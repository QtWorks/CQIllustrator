CONCAT_ID=##concat##
##concat##CQAccelerate.cpp
/*
    Copyright (c) 2008-10 Qtrac Ltd. All rights reserved.
    This program or module is free software: you can redistribute it
    and/or modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation, either version 2 of
    the License, or version 3 of the License, or (at your option) any
    later version. This program is distributed in the hope that it will
    be useful, but WITHOUT ANY WARRANTY; without even the implied
    warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    See the GNU General Public License for more details.
*/

#include <CQAccelerate.h>
#include <CKuhnMunkres.h>
#include <QAbstractButton>
#include <QAction>
#include <QGroupBox>
#include <QLabel>
#include <QMenu>
#include <QSet>
#include <QToolButton>
#include <limits>

namespace {

typedef QSet<QChar> CharSet;

struct StringItem {
  explicit StringItem(const QString &string_=QString(), const CharSet alphabet=CharSet()) :
   string(string_), ustring(string_.toUpper()) {
    foreach (const QChar &c, ustring)
      if (alphabet.contains(c))
        unique.insert(c);
  }

  void calculateWeights(int sizeOfAlphabet) {
    const double factor = unique.count() / static_cast<double>(sizeOfAlphabet);

    QList<QChar> characters = QList<QChar>::fromSet(unique);

    qSort(characters);

    double weight;

    foreach (const QChar &c, characters) {
      if      (ustring[0] == c)    // First character's weight
        weight = factor;
      else if (ustring.contains(QString(" %1").arg(c))) {
        int pos = string.indexOf(QString(" %1").arg(c));

        if (pos > -1)       // Capital start of word's weight
          weight = factor * 10;
        else {              // Start of word's weight
          weight = factor * 100;
          pos = ustring.indexOf(QString(" %1").arg(c));
        }

        weight += pos;
      }
      else                    // Any character's weight
        weight = (factor * 1000) + ustring.indexOf(c);

      weightOf[c] = weight;
    }
  }

  QString              string;
  QString              ustring;
  CharSet              unique;
  QHash<QChar, double> weightOf;
};

QStringList
accelerated_(const QStringList &strings, const CharSet &alphabet)
{
  const double Invalid = std::numeric_limits<double>::max();

  QList<StringItem> items;

  foreach (const QString &string, strings)
    items.append(StringItem(string, alphabet));

  CharSet alphabetSet;

  foreach (const StringItem &item, items)
    alphabetSet |= item.unique;

  QList<QChar> characters = QList<QChar>::fromSet(alphabetSet);

  qSort(characters);

  QString alphabetString;

  foreach (const QChar &c, characters)
    alphabetString.append(c);

  const int rows    = items.count();
  const int columns = alphabetString.count();

  CKuhnMunkres::Grid grid;

  for (int row = 0; row < rows; ++row) {
    StringItem &item = items[row];

    item.calculateWeights(alphabetString.count());

    CKuhnMunkres::Row rowData;

    foreach (const QChar &c, alphabetString)
      rowData.push_back(item.weightOf.value(c, Invalid));

    grid.push_back(rowData);
  }

  CKuhnMunkres km;

  CKuhnMunkres::Indexes indexes = km.calculate(grid);

  QStringList results;

  foreach (const CKuhnMunkres::Index &index, indexes) {
    int row    = index.first;
    int column = index.second;

    if (row >= rows || column >= columns)  continue;

    StringItem &item = items[row];

    QString string = item.string;

    if (grid.at(row).at(column) < Invalid) {
      const QChar &c = alphabetString.at(column);

      if (c == item.ustring.at(0))
        string = QString("&%1").arg(item.string);
      else {
        int i = item.ustring.indexOf(QString(" %1").arg(c));

        if (i > -1)
          ++i;
        else
          i = item.ustring.indexOf(c);

        string = item.string.left(i) + "&" + item.string.mid(i);
      }
    }

    results.append(string);
  }

  return results;
}

} // anonymous namespace

namespace CQAccelerate {

/*
   Returns a copy of the given strings but with accelerators inserted
   where possible. Accelerators are only chosen from the given alphabet
   (which defaults to 0-9A-Z).
*/
QStringList accelerated(const QStringList &strings, const QString &alphabet)
{
  CharSet alphabetSet;

  foreach (const QChar &c, alphabet.toUpper())
    alphabetSet.insert(c);

  QStringList fullResults;
  QStringList newStrings;

  foreach (const QString &string, strings) {
    QString string_copy = string;

    string_copy = string_copy.replace("&&", "");

    int i = string_copy.indexOf("&");

    if (i > -1 && i + 1 < string_copy.length()) {
      alphabetSet.remove(string_copy[string_copy.indexOf("&") + 1].toUpper());

      fullResults.append(string);
    }
    else {
      fullResults.append(QString());

      newStrings.append(string);
    }
  }

  if (newStrings.isEmpty()) // They're already accelerated
    return strings;

  QStringList results = accelerated_(newStrings, alphabetSet);

  for (int i = 0; i < fullResults.count(); ++i) {
    if (fullResults.at(i).isEmpty())
      fullResults[i] = results.isEmpty() ? strings.at(i) : results.takeFirst();
  }

  return fullResults;
}

/*
    Adds accelerators to every action that has text in the menu or menu
    bar, and to all the menu or menu bar's menus and sub-menus,
    recursively.
*/
void accelerateMenu(QWidget *menuOrMenuBar, const QString &alphabet)
{
  Q_ASSERT(menuOrMenuBar->inherits("QMenuBar") || menuOrMenuBar->inherits("QMenu"));

  accelerateActions(menuOrMenuBar->actions());

  foreach (QMenu *menu, menuOrMenuBar->findChildren<QMenu*>())
    accelerateActions(menu->actions(), alphabet);
}

/*
    Adds accelerators to every action that has text, but skipping separators.
*/
void accelerateActions(QList<QAction*> actions, const QString &alphabet)
{
  QStringList texts;

  QList<QAction*> acceleratedActions;

  foreach (QAction *action, actions) {
    if (action->isSeparator()) continue;

    const QString &text = action->text();

    if (! text.isEmpty()) {
      texts              << action->text();
      acceleratedActions << action;
    }

    if (QMenu *menu = action->menu())
      accelerateMenu(menu, alphabet);
  }

  texts = accelerated(texts, alphabet);

  Q_ASSERT(isValid(texts, 0, alphabet));

  for (int i = 0; i < texts.count(); ++i)
    acceleratedActions.at(i)->setText(texts.at(i));
}

/*
    Adds accelerators to all labels that have buddies and all abstract
    button's that have a text and all group boxes that are checkable and
    have a text that are children of the given widget.
*/
void
accelerateWidget(QWidget *widget, const QString &alphabet)
{
  QStringList texts;

  QList<QWidget*> widgets;

  foreach (QLabel *label, widget->findChildren<QLabel*>()) {
    if (label->buddy() && ! label->text().isEmpty()) {
      texts   << label->text();
      widgets << label;
    }
  }

  foreach (QAbstractButton *button, widget->findChildren<QAbstractButton*>()) {
    if (! qobject_cast<QToolButton*>(button) && ! button->text().isEmpty()) {
      texts   << button->text();
      widgets << button;
    }
  }

  foreach (QGroupBox *groupBox, widget->findChildren<QGroupBox*>()) {
    if (groupBox->isCheckable() && ! groupBox->title().isEmpty()) {
      texts   << groupBox->title();
      widgets << groupBox;
    }
  }

  texts = accelerated(texts, alphabet);

  Q_ASSERT(isValid(texts, 0, alphabet));

  for (int i = 0; i < texts.count(); ++i) {
    if (QLabel *label = qobject_cast<QLabel*>(widgets.at(i))) {
      label->setText(texts.at(i));
      continue;
    }
    if (QGroupBox *groupBox = qobject_cast<QGroupBox*>(widgets.at(i))) {
      groupBox->setTitle(texts.at(i));
      continue;
    }
    QAbstractButton *button = qobject_cast<QAbstractButton*>(widgets.at(i));
    Q_ASSERT(button);
    button->setText(texts.at(i));
  }
}

/*
    Adds accelerators to all the widgets in the list that are labels
    that have buddies or that are abstract button's that have a text or
    that are group boxes that are checkable and have a text.
*/
void
accelerateWidgets(QList<QWidget*> widgets, const QString &alphabet)
{
  QStringList texts;

  foreach (QWidget *widget, widgets) {
    QLabel *label = qobject_cast<QLabel*>(widget);
    if (label && label->buddy() && !label->text().isEmpty()) {
      texts << label->text();
      continue;
    }
    QGroupBox *groupBox = qobject_cast<QGroupBox*>(widget);
    if (groupBox && groupBox->isCheckable() && !groupBox->title().isEmpty()) {
      texts << groupBox->title();
      continue;
    }
    QAbstractButton *button = qobject_cast<QAbstractButton*>(widget);
    if (button && !qobject_cast<QToolButton*>(button) && !button->text().isEmpty())
      texts << button->text();
    else
      texts << QString();
  }

  texts = accelerated(texts, alphabet);

  Q_ASSERT(isValid(texts, 0, alphabet));

  for (int i = 0; i < texts.count(); ++i) {
    const QString &text = texts.at(i);

    if (text.isEmpty()) continue;

    if (QLabel *label = qobject_cast<QLabel*>(widgets.at(i))) {
      label->setText(text);
      continue;
    }
    if (QGroupBox *groupBox = qobject_cast<QGroupBox*>(widgets.at(i))) {
      groupBox->setTitle(text);
      continue;
    }
    QAbstractButton *button = qobject_cast<QAbstractButton*>(widgets.at(i));
    Q_ASSERT(button);
    button->setText(text);
  }
}

/*
   Returns true if all the strings are valid (i.e., each one has a
   unique accelerator---or no accelerator) and ignores where. Otherwise
   returns false and sets where to the (index of string, column) for the
   first string that is invalid (e.g., has a duplicate accelerator).
*/
bool
isValid(const QStringList &listOfStrings, QPair<int, int> *where, const QString &alphabet)
{
  CharSet seen;

  for (int i = 0; i < listOfStrings.count(); ++i) {
    QString string = listOfStrings.at(i);

    string = string.replace("&&", "");

    int j = string.indexOf("&");

    if (j > -1 && j + 1 < string.length()) {
      const QChar c = string.at(j + 1).toUpper();

      if (seen.contains(c) || !alphabet.contains(c)) {
        if (where) {
          where->first  = i;
          where->second = j;
        }
        return false;
      }
      seen.insert(c);
    }
  }
  return true;
}

/*
   Returns a quality value in the range 0.0 (worst) to 1.0 (best).
   The best quality is when a string has an accelerator for its first
   character, second best is an accelerator for a start of word, third
   best is any accelerator at all, and worst is no accelerator.
*/
double
quality(const QStringList &listOfStrings)
{
  enum {FIRST_CHARACTER = 4, START_OF_WORD = 2, IN_STRING = 1};

  int done   = 0;
  int weight = 0;

  foreach (QString string, listOfStrings) {
    string = string.replace("&&", "");

    ++done;

    if      (string.at(0) == QChar('&'))
      weight += FIRST_CHARACTER;
    else if (string.contains(" &"))
      weight += START_OF_WORD;
    else if (string.contains("&"))
      weight += IN_STRING;
    else
      --done;
  }

  double range = (listOfStrings.count() * static_cast<int>(FIRST_CHARACTER));

  return ((weight * (done / static_cast<double>(listOfStrings.count()))) / range);
}

/*
   Returns the number of strings in the given list that have accelerators.
*/
int
numberAccelerated(const QStringList &listOfStrings)
{
  int count = 0;

  foreach (QString string, listOfStrings) {
    string = string.replace("&&", "");

    int i = string.indexOf("&");

    if (i > -1 && i + 1 < string.length())
      ++count;
  }

  return count;
}

}
##concat##CQAlphaButton.cpp
#include <CQAlphaButton.h>

#include <QPainter>
#include <QMouseEvent>

CQAlphaButton::
CQAlphaButton(QWidget *parent) :
 QWidget(parent), alpha_(1.0), fg_(0,0,0), bg_(196,196,196)
{
  setFixedWidth(8);

  setToolTip(QString("%1").arg(alpha_));
}

void
CQAlphaButton::
setColor(QColor fg)
{
  fg_ = fg;

  update();
}

double
CQAlphaButton::
getAlpha() const
{
  return alpha_;
}

void
CQAlphaButton::
setAlpha(double alpha)
{
  alpha_ = alpha;

  setToolTip(QString("%1").arg(alpha_));

  update();
}

void
CQAlphaButton::
paintEvent(QPaintEvent *)
{
  QPainter p(this);

  int w = width();
  int h = height();

  int pos = alphaToPos();

  double dg = (h > 1 ? 1.0/(h - 1) : 0.0);

  int fr = fg_.red  ();
  int fg = fg_.green();
  int fb = fg_.blue ();

  int br = bg_.red  ();
  int bg = bg_.green();
  int bb = bg_.blue ();

  for (int i = 0; i < h; ++i) {
    double rg  = (h - 1 - i)*dg;
    double rg1 = 1 - rg;

    int ir1 = std::min(int(br*rg1 + fr*rg), 255);
    int ig1 = std::min(int(bg*rg1 + fg*rg), 255);
    int ib1 = std::min(int(bb*rg1 + fb*rg), 255);

    QColor c(ir1, ig1, ib1);

    p.setPen(c);

    p.drawLine(0, i, w - 1, i);
  }

  QColor c(255, 0, 0);

  p.setPen(c);

  p.drawLine(0, pos, w - 1, pos);
}

void
CQAlphaButton::
mousePressEvent(QMouseEvent *e)
{
  posToAlpha(e->pos().y());

  update();
}

void
CQAlphaButton::
mouseMoveEvent(QMouseEvent *e)
{
  posToAlpha(e->pos().y());

  update();
}

void
CQAlphaButton::
mouseReleaseEvent(QMouseEvent *e)
{
  posToAlpha(e->pos().y());

  update();
}

void
CQAlphaButton::
posToAlpha(int pos)
{
  double alpha = std::min(std::max(0.0, (1.0*pos)/(height() - 1)), 1.0);

  setAlpha(1.0 - alpha);

  emit valueChanged();
}

int
CQAlphaButton::
alphaToPos()
{
  int pos = std::min(std::max(0, int(alpha_*(height() - 1))), height() - 1);

  return (height() - 1 - pos);
}
##concat##CQAngleSpinBox.cpp
#include <CQAngleSpinBox.h>

namespace {
const QChar Degree(0xB0);
}

CQAngleSpinBox::
CQAngleSpinBox(QWidget *parent, double value) :
 QDoubleSpinBox(parent)
{
  init("edit", value);
}

CQAngleSpinBox::
CQAngleSpinBox(double value) :
 QDoubleSpinBox(0)
{
  init("edit", value);
}

double
CQAngleSpinBox::
getValue() const
{
  return value();
}

void
CQAngleSpinBox::
init(const QString &name, double value)
{
  if (name.length()) setObjectName(name);

  setRange(-360.0, 360.0);

  setAlignment(Qt::AlignVCenter|Qt::AlignRight);

  setDecimals(1);

  setSuffix(Degree);

  connect(this, SIGNAL(valueChanged(double)), this, SIGNAL(angleChanged(double)));

  setValue(value);
}
##concat##CQColorChooser.cpp
#include <CQColorChooser.h>
#include <CQAlphaButton.h>
#include <CRGBName.h>

#include <CQUtil.h>
#include <color_dialog.xpm>

#include <QLineEdit>
#include <QPushButton>
#include <QToolButton>
#include <QLabel>
#include <QHBoxLayout>
#include <QColorDialog>

CQColorChooser::
CQColorChooser(QWidget *parent) :
 QWidget(parent), styles_(Text), editable_(true)
{
  init();
}

CQColorChooser::
CQColorChooser(uint styles, QWidget *parent) :
 QWidget(parent), styles_(styles), editable_(true)
{
  init();
}

void
CQColorChooser::
init()
{
  color_     = QColor(1,2,3);
  alpha_     = 0.456;
  colorName_ = "abcdef";

  //-----

  QHBoxLayout *layout = new QHBoxLayout(this);

  layout->setMargin (2);
  layout->setSpacing(2);

  cedit_   = new QLineEdit  (this); // text color
  cbutton_ = new QToolButton(this); // click color button
  clabel_  = new QLabel     (this); // static color button
  button_  = new QToolButton(this); // image click button
  alphab_  = new CQAlphaButton(this);

  cbutton_->setFixedSize(QSize(24,24));
  clabel_ ->setFixedSize(QSize(24,24));
  button_ ->setFixedSize(QSize(24,24));

  button_->setIcon(QIcon(QPixmap((const char **) color_dialog_data)));

  layout->addWidget(cedit_  );
  layout->addWidget(cbutton_);
  layout->addWidget(clabel_ );
  layout->addWidget(alphab_ );
  layout->addWidget(button_ );
  layout->addStretch();

  cedit_  ->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Fixed);
  cbutton_->setSizePolicy(QSizePolicy::Fixed    , QSizePolicy::Fixed);
  clabel_ ->setSizePolicy(QSizePolicy::Fixed    , QSizePolicy::Fixed);
  button_ ->setSizePolicy(QSizePolicy::Fixed    , QSizePolicy::Fixed);

  connect(cedit_  , SIGNAL(editingFinished()), this, SLOT(textColorChanged()));
  connect(cbutton_, SIGNAL(clicked()), this, SLOT(colorButtonClicked()));
  connect(button_ , SIGNAL(clicked()), this, SLOT(imageButtonClicked()));
  connect(alphab_ , SIGNAL(valueChanged()), this, SLOT(alphaButtonChanged()));

  update();

  setColor(color_, alpha_);

  setFocusProxy(cedit_);
}

void
CQColorChooser::
setEditable(bool editable)
{
  editable_ = editable;

  update();
}

void
CQColorChooser::
setStyles(uint styles)
{
  styles_ = styles;

  update();
}

void
CQColorChooser::
update()
{
  cedit_  ->setVisible(styles_ & Text       );
  cbutton_->setVisible(styles_ & ColorButton);
  clabel_ ->setVisible(styles_ & ColorLabel );
  button_ ->setVisible(styles_ & ImageButton);
  alphab_ ->setVisible(styles_ & AlphaButton);

  cedit_->setReadOnly(! editable_);
}

void
CQColorChooser::
setColor(const QColor &color, double alpha)
{
  if (! color.isValid())
    return;

  QColor color1(color);

  color1.setAlpha(255);

  if (color_ == color1 && alpha_ == alpha_)
    return;

  color_     = color1;
  colorName_ = color_.name();

  cedit_->setText(colorName_);

  QPixmap pixmap(24, 24);

  pixmap.fill(color_);

  cbutton_->setIcon(QIcon(QPixmap(pixmap)));

  CQUtil::setBackground(clabel_, color_);

  alpha_ = alpha;

  alphab_->setColor(color1);
  alphab_->setAlpha(alpha_);
}

void
CQColorChooser::
setRGBA(const CRGBA &rgba)
{
  setColor(CQUtil::rgbaToColor(rgba));
}

CRGBA
CQColorChooser::
getRGBA() const
{
  return CQUtil::colorToRGBA(color());
}

void
CQColorChooser::
setColorName(const QString &colorName, double alpha)
{
  QColor color = CQUtil::rgbaToColor(CRGBName::toRGBA(colorName.toStdString()));

  if (! color.isValid())
    return;

  QColor color1(color);

  color1.setAlpha(255);

  if (color_ == color1 && alpha_ == alpha_)
    return;

  color_     = color1;
  colorName_ = colorName;

  cedit_->setText(colorName_);

  QPixmap pixmap(24, 24);

  pixmap.fill(color_);

  cbutton_->setIcon(QIcon(QPixmap(pixmap)));

  CQUtil::setBackground(clabel_, color_);

  alpha_ = alpha;

  alphab_->setAlpha(alpha_);
}

const QColor &
CQColorChooser::
color() const
{
  return color_;
}

QString
CQColorChooser::
colorName() const
{
  return colorName_;
}

void
CQColorChooser::
setAlpha(double alpha)
{
  alpha_ = alpha;

  alphab_->setAlpha(alpha_);
}

double
CQColorChooser::
getAlpha() const
{
  return alpha_;
}

void
CQColorChooser::
textColorChanged()
{
  setColorName(cedit_->text(), alpha_);

  changeColor();
}

void
CQColorChooser::
imageButtonClicked()
{
  QColor color = QColorDialog::getColor(color_, this);

  setColor(color, alpha_);

  changeColor();
}

void
CQColorChooser::
colorButtonClicked()
{
  QColor color = QColorDialog::getColor(color_, this);

  setColor(color, alpha_);

  changeColor();
}

void
CQColorChooser::
alphaButtonChanged()
{
  setAlpha(alphab_->getAlpha());

  changeColor();
}

void
CQColorChooser::
changeColor()
{
  QColor color(color_);

  color_.setAlpha(255*alpha_);

  emit colorChanged(color);
  emit colorChanged(colorName_);
}

void
CQColorChooser::
applyColor()
{
  QColor color(color_);

  color_.setAlpha(255*alpha_);

  emit colorApplied(color);
  emit colorApplied(colorName_);
}
##concat##CQFillOption.cpp
#include <CQFillOption.h>
#include <CQIllustrator.h>
#include <CQColorChooser.h>
#include <CQUtil.h>
#include <CQRealEdit.h>
#include <CQPointEdit.h>
#include <CQImageButton.h>
#include <CQImagePreview.h>
#include <CLinearGradient.h>
#include <CRadialGradient.h>
#include <COSFile.h>

#include <CQGradientStopList.h>

#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QGridLayout>
#include <QLabel>
#include <QComboBox>
#include <QCheckBox>
#include <QPushButton>
#include <QDoubleSpinBox>
#include <QStackedWidget>
#include <QFileDialog>
#include <QPainter>

#include <xpm/flat.xpm>
#include <xpm/lgradient.xpm>
#include <xpm/rgradient.xpm>
#include <xpm/image.xpm>

class CQFillOptionSwab : public QWidget {
 public:
  CQFillOptionSwab(CQFillOptionDialog *dialog);

 private:
  void paintEvent(QPaintEvent *e);

 private:
  CQFillOptionDialog *dialog_;
};

//----------

CQFillOptionTool::
CQFillOptionTool(CQIllustrator *illustrator) :
 CQOptionTool(), illustrator_(illustrator), dialog_(0)
{
  dialog_ = new CQFillOptionDialog(this);

  QVBoxLayout *layout = new QVBoxLayout(this);
  layout->setMargin(0); layout->setSpacing(0);

  QLabel *label = new QLabel("<small><b>Fill</b></small>");

  layout->addWidget(label);

  swab_ = new CQFillOptionSwab(dialog_);

  layout->addWidget(swab_);

  connect(dialog_, SIGNAL(valueChanged(const CQIllustratorShapeFill &)),
          this, SIGNAL(valueChanged(const CQIllustratorShapeFill &)));

  connect(dialog_, SIGNAL(clipChanged(bool)),
          this, SIGNAL(clipChanged(bool)));

  connect(illustrator_, SIGNAL(selectionChanged()),
          this, SLOT(selectionChangedSlot()));
  connect(illustrator_, SIGNAL(fillChanged()),
          this, SLOT(selectionChangedSlot()));
}

CQOptionToolDialog *
CQFillOptionTool::
getDialog()
{
  return dialog_;
}

void
CQFillOptionTool::
selectionChangedSlot()
{
  const CQIllustratorShape *shape = 0;

  const CQIllustratorSelectedShapes *selection = illustrator_->getSelection();

  uint num_selected = selection->size();

  if (num_selected == 1) {
    const CQIllustratorSelectedShape &sshape = selection->front();

    shape = sshape.getShape();
  }

  CQIllustratorShapeFill fill;

  if (shape)
    fill = shape->getFill();
  else
    fill = illustrator_->getDefaultFill();

  dialog_->setFill(fill);

  swab_->update();
}

//----------

CQFillOptionSwab::
CQFillOptionSwab(CQFillOptionDialog *dialog) :
 dialog_(dialog)
{
  setFixedSize(32, 16);
}

void
CQFillOptionSwab::
paintEvent(QPaintEvent *)
{
  QPainter painter(this);

  const CQIllustratorShapeFill &fill = dialog_->getFill();

  if (fill.hasGradient()) {
    const CGenGradient *g = fill.getGradient();

    const CLinearGradient *lg = 0;
    const CRadialGradient *rg = 0;

    if      ((lg = dynamic_cast<const CLinearGradient *>(g)) != 0) {
      QBrush brush(CQUtil::toQGradient(lg));

      painter.setBrush(brush);
    }
    else if ((rg = dynamic_cast<const CRadialGradient *>(g)) != 0) {
      QBrush brush(CQUtil::toQGradient(rg));

      painter.setBrush(brush);
    }
  }
  else {
    CRGBA color = fill.getColor();

    QBrush brush(CQUtil::rgbaToColor(color));

    painter.setBrush(brush);
  }

  painter.drawRect(rect());
}

//----------

CQFillOptionDialog::
CQFillOptionDialog(CQFillOptionTool *tool) :
 CQOptionToolDialog(), tool_(tool), colorChooser_(0)
{
  initWidgets();
}

void
CQFillOptionDialog::
setFill(const CQIllustratorShapeFill &fill)
{
  fill_ = fill;

  setActiveState();

  updateWidgets();
}

void
CQFillOptionDialog::
initWidgets()
{
  QVBoxLayout *layout = new QVBoxLayout(this);
  layout->setMargin(0); layout->setSpacing(0);

  //-----

  QHBoxLayout *buttonLayout = new QHBoxLayout;
  buttonLayout->setMargin(2); buttonLayout->setSpacing(8);

  flatButton_  = new CQImageButton(QPixmap(flat_data     ));
  lgradButton_ = new CQImageButton(QPixmap(lgradient_data));
  rgradButton_ = new CQImageButton(QPixmap(rgradient_data));
  imageButton_ = new CQImageButton(QPixmap(image_data    ));

  flatButton_ ->setCheckable(true);
  lgradButton_->setCheckable(true);
  rgradButton_->setCheckable(true);
  imageButton_->setCheckable(true);

  buttonLayout->addWidget(flatButton_);
  buttonLayout->addWidget(lgradButton_);
  buttonLayout->addWidget(rgradButton_);
  buttonLayout->addWidget(imageButton_);
  buttonLayout->addStretch();

  layout->addLayout(buttonLayout);

  connect(flatButton_ , SIGNAL(clicked()), this, SLOT(flatSlot()));
  connect(lgradButton_, SIGNAL(clicked()), this, SLOT(lgradSlot()));
  connect(rgradButton_, SIGNAL(clicked()), this, SLOT(rgradSlot()));
  connect(imageButton_, SIGNAL(clicked()), this, SLOT(imageSlot()));

  //-----

  stack_ = new QStackedWidget;

  layout->addWidget(stack_);

  //-----

  // Normal Fill

  QWidget *flatPanel = new QWidget;

  stack_->addWidget(flatPanel);

  QGridLayout *flatLayout = new QGridLayout(flatPanel);

  flatLayout->setMargin(2); flatLayout->setSpacing(2);

  flatLayout->addWidget(new QLabel("Color"  ), 0, 0);
  flatLayout->addWidget(new QLabel("Opacity"), 1, 0);
  flatLayout->addWidget(new QLabel("Rule"   ), 2, 0);
  flatLayout->addWidget(new QLabel("Clip"   ), 3, 0);

  colorChooser_ = new CQColorChooser;

  colorChooser_->setStyles(CQColorChooser::ColorButton);

  connect(colorChooser_, SIGNAL(colorChanged(const QColor &)),
          this, SLOT(colorSlot(const QColor &)));

  opacityEdit_ = new QDoubleSpinBox;

  opacityEdit_->setRange(0.0, 1.0);
  opacityEdit_->setSingleStep(0.1);
  opacityEdit_->setDecimals(5);
//opacityEdit_->setRange(0.00, 1.0, 5);

  connect(opacityEdit_, SIGNAL(valueChanged(double)),
          this, SLOT(opacitySlot(double)));

  fillRule_ = new QComboBox;

  fillRule_->addItems(QStringList() << "Winding" << "Even Odd");

  connect(fillRule_, SIGNAL(currentIndexChanged(const QString &)),
          this, SLOT(fillRuleSlot(const QString &)));

  clipCheck_ = new QCheckBox("Yes");

  connect(clipCheck_, SIGNAL(clicked(bool)), this, SLOT(clipSlot()));

  flatLayout->addWidget(colorChooser_, 0, 1);
  flatLayout->addWidget(opacityEdit_ , 1, 1);
  flatLayout->addWidget(fillRule_    , 2, 1);
  flatLayout->addWidget(clipCheck_   , 3, 1);

  flatLayout->setRowStretch(4, 1);

  //-----

  // Linear Gradient

  QWidget *lgradPanel = new QWidget;

  stack_->addWidget(lgradPanel);

  QVBoxLayout *lgradLayout = new QVBoxLayout(lgradPanel);

  lgradLayout->setMargin(0); lgradLayout->setSpacing(0);

  QGridLayout *lgradEditLayout = new QGridLayout;

  lgradEditLayout->setMargin(2); lgradEditLayout->setSpacing(2);

  lgradLayout->addLayout(lgradEditLayout);

  lgradEditLayout->addWidget(new QLabel("Start"), 0, 0);
  lgradEditLayout->addWidget(new QLabel("End"  ), 1, 0);

  lgrad1_ = new CQPointEdit;
  lgrad2_ = new CQPointEdit;

  connect(lgrad1_, SIGNAL(valueChanged()), this, SLOT(updateLGrad()));
  connect(lgrad2_, SIGNAL(valueChanged()), this, SLOT(updateLGrad()));

  lgradEditLayout->addWidget(lgrad1_, 0, 1);
  lgradEditLayout->addWidget(lgrad2_, 1, 1);

  lgradStops_ = new CQGradientStopList;

  connect(lgradStops_, SIGNAL(stopsChanged()), this, SLOT(updateLGradStops()));

  lgradLayout->addWidget(lgradStops_);

  QHBoxLayout *lbuttonLayout = new QHBoxLayout;

  lgradLayout->addLayout(lbuttonLayout);

  QPushButton *addLGradStopButton    = new QPushButton("Add");
  QPushButton *deleteLGradStopButton = new QPushButton("Delete");

  connect(addLGradStopButton   , SIGNAL(clicked()), this, SLOT(addLGradStop()));
  connect(deleteLGradStopButton, SIGNAL(clicked()), this, SLOT(removeLGradStop()));

  lbuttonLayout->addWidget(addLGradStopButton);
  lbuttonLayout->addWidget(deleteLGradStopButton);

  //-----

  // Radial Gradient

  QWidget *rgradPanel = new QWidget;

  stack_->addWidget(rgradPanel);

  QVBoxLayout *rgradLayout = new QVBoxLayout(rgradPanel);

  rgradLayout->setMargin(0); rgradLayout->setSpacing(0);

  QGridLayout *rgradEditLayout = new QGridLayout;

  rgradEditLayout->setMargin(2); rgradEditLayout->setSpacing(2);

  rgradLayout->addLayout(rgradEditLayout);

  rgradEditLayout->addWidget(new QLabel("Center"), 0, 0);
  rgradEditLayout->addWidget(new QLabel("Radius"), 1, 0);
  rgradEditLayout->addWidget(new QLabel("Focus" ), 2, 0);

  rgradC_ = new CQPointEdit;
  rgradR_ = new CQRealEdit;
  rgradF_ = new CQPointEdit;

  connect(rgradC_, SIGNAL(valueChanged()), this, SLOT(updateRGrad()));
  connect(rgradR_, SIGNAL(valueChanged(double)), this, SLOT(updateRGrad()));
  connect(rgradF_, SIGNAL(valueChanged()), this, SLOT(updateRGrad()));

  rgradEditLayout->addWidget(rgradC_, 0, 1);
  rgradEditLayout->addWidget(rgradR_, 1, 1);
  rgradEditLayout->addWidget(rgradF_, 2, 1);

  rgradStops_ = new CQGradientStopList;

  connect(rgradStops_, SIGNAL(stopsChanged()), this, SLOT(updateRGradStops()));

  rgradLayout->addWidget(rgradStops_);

  QHBoxLayout *rbuttonLayout = new QHBoxLayout;

  rgradLayout->addLayout(rbuttonLayout);

  QPushButton *addRGradStopButton    = new QPushButton("Add");
  QPushButton *deleteRGradStopButton = new QPushButton("Delete");

  connect(addRGradStopButton   , SIGNAL(clicked()), this, SLOT(addRGradStop()));
  connect(deleteRGradStopButton, SIGNAL(clicked()), this, SLOT(removeRGradStop()));

  rbuttonLayout->addWidget(addRGradStopButton);
  rbuttonLayout->addWidget(deleteRGradStopButton);

  //-----

  // Image

  QWidget *imagePanel = new QWidget;

  stack_->addWidget(imagePanel);

  QVBoxLayout *imageLayout = new QVBoxLayout(imagePanel);

  imagePreview_ = new CQImagePreview;

  imagePreview_->setFixedSize(256, 256);

  imageLayout->addWidget(imagePreview_);

  QPushButton *setImage = new QPushButton("Set Image ...");

  connect(setImage, SIGNAL(clicked()), this, SLOT(setImageSlot()));

  imageLayout->addWidget(setImage);

  imageScale_ = new QComboBox;

  imageScale_->addItems(QStringList() << "None" << "Fit" << "Equal");

  connect(imageScale_, SIGNAL(currentIndexChanged(const QString &)),
          this, SLOT(imageScaleSlot(const QString &)));

  imageLayout->addWidget(imageScale_);

  //-----

  QHBoxLayout *buttonLayout1 = new QHBoxLayout;

  QPushButton *defButton = new QPushButton("Set Default");
  QPushButton *bgButton  = new QPushButton("Set Background");

  connect(defButton, SIGNAL(clicked()), this, SLOT(setDefaultSlot()));
  connect(bgButton , SIGNAL(clicked()), this, SLOT(setBackgroundSlot()));

  buttonLayout1->addWidget(defButton);
  buttonLayout1->addWidget(bgButton);

  layout->addLayout(buttonLayout1);

  //-----

  setActiveState();
}

void
CQFillOptionDialog::
flatSlot()
{
  stack_->setCurrentIndex(0);

  if (fill_.hasGradient() || fill_.hasImage()) {
    fill_.setGradient(0);
    fill_.resetImage();

    emit valueChanged(fill_);

    updateWidgets();
  }

  setActiveState();
}

void
CQFillOptionDialog::
lgradSlot()
{
  stack_->setCurrentIndex(1);

  const CLinearGradient *lg = 0;

  if (fill_.hasGradient()) {
    const CGenGradient *g = fill_.getGradient();

    lg = dynamic_cast<const CLinearGradient *>(g);
  }

  if (lg == 0) {
    CLinearGradient *lg1 = new CLinearGradient;

    lg1->addStop(0.0, CRGBA(1,1,1));
    lg1->addStop(1.0, CRGBA(0,0,0));

    fill_.setGradient(lg1);
    fill_.resetImage();

    emit valueChanged(fill_);

    updateWidgets();

    lg = lg1;
  }

  setActiveState();
}

void
CQFillOptionDialog::
rgradSlot()
{
  stack_->setCurrentIndex(2);

  const CRadialGradient *rg = 0;

  if (fill_.hasGradient()) {
    const CGenGradient *g = fill_.getGradient();

    rg = dynamic_cast<const CRadialGradient *>(g);
  }

  if (rg == 0) {
    CRadialGradient *rg1 = new CRadialGradient;

    rg1->addStop(0.0, CRGBA(1,1,1));
    rg1->addStop(1.0, CRGBA(0,0,0));

    fill_.setGradient(rg1);
    fill_.resetImage();

    emit valueChanged(fill_);

    updateWidgets();

    rg = rg1;
  }

  setActiveState();
}

void
CQFillOptionDialog::
imageSlot()
{
  stack_->setCurrentIndex(3);

  if (! fill_.hasImage()) {
    fill_.setImage(CImagePtr());
    fill_.setGradient(0);

    emit valueChanged(fill_);

    updateWidgets();
  }

  setActiveState();
}

void
CQFillOptionDialog::
setActiveState()
{
  const CLinearGradient *lg = 0;
  const CRadialGradient *rg = 0;

  bool is_image = false;

  if      (fill_.hasGradient()) {
    const CGenGradient *g = fill_.getGradient();

    lg = dynamic_cast<const CLinearGradient *>(g);
    rg = dynamic_cast<const CRadialGradient *>(g);
  }
  else if (fill_.hasImage()) {
    is_image = true;
  }

  flatButton_ ->setChecked(! is_image && ! lg && ! rg);
  lgradButton_->setChecked(lg);
  rgradButton_->setChecked(rg);
  imageButton_->setChecked(is_image);
}

void
CQFillOptionDialog::
updateWidgets()
{
  const CLinearGradient *lg = 0;
  const CRadialGradient *rg = 0;

  bool is_image = false;

  if      (fill_.hasGradient()) {
    const CGenGradient *g = fill_.getGradient();

    lg = dynamic_cast<const CLinearGradient *>(g);

    if (lg != 0) {
      stack_->setCurrentIndex(1);

      lgrad1_->setValue(lg->getPoint1());
      lgrad2_->setValue(lg->getPoint2());

      lgradStops_->init(*lg);
    }

    rg = dynamic_cast<const CRadialGradient *>(g);

    if (rg != 0) {
      stack_->setCurrentIndex(2);

      rgradC_->setValue(rg->getCenter());
      rgradR_->setValue(rg->getRadius());
      rgradF_->setValue(rg->getFocus ());

      rgradStops_->init(*rg);
    }
  }
  else if (fill_.hasImage()) {
    stack_->setCurrentIndex(3);

    imagePreview_->setImage(fill_.getImage());

    is_image = true;
  }
  else {
    stack_->setCurrentIndex(0);

    colorChooser_->setColor(CQUtil::rgbaToColor(fill_.getColor()));
    opacityEdit_ ->setValue(fill_.getOpacity());
    fillRule_    ->setCurrentIndex(fill_.getFillRule() == FILL_TYPE_WINDING ? 0 : 1);
  }

  colorChooser_->setEnabled(lg == 0 && rg == 0 && ! is_image);
  opacityEdit_ ->setEnabled(lg == 0 && rg == 0 && ! is_image);
  fillRule_    ->setEnabled(lg == 0 && rg == 0 && ! is_image);

  lgrad1_     ->setEnabled(lg != 0);
  lgrad2_     ->setEnabled(lg != 0);
  lgradStops_ ->setEnabled(lg != 0);

  rgradC_    ->setEnabled(rg != 0);
  rgradR_    ->setEnabled(rg != 0);
  rgradF_    ->setEnabled(rg != 0);
  rgradStops_->setEnabled(rg != 0);

  imagePreview_->setEnabled(is_image);
}

void
CQFillOptionDialog::
colorSlot(const QColor &color)
{
  fill_.setColor(CQUtil::colorToRGBA(color));

  tool_->update();

  emit valueChanged(fill_);
}

void
CQFillOptionDialog::
opacitySlot(double value)
{
  fill_.setOpacity(value);

  tool_->update();

  emit valueChanged(fill_);
}

void
CQFillOptionDialog::
fillRuleSlot(const QString &rule)
{
  fill_.setFillRule(rule == "Winding" ? FILL_TYPE_WINDING : FILL_TYPE_EVEN_ODD);

  tool_->update();

  emit valueChanged(fill_);
}

void
CQFillOptionDialog::
clipSlot()
{
  bool value = clipCheck_->isChecked();

  emit clipChanged(value);
}

void
CQFillOptionDialog::
updateLGrad()
{
  CGenGradient *g = fill_.getGradient();

  CLinearGradient *lg = dynamic_cast<CLinearGradient *>(g);

  if (! lg) return;

  lg->setPoint1(lgrad1_->getValue());
  lg->setPoint2(lgrad2_->getValue());

  emit valueChanged(fill_);
}

void
CQFillOptionDialog::
updateLGradStops()
{
  const CGenGradient::StopList &stops = lgradStops_->getStops();

  CGenGradient *g = fill_.getGradient();

  CLinearGradient *lg = dynamic_cast<CLinearGradient *>(g);

  if (! lg) return;

  lg->setStops(stops);

  emit valueChanged(fill_);
}

void
CQFillOptionDialog::
addLGradStop()
{
  CGenGradient *g = fill_.getGradient();

  CLinearGradient *lg = dynamic_cast<CLinearGradient *>(g);

  if (! lg) return;

  lg->addStop(1.0, CRGBA(1,1,1));

  updateWidgets();

  emit valueChanged(fill_);
}

void
CQFillOptionDialog::
removeLGradStop()
{
}

void
CQFillOptionDialog::
updateRGrad()
{
  CGenGradient *g = fill_.getGradient();

  CRadialGradient *rg = dynamic_cast<CRadialGradient *>(g);

  if (! rg) return;

  rg->setCenter(rgradC_->getValue());
  rg->setRadius(rgradR_->getValue());
  rg->setFocus (rgradF_->getValue());

  emit valueChanged(fill_);
}

void
CQFillOptionDialog::
updateRGradStops()
{
  const CGenGradient::StopList &stops = rgradStops_->getStops();

  CGenGradient *g = fill_.getGradient();

  CRadialGradient *rg = dynamic_cast<CRadialGradient *>(g);

  if (! rg) return;

  rg->setStops(stops);

  emit valueChanged(fill_);
}

void
CQFillOptionDialog::
addRGradStop()
{
  CGenGradient *g = fill_.getGradient();

  CRadialGradient *rg = dynamic_cast<CRadialGradient *>(g);

  if (! rg) return;

  rg->addStop(1.0, CRGBA(1,1,1));

  updateWidgets();

  emit valueChanged(fill_);
}

void
CQFillOptionDialog::
removeRGradStop()
{
}

void
CQFillOptionDialog::
setImageSlot()
{
  QString title  = "Load Image";
  QString cwd    = QString(COSFile::getCurrentDir().c_str());
  QString filter = "Image Files (*)";

  QStringList filenames = QFileDialog::getOpenFileNames(this, title, cwd, filter);

  if (filenames.size() == 0)
    return;

  QStringListIterator fi(filenames);

  while (fi.hasNext()) {
    CImageFileSrc src(fi.next().toStdString());

    CImagePtr image = CImageMgrInst->lookupImage(src);

    if (image.isValid()) {
      fill_.setImage(image);

      updateWidgets();

      emit valueChanged(fill_);

      return;
    }
  }
}

void
CQFillOptionDialog::
imageScaleSlot(const QString &scale)
{
  if      (scale == "None")
    fill_.setImageScale(CQIllustratorShapeFill::IMAGE_SCALE_NONE);
  else if (scale == "Fit")
    fill_.setImageScale(CQIllustratorShapeFill::IMAGE_SCALE_FIT);
  else if (scale == "Equal")
    fill_.setImageScale(CQIllustratorShapeFill::IMAGE_SCALE_EQUAL);

  tool_->update();

  emit valueChanged(fill_);
}

void
CQFillOptionDialog::
setDefaultSlot()
{
  tool_->getIllustrator()->setDefaultFill(fill_);
}

void
CQFillOptionDialog::
setBackgroundSlot()
{
  tool_->getIllustrator()->setBackground(fill_.getColor());
}
##concat##CQFontChooser.cpp
#include <CQFontChooser.h>
#include <font_dialog.xpm>

#include <QLineEdit>
#include <QPushButton>
#include <QToolButton>
#include <QLabel>
#include <QFontComboBox>
#include <QComboBox>
#include <QHBoxLayout>
#include <QFontDialog>
#include <QFontDatabase>

CQFontChooser::
CQFontChooser(QWidget *parent) :
 QWidget(parent), style_(FontNone), fixedWidth_(false)
{
  font_     = font();
  fontName_ = font_.toString();

  //-----

  QHBoxLayout *layout = new QHBoxLayout(this);

  layout->setMargin (2);
  layout->setSpacing(2);

  cedit_   = new QLineEdit  (this);
  cbutton_ = new QToolButton(this);
  clabel_  = new QLabel     (this);
  button_  = new QToolButton(this);

  ncombo_ = new QFontComboBox(this);
  scombo_ = new QComboBox(this);
  zcombo_ = new QComboBox(this);

  button_->setIcon(QIcon(QPixmap((const char **) font_dialog_data)));

  ncombo_->setWritingSystem(QFontDatabase::Latin);

  cbutton_->setFixedSize(QSize(24,24));
  clabel_ ->setFixedSize(QSize(24,24));
  button_ ->setFixedSize(QSize(24,24));

  cbutton_->setText("Abc");
  clabel_ ->setText("Abc");

  layout->addWidget(cedit_  );
  layout->addWidget(cbutton_);
  layout->addWidget(clabel_ );
  layout->addWidget(button_ );
  layout->addWidget(ncombo_ );
  layout->addWidget(scombo_ );
  layout->addWidget(zcombo_ );
  layout->addStretch();

  cedit_  ->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Fixed);
  cbutton_->setSizePolicy(QSizePolicy::Fixed    , QSizePolicy::Fixed);
  clabel_ ->setSizePolicy(QSizePolicy::Fixed    , QSizePolicy::Fixed);
  button_ ->setSizePolicy(QSizePolicy::Fixed    , QSizePolicy::Fixed);

  connect(cedit_  , SIGNAL(editingFinished()), this, SLOT(editFont  ()));
  connect(cbutton_, SIGNAL(clicked()        ), this, SLOT(applyFont ()));
  connect(button_ , SIGNAL(clicked()        ), this, SLOT(chooseFont()));

  connect(ncombo_ , SIGNAL(activated(int)), this, SLOT(nameChanged ()));
  connect(scombo_ , SIGNAL(activated(int)), this, SLOT(styleChanged()));
  connect(zcombo_ , SIGNAL(activated(int)), this, SLOT(sizeChanged ()));

  setStyle(FontEdit);

  setFixedWidth(false);

  //-----

  updateWidgets();
}

void
CQFontChooser::
setStyle(Style style)
{
  if (style_ == style) return;

  style_ = style;

  cedit_  ->setVisible(style_ == FontEdit  );
  cbutton_->setVisible(style_ == FontButton);
  clabel_ ->setVisible(style_ == FontLabel );
  button_ ->setVisible(style_ != FontCombo );
  ncombo_ ->setVisible(style_ == FontCombo );
  scombo_ ->setVisible(style_ == FontCombo );
  zcombo_ ->setVisible(style_ == FontCombo );
}

void
CQFontChooser::
setFixedWidth(bool fixedWidth)
{
  if (fixedWidth == fixedWidth_) return;

  fixedWidth_ = fixedWidth;

  if (fixedWidth_)
    ncombo_->setFontFilters(QFontComboBox::MonospacedFonts);
  else
    ncombo_->setFontFilters(QFontComboBox::AllFonts);

  ncombo_->setCurrentIndex(1);

  nameChanged();
}

void
CQFontChooser::
setFont(const QFont &font)
{
  if (font_ == font)
    return;

  font_     = font;
  fontName_ = font_.toString();

  updateWidgets();

  emit fontChanged(font_);
  emit fontChanged(fontName_);
}

void
CQFontChooser::
updateWidgets()
{
  cedit_->setText(fontName_);

  cbutton_->setFont(font_);
  clabel_ ->setFont(font_);

  int nind = ncombo_->findText(font_.family());

  if (nind >= 0)
    ncombo_->setCurrentIndex(nind);

  updateStyles();
  updateSizes ();

  updateCombos();
}

void
CQFontChooser::
setFontName(const QString &fontName)
{
  QFont font;

  if (! font.fromString(fontName))
    return;

  fontName_ = fontName;
  font_     = font;

  cedit_->setText(fontName_);

  cbutton_->setFont(font_);
  clabel_ ->setFont(font_);

  int nind = ncombo_->findText(font_.family());

  if (nind >= 0)
    ncombo_->setCurrentIndex(nind);

  updateStyles();
  updateSizes ();

  updateCombos();

  emit fontChanged(font_);
  emit fontChanged(fontName_);
}

void
CQFontChooser::
updateCombos()
{
  QFontDatabase database;

  QString style = database.styleString(font_);

  int sind = scombo_->findText(style);

  if (sind == -1) {
    bool italic = (style == "Italic" || style == "Bold Italic");

    if (italic) {
      if (style == "Italic"     ) style = "Oblique";
      if (style == "Bold Italic") style = "Bold Oblique";

      sind = scombo_->findText(style);

      if (sind == -1) {
        if (style == "Bold Oblique") style = "Oblique";

        sind = scombo_->findText(style);
      }

      if (sind == -1) {
        if (style == "Oblique") style = "Italic";

        sind = scombo_->findText(style);
      }
    }
  }

  if (sind >= 0)
    scombo_->setCurrentIndex(sind);

  int zind = zcombo_->findText(QString("%1").arg(font_.pointSize()));

  if (zind >= 0)
    zcombo_->setCurrentIndex(zind);
}

const QFont &
CQFontChooser::
font() const
{
  return font_;
}

QString
CQFontChooser::
fontName() const
{
  return fontName_;
}

void
CQFontChooser::
editFont()
{
  setFontName(cedit_->text());
}

void
CQFontChooser::
applyFont()
{
  emit fontApplied(font_);
  emit fontApplied(fontName_);
}

void
CQFontChooser::
chooseFont()
{
  bool ok;

  QFont font = QFontDialog::getFont(&ok, font_, this);

  if (ok)
    setFont(font);
}

void
CQFontChooser::
nameChanged()
{
  styleChanged();
}

void
CQFontChooser::
updateStyles()
{
  QFontDatabase database;

  const QString &family = ncombo_->itemText(ncombo_->currentIndex());

  scombo_->clear();
  scombo_->addItems(database.styles(family));
}

void
CQFontChooser::
updateSizes()
{
  QFontDatabase database;

  const QString &family = ncombo_->itemText(ncombo_->currentIndex());

  QList<int> sizes = database.pointSizes(family);

  zcombo_->clear();

  for (int i = 0; i < sizes.size(); ++i)
    zcombo_->addItem(QString("%1").arg(sizes[i]));
}

void
CQFontChooser::
styleChanged()
{
  sizeChanged();
}

void
CQFontChooser::
sizeChanged()
{
  QString name = ncombo_->itemText(ncombo_->currentIndex());
  int     size = zcombo_->itemText(zcombo_->currentIndex()).toInt();

  QFont font(name, size);

  QString style = scombo_->itemText(scombo_->currentIndex());

  if (style == "Bold" || style == "Bold Oblique" || style == "Bold Italic")
    font.setBold(true);

  if (style == "Oblique" || style == "Italic" ||
      style == "Bold Oblique" || style == "Bold Italic")
    font.setItalic(true);

  setFont(font);
}
##concat##CQFontOption.cpp
#include <CQFontOption.h>
#include <CQFontChooser.h>
#include <CQUtil.h>

#include <QVBoxLayout>
#include <QGridLayout>
#include <QLabel>
#include <QLineEdit>
#include <QPainter>

class CQFontOptionSwab : public QWidget {
 public:
  CQFontOptionSwab(CQFontOptionDialog *dialog);

 private:
  void paintEvent(QPaintEvent *e);

 private:
  CQFontOptionDialog *dialog_;
  int                 tw_, th_, fw_;
};

CQFontOptionTool::
CQFontOptionTool(QWidget *) :
 CQOptionTool(), dialog_(0)
{
  dialog_ = new CQFontOptionDialog(this);

  QVBoxLayout *layout = new QVBoxLayout(this);
  layout->setMargin(0); layout->setSpacing(0);

  QLabel *label = new QLabel("<small><b>Font</b></small>");

  layout->addWidget(label);

  CQFontOptionSwab *swab = new CQFontOptionSwab(dialog_);

  layout->addWidget(swab);

  connect(dialog_, SIGNAL(valueChanged(const QFont &)),
          this, SIGNAL(valueChanged(const QFont &)));
}

CQOptionToolDialog *
CQFontOptionTool::
getDialog()
{
  return dialog_;
}

void
CQFontOptionTool::
setFont(QFont font)
{
  dialog_->setFont(font);
}

QFont
CQFontOptionTool::
getFont() const
{
  return dialog_->getFont();
}

//----------

CQFontOptionSwab::
CQFontOptionSwab(CQFontOptionDialog *dialog) :
 dialog_(dialog)
{
  QFontMetrics fm(font());

  tw_ = fm.width("ABCabc");
  th_ = fm.ascent() + fm.descent();
  fw_ = 32;

  setFixedSize(tw_ + fw_ + 6, th_ + 4);
}

void
CQFontOptionSwab::
paintEvent(QPaintEvent *)
{
  QPainter painter(this);

  QFont font = dialog_->getFont();

  font.setPointSizeF(12);

  painter.setFont(font);

  painter.drawText(rect(), "ABCabc");
}

//----------

CQFontOptionDialog::
CQFontOptionDialog(CQFontOptionTool *tool) :
 CQOptionToolDialog(), tool_(tool), fontChooser_(0)
{
  initWidgets();
}

void
CQFontOptionDialog::
setFont(QFont font)
{
  font_ = font;

  updateWidgets();
}

void
CQFontOptionDialog::
initWidgets()
{
  QGridLayout *gridLayout = new QGridLayout(this);

  gridLayout->addWidget(new QLabel("Font"), 0, 0);

  fontChooser_ = new CQFontChooser;

  connect(fontChooser_, SIGNAL(fontChanged(const QFont &)),
          this, SLOT(fontSlot(const QFont &)));

  gridLayout->addWidget(fontChooser_, 0, 1);
}

void
CQFontOptionDialog::
updateWidgets()
{
  fontChooser_->setFont(font_);
}

void
CQFontOptionDialog::
fontSlot(const QFont &font)
{
  font_ = font;

  tool_->update();

  emit valueChanged(font_);
}
##concat##CQGradientStopList.cpp
#include <CQGradientStopList.h>
#include <CQUtil.h>
#include <CQColorChooser.h>
#include <CQRealEdit.h>

#include <QVBoxLayout>
#include <QPainter>

CQGradientStopList::
CQGradientStopList(QWidget *parent) :
 QWidget(parent)
{
  QVBoxLayout *layout = new QVBoxLayout(this);

  table_ = new CQGradientStopTable(this);

  layout->addWidget(table_);
}

void
CQGradientStopList::
init(const CGenGradient &g)
{
  stops_ = g.getStops();

  table_->clear();

  table_->setRowCount(stops_.size());

  uint ind = 0;

  CGenGradient::StopList::iterator p1, p2;

  for (p1 = stops_.begin(), p2 = stops_.end(); p1 != p2; ++p1, ++ind) {
    const CGradientStop &stop = *p1;

    const CRGBA &rgba = stop.getColor();

    CRGBA  rgba1 = rgba.solid();
    double alpha = rgba.getAlpha();

    CQGradientStopColorItem  *item1 = new CQGradientStopColorItem (table_, ind, rgba1);
    CQGradientStopAlphaItem  *item2 = new CQGradientStopAlphaItem (table_, ind, alpha);
    CQGradientStopOffsetItem *item3 = new CQGradientStopOffsetItem(table_, ind, stop.getOffset());

    table_->setItem(ind, 0, item1);
    table_->setItem(ind, 1, item2);
    table_->setItem(ind, 2, item3);
  }
}

void
CQGradientStopList::
emitStopsChanged()
{
  emit stopsChanged();
}

//------

CQGradientStopTable::
CQGradientStopTable(CQGradientStopList *list) :
 CQTableWidget(), list_(list)
{
  clear();

  connect(this, SIGNAL(valueChanged(int, int)), this, SLOT(updateStopsSlot()));
}

void
CQGradientStopTable::
clear()
{
  CQTableWidget::clear();

  setColumnCount(3);

  setColumnLabel(0, "Color");
  setColumnLabel(1, "Alpha");
  setColumnLabel(2, "Offset");
}

void
CQGradientStopTable::
updateStopsSlot()
{
  int num_rows = rowCount();

  int ind = 0;

  CGenGradient::StopList &stops = list_->getStops();

  CGenGradient::StopList::iterator p1, p2;

  for (p1 = stops.begin(), p2 = stops.end(); p1 != p2 && ind < num_rows; ++p1, ++ind) {
    CGradientStop &stop = *p1;

    CQGradientStopColorItem  *item1 = getItem<CQGradientStopColorItem >(ind, 0);
    CQGradientStopAlphaItem  *item2 = getItem<CQGradientStopAlphaItem >(ind, 1);
    CQGradientStopOffsetItem *item3 = getItem<CQGradientStopOffsetItem>(ind, 2);

    CRGBA rgba = item1->getColor();

    rgba.setAlpha(item2->getAlpha());

    stop.setColor(rgba);

    stop.setOffset(item3->getOffset());
  }

  list_->emitStopsChanged();
}

//------

CQGradientStopColorItem::
CQGradientStopColorItem(CQGradientStopTable *t, uint ind, const CRGBA &rgba) :
 CQTableWidgetItem(t), table_(t), ind_(ind), rgba_(rgba), edit_(0)
{
}

CQGradientStopColorItem *
CQGradientStopColorItem::
clone() const
{
  return new CQGradientStopColorItem(table_, ind_, rgba_);
}

QString
CQGradientStopColorItem::
getString()
{
  return "";
}

QWidget *
CQGradientStopColorItem::
createEditor(QWidget *parent) const
{
  uint styles = CQColorChooser::Text | CQColorChooser::ColorButton;

  edit_ = new CQColorChooser(styles, parent);

  return edit_;
}

void
CQGradientStopColorItem::
setEditorData()
{
  if (edit_.isNull()) return;

  edit_->setColor(CQUtil::rgbaToColor(rgba_));
}

void
CQGradientStopColorItem::
getEditorData(QString &str)
{
  if (edit_.isNull()) return;

  const QColor &c = edit_->color();

  rgba_ = CQUtil::colorToRGBA(c);

  str = "";
}

bool
CQGradientStopColorItem::
sizeHint(const QStyleOptionViewItem &option, QSize &size) const
{
  size = QSize(128, option.rect.height());

  return true;
}

bool
CQGradientStopColorItem::
paint(QPainter *painter, const QStyleOptionViewItem &option) const
{
  if (edit_.isNull()) {
    paintBackground(painter, option);

    CRGBA rgba = rgba_.solid();

    QBrush brush;

    QRect rect = option.rect.adjusted(2, 2, -2, -2);

    painter->fillRect(rect, QBrush(CQUtil::rgbaToColor(rgba)));
  }

  return true;
}

//----------

CQGradientStopAlphaItem::
CQGradientStopAlphaItem(CQGradientStopTable *t, uint ind, double alpha) :
 CQTableWidgetItem(t), table_(t), ind_(ind), alpha_(alpha), edit_(0)
{
}

CQGradientStopAlphaItem *
CQGradientStopAlphaItem::
clone() const
{
  return new CQGradientStopAlphaItem(table_, ind_, alpha_);
}

QString
CQGradientStopAlphaItem::
getString()
{
  return toString();
}

QWidget *
CQGradientStopAlphaItem::
createEditor(QWidget *parent) const
{
  edit_ = new CQRealEdit(parent);

  return edit_;
}

void
CQGradientStopAlphaItem::
setEditorData()
{
  if (! edit_) return;

  edit_->setValue(alpha_);
}

void
CQGradientStopAlphaItem::
getEditorData(QString &str)
{
  if (! edit_) return;

  alpha_ = edit_->getValue();

  str = toString();
}

QString
CQGradientStopAlphaItem::
toString() const
{
  return QString("%1").arg(alpha_);
}

//----------

CQGradientStopOffsetItem::
CQGradientStopOffsetItem(CQGradientStopTable *t, uint ind, double offset) :
 CQTableWidgetItem(t), table_(t), ind_(ind), offset_(offset), edit_(0)
{
}

CQGradientStopOffsetItem *
CQGradientStopOffsetItem::
clone() const
{
  return new CQGradientStopOffsetItem(table_, ind_, offset_);
}

QString
CQGradientStopOffsetItem::
getString()
{
  return toString();
}

QWidget *
CQGradientStopOffsetItem::
createEditor(QWidget *parent) const
{
  edit_ = new CQRealEdit(parent);

  return edit_;
}

void
CQGradientStopOffsetItem::
setEditorData()
{
  if (! edit_) return;

  edit_->setValue(offset_);
}

void
CQGradientStopOffsetItem::
getEditorData(QString &str)
{
  if (! edit_) return;

  offset_ = edit_->getValue();

  str = toString();
}

QString
CQGradientStopOffsetItem::
toString() const
{
  return QString("%1").arg(offset_);
}
##concat##CQIllustratorAlignMode.cpp
#include <CQIllustratorAlignMode.h>
#include <CQIllustrator.h>
#include <CQIllustratorShapeDrawer.h>

#include <QGridLayout>
#include <QLabel>
#include <QTabWidget>
#include <QPushButton>
#include <QComboBox>
#include <QStackedWidget>
#include <QPainter>
#include <QMenu>
#include <QAction>
#include <QIcon>
#include <QPixmap>
#include <QEvent>

#include <CQRealEdit.h>
#include <CQPointEdit.h>
#include <CQUtil.h>
#include <CQMenu.h>
#include <CQDockWidget.h>

#include <xpm/align.xpm>

#include <align_xpm/align_to_bottom_16_xpm.xpm>
#include <align_xpm/align_to_left_16_xpm.xpm>
#include <align_xpm/align_to_right_16_xpm.xpm>
#include <align_xpm/align_to_top_16_xpm.xpm>
#include <align_xpm/align_horizontally_16_xpm.xpm>
#include <align_xpm/align_vertically_16_xpm.xpm>
#include <align_xpm/distribute_bottom_16_xpm.xpm>
#include <align_xpm/distribute_left_16_xpm.xpm>
#include <align_xpm/distribute_right_16_xpm.xpm>
#include <align_xpm/distribute_top_16_xpm.xpm>
#include <align_xpm/spread_horz_16_xpm.xpm>
#include <align_xpm/spread_vert_16_xpm.xpm>
#include <align_xpm/select.xpm>
#include <align_xpm/left_bottom.xpm>
#include <align_xpm/right_top.xpm>
#include <align_xpm/middle_middle.xpm>

CQIllustratorAlignMode::
CQIllustratorAlignMode(CQIllustrator *illustrator) :
 CQIllustratorMode(illustrator, CQIllustrator::MODE_ALIGN)
{
}

CQIllustratorAlignToolbar *
CQIllustratorAlignMode::
createToolbar()
{
  toolbar_ = new CQIllustratorAlignToolbar(this);

  connect(toolbar_, SIGNAL(alignLeft()), this, SLOT(alignLSlot()));
  connect(toolbar_, SIGNAL(alignLeftPreview()), this, SLOT(alignLPreviewSlot()));

  connect(toolbar_, SIGNAL(alignBottom()), this, SLOT(alignBSlot()));
  connect(toolbar_, SIGNAL(alignBottomPreview()), this, SLOT(alignBPreviewSlot()));

  connect(toolbar_, SIGNAL(alignRight()), this, SLOT(alignRSlot()));
  connect(toolbar_, SIGNAL(alignRightPreview()), this, SLOT(alignRPreviewSlot()));

  connect(toolbar_, SIGNAL(alignTop()), this, SLOT(alignTSlot()));
  connect(toolbar_, SIGNAL(alignTopPreview()), this, SLOT(alignTPreviewSlot()));

  connect(toolbar_, SIGNAL(alignHorizontal()), this, SLOT(alignHSlot()));
  connect(toolbar_, SIGNAL(alignHorizontalPreview()), this, SLOT(alignHPreviewSlot()));
  connect(toolbar_, SIGNAL(alignVertical()), this, SLOT(alignVSlot()));
  connect(toolbar_, SIGNAL(alignVerticalPreview()), this, SLOT(alignVPreviewSlot()));

  connect(toolbar_, SIGNAL(alignPreviewClear()), this, SLOT(alignPreviewClearSlot()));

  connect(toolbar_, SIGNAL(selectAnchorObject()), illustrator_, SLOT(anchorObjectSlot()));
  connect(toolbar_, SIGNAL(selectAnchorPosition()), illustrator_, SLOT(anchorPositionSlot()));
  connect(toolbar_, SIGNAL(cancelSelectAnchor()), illustrator_, SLOT(cancelAnchorSlot()));

  return toolbar_;
}

CQMenuItem *
CQIllustratorAlignMode::
createMenuItem(CQMenu *menu)
{
  menuItem_ = new CQMenuItem(menu, "&Align", CQMenuItem::CHECKABLE);

  menuItem_->setStatusTip("Align Objects");
  menuItem_->setXPMIcon(align_data);

  connect(menuItem_->getAction(), SIGNAL(toggled(bool)), this, SLOT(menuItemSlot()));

  return menuItem_;
}

void
CQIllustratorAlignMode::
handleMouseRelease(const MouseEvent &e)
{
  if (dragging_) {
    // not moving so select control point
    if (! moving_) {
      selectControlPoint(e);
    }
    // dragging finished so commit
    else {
    }
  }
  // not dragging so do a select
  else {
    CPoint2D p1 = CQUtil::fromQPoint(press_wpos_);
    CPoint2D p2 = CQUtil::fromQPoint(release_wpos_);

    // point click - select at point
    if (! moving_) {
      (void) illustrator_->selectAt(p2, e.event->isControlKey(), e.event->isShiftKey());
    }
    // drag then create rectangle using specified bbox
    else {
      (void) illustrator_->selectIn(CBBox2D(p1, p2), e.event->isControlKey(),
                                    e.event->isShiftKey());
    }
  }

  CQIllustratorMode::handleMouseRelease(e);
}

void
CQIllustratorAlignMode::
handleMouseDrag(const MouseEvent &)
{
  illustrator_->redrawOverlay();
}

void
CQIllustratorAlignMode::
drawOverlay(CQIllustratorShapeDrawer *drawer)
{
  QPainter *painter = drawer->getPainter();

  CQIllustratorAlignToolbar::AnchorMode anchorMode = toolbar_->getAnchorMode();

  if (anchorMode == CQIllustratorAlignToolbar::POSITION_MODE) {
    QPointF pos = toolbar_->getAnchorPosition();

    QPen pen;

    pen.setColor(QColor(255,0,0));
    pen.setStyle(Qt::DashLine);

    QPointF ps1 = illustrator_->getITransform().map(QPointF(0, 0));
    QPointF ps2 = illustrator_->getITransform().map(QPointF(8, 8));

    double px = fabs(ps1.x() - ps2.x());
    double py = fabs(ps1.y() - ps2.y());

    painter->setPen(pen);
    painter->setBrush(Qt::NoBrush);

    painter->drawLine(QPointF(pos.x() - px, pos.y()), QPointF(pos.x() + px, pos.y()));
    painter->drawLine(QPointF(pos.x(), pos.y() - py), QPointF(pos.x(), pos.y() + py));
  }
}

QCursor
CQIllustratorAlignMode::
getCursor() const
{
  return Qt::OpenHandCursor;
}

void
CQIllustratorAlignMode::
alignLSlot()
{
  align(CQIllustrator::ALIGN_LEFT, true);
}

void
CQIllustratorAlignMode::
alignLPreviewSlot()
{
  illustrator_->setDimmed(true);

  align(CQIllustrator::ALIGN_LEFT, false);
}

void
CQIllustratorAlignMode::
alignBSlot()
{
  align(CQIllustrator::ALIGN_BOTTOM, true);
}

void
CQIllustratorAlignMode::
alignBPreviewSlot()
{
  illustrator_->setDimmed(true);

  align(CQIllustrator::ALIGN_BOTTOM, false);
}

void
CQIllustratorAlignMode::
alignRSlot()
{
  align(CQIllustrator::ALIGN_RIGHT, true);
}

void
CQIllustratorAlignMode::
alignRPreviewSlot()
{
  illustrator_->setDimmed(true);

  align(CQIllustrator::ALIGN_RIGHT, false);
}

void
CQIllustratorAlignMode::
alignTSlot()
{
  align(CQIllustrator::ALIGN_TOP, true);
}

void
CQIllustratorAlignMode::
alignTPreviewSlot()
{
  illustrator_->setDimmed(true);

  align(CQIllustrator::ALIGN_TOP, false);
}

void
CQIllustratorAlignMode::
alignHSlot()
{
  align(CQIllustrator::ALIGN_HORIZONTAL, true);
}

void
CQIllustratorAlignMode::
alignHPreviewSlot()
{
  illustrator_->setDimmed(true);

  align(CQIllustrator::ALIGN_HORIZONTAL, false);
}

void
CQIllustratorAlignMode::
alignVSlot()
{
  align(CQIllustrator::ALIGN_VERTICAL, true);
}

void
CQIllustratorAlignMode::
alignVPreviewSlot()
{
  illustrator_->setDimmed(true);

  align(CQIllustrator::ALIGN_VERTICAL, false);
}

void
CQIllustratorAlignMode::
alignPreviewClearSlot()
{
  illustrator_->setDimmed(false);

  illustrator_->clearPreviewObjects();

  illustrator_->redrawOverlay();
}

void
CQIllustratorAlignMode::
align(CQIllustrator::AlignSide side, bool commit)
{
  CQIllustratorSelectedShapes *selection = illustrator_->getSelection();

  if (selection->empty()) return;

  //------

  if (illustrator_->getFlipY()) {
    if      (side == CQIllustrator::ALIGN_BOTTOM) side = CQIllustrator::ALIGN_TOP;
    else if (side == CQIllustrator::ALIGN_TOP   ) side = CQIllustrator::ALIGN_BOTTOM;
  }

  //------

  CQIllustratorShape *ashape = 0;

  CBBox2D abbox;
  CBBox2D bbbox;
  bool    afixed = false;

  CQIllustratorAlignToolbar::AnchorMode anchorMode = toolbar_->getAnchorMode();

  if      (anchorMode == CQIllustratorAlignToolbar::SELECTION_MODE) {
    // get anchor shape for side

    CQIllustratorSelectedShapes::iterator ps1, ps2;

    ps1 = selection->begin();
    ps2 = selection->end();

    for ( ; ps1 != ps2; ++ps1) {
      CQIllustratorShape *shape = (*ps1).getShape();

      bbbox += shape->getBBox();
    }

    ps1 = selection->begin();

    for ( ; ps1 != ps2; ++ps1) {
      CQIllustratorShape *shape = (*ps1).getShape();

      const CBBox2D &bbox = shape->getBBox();

      if (! abbox.isSet() || (! afixed && shape->getFixed())) {
        ashape = shape;
        abbox  = bbox;
        afixed = ashape->getFixed();

        continue;
      }

      if (afixed && ! shape->getFixed())
        continue;

      if ((side == CQIllustrator::ALIGN_LEFT       && bbox.getXMin() < abbox.getXMin()) ||
          (side == CQIllustrator::ALIGN_BOTTOM     && bbox.getYMin() < abbox.getYMin()) ||
          (side == CQIllustrator::ALIGN_RIGHT      && bbox.getXMax() > abbox.getXMax()) ||
          (side == CQIllustrator::ALIGN_TOP        && bbox.getYMax() > abbox.getYMax()) ||
          (side == CQIllustrator::ALIGN_HORIZONTAL && bbox.getYMid() < abbox.getYMid()) ||
          (side == CQIllustrator::ALIGN_VERTICAL   && bbox.getXMid() < abbox.getXMid())) {
        ashape = shape;
        abbox  = bbox;
        afixed = ashape->getFixed();
      }
    }
  }
  else if (anchorMode == CQIllustratorAlignToolbar::OBJECT_MODE) {
    CQIllustratorShape *shape = illustrator_->getShape(toolbar_->getAnchorObject().toStdString());

    if (shape == 0) return;

    CQIllustratorAlignToolbar::ObjectEdgeType edgeType =
      toolbar_->getAnchorObjectEdgeType();

    abbox = shape->getBBox();

    if      (edgeType == CQIllustratorAlignToolbar::EDGE_LEFT_BOTTOM)
      abbox = CBBox2D(abbox.getLL(), abbox.getLR());
    else if (edgeType == CQIllustratorAlignToolbar::EDGE_RIGHT_TOP)
      abbox = CBBox2D(abbox.getUR(), abbox.getUR());
    else if (edgeType == CQIllustratorAlignToolbar::EDGE_MIDDLE)
      abbox = CBBox2D(abbox.getCenter(), abbox.getCenter());

    bbbox = abbox;
  }
  else if (anchorMode == CQIllustratorAlignToolbar::POSITION_MODE) {
    QPointF pos = toolbar_->getAnchorPosition();

    abbox = CBBox2D(CQUtil::fromQPoint(pos), CQUtil::fromQPoint(pos));

    CQIllustratorSelectedShapes::iterator ps1 = selection->begin(), ps2 = selection->end();

    for ( ; ps1 != ps2; ++ps1) {
      CQIllustratorShape *shape = (*ps1).getShape();

      const CBBox2D &bbox = shape->getBBox();

      bbbox += bbox;
    }
  }
  else
    return;

  // align

  double offset = toolbar_->getOffset();

  if (commit) {
    illustrator_->startUndoGroup("Align");

    CQIllustratorSelectedShapes::iterator ps1 = selection->begin(), ps2 = selection->end();

    for ( ; ps1 != ps2; ++ps1) {
      CQIllustratorShape *shape = (*ps1).getShape();

      if (shape->getFixed()) continue;

      const CBBox2D &bbox = shape->getBBox();

      double dx = 0.0, dy = 0.0;

      if (shape != ashape) {
        if      (side == CQIllustrator::ALIGN_LEFT      ) dx = abbox.getXMin() - bbox.getXMin();
        else if (side == CQIllustrator::ALIGN_BOTTOM    ) dy = abbox.getYMin() - bbox.getYMin();
        else if (side == CQIllustrator::ALIGN_RIGHT     ) dx = abbox.getXMax() - bbox.getXMax();
        else if (side == CQIllustrator::ALIGN_TOP       ) dy = abbox.getYMax() - bbox.getYMax();
        else if (side == CQIllustrator::ALIGN_HORIZONTAL) dy = abbox.getYMid() - bbox.getYMid();
        else if (side == CQIllustrator::ALIGN_VERTICAL  ) dx = abbox.getXMid() - bbox.getXMid();
      }

      if      (side == CQIllustrator::ALIGN_LEFT      ) dx += offset;
      else if (side == CQIllustrator::ALIGN_BOTTOM    ) dy += offset;
      else if (side == CQIllustrator::ALIGN_RIGHT     ) dx -= offset;
      else if (side == CQIllustrator::ALIGN_TOP       ) dy -= offset;
      else if (side == CQIllustrator::ALIGN_HORIZONTAL) dy += offset;
      else if (side == CQIllustrator::ALIGN_VERTICAL  ) dx += offset;

      shape->moveBy(CPoint2D(dx, dy));
    }

    illustrator_->endUndoGroup();

    illustrator_->setDimmed(false);

    illustrator_->clearPreviewObjects();

    illustrator_->redraw();
  }
  else {
    illustrator_->clearPreviewObjects();

    CQIllustratorSelectedShapes::iterator ps1 = selection->begin(), ps2 = selection->end();

    for ( ; ps1 != ps2; ++ps1) {
      CQIllustratorShape *shape = (*ps1).getShape();

      if (shape->getFixed()) continue;

      const CBBox2D &bbox = shape->getBBox();

      double dx = 0.0, dy = 0.0;

      if (shape != ashape) {
        if      (side == CQIllustrator::ALIGN_LEFT      ) dx = abbox.getXMin() - bbox.getXMin();
        else if (side == CQIllustrator::ALIGN_BOTTOM    ) dy = abbox.getYMin() - bbox.getYMin();
        else if (side == CQIllustrator::ALIGN_RIGHT     ) dx = abbox.getXMax() - bbox.getXMax();
        else if (side == CQIllustrator::ALIGN_TOP       ) dy = abbox.getYMax() - bbox.getYMax();
        else if (side == CQIllustrator::ALIGN_HORIZONTAL) dy = abbox.getYMid() - bbox.getYMid();
        else if (side == CQIllustrator::ALIGN_VERTICAL  ) dx = abbox.getXMid() - bbox.getXMid();
      }

      if      (side == CQIllustrator::ALIGN_LEFT      ) dx += offset;
      else if (side == CQIllustrator::ALIGN_BOTTOM    ) dy += offset;
      else if (side == CQIllustrator::ALIGN_RIGHT     ) dx -= offset;
      else if (side == CQIllustrator::ALIGN_TOP       ) dy -= offset;
      else if (side == CQIllustrator::ALIGN_HORIZONTAL) dy += offset;
      else if (side == CQIllustrator::ALIGN_VERTICAL  ) dx += offset;

      illustrator_->addPreviewObject(new CQIllustrator::PreviewShape(shape, CPoint2D(dx, dy)));
    }

    double x1 = 0.0, y1 = 0.0, x2 = 0.0, y2 = 0.0;

    if      (side == CQIllustrator::ALIGN_LEFT || side == CQIllustrator::ALIGN_RIGHT) {
      x1 = abbox.getXMin();
      x2 = abbox.getXMax();

      y1 = bbbox.getYMin();
      y2 = bbbox.getYMax();
    }
    else if (side == CQIllustrator::ALIGN_BOTTOM || side == CQIllustrator::ALIGN_TOP) {
      y1 = abbox.getYMin();
      y2 = abbox.getYMax();

      x1 = bbbox.getXMin();
      x2 = bbbox.getXMax();
    }
    else if (side == CQIllustrator::ALIGN_HORIZONTAL) {
      x1 = bbbox.getXMin();
      x2 = bbbox.getXMax();

      y1 = abbox.getYMid();
      y2 = y2;
    }
    else if (side == CQIllustrator::ALIGN_VERTICAL) {
      y1 = bbbox.getYMin();
      y2 = bbbox.getYMax();

      x1 = abbox.getXMid();
      x2 = x1;
    }

    double dx = (x2 - x1)/8;
    double dy = (y2 - y1)/8;

    if      (side == CQIllustrator::ALIGN_LEFT      )
      illustrator_->addPreviewObject(
        new CQIllustrator::PreviewLine(CPoint2D(x1, y1 - dy), CPoint2D(x1, y2 + dy)));
    else if (side == CQIllustrator::ALIGN_BOTTOM    )
      illustrator_->addPreviewObject(
        new CQIllustrator::PreviewLine(CPoint2D(x1 - dx, y1), CPoint2D(x2 + dx, y1)));
    else if (side == CQIllustrator::ALIGN_RIGHT     )
      illustrator_->addPreviewObject(
        new CQIllustrator::PreviewLine(CPoint2D(x2, y1 - dy), CPoint2D(x2, y2 + dy)));
    else if (side == CQIllustrator::ALIGN_TOP       )
      illustrator_->addPreviewObject(
        new CQIllustrator::PreviewLine(CPoint2D(x1 - dx, y2), CPoint2D(x2 + dx, y2)));
    else if (side == CQIllustrator::ALIGN_HORIZONTAL)
      illustrator_->addPreviewObject(
        new CQIllustrator::PreviewLine(CPoint2D(x1 - dx, y1), CPoint2D(x2 + dx, y1)));
    else if (side == CQIllustrator::ALIGN_VERTICAL  )
      illustrator_->addPreviewObject(
        new CQIllustrator::PreviewLine(CPoint2D(x1, y1 - dy), CPoint2D(x1, y2 + dy)));

    illustrator_->redrawOverlay();
  }
}

//-------------------

CQIllustratorAlignToolbar::
CQIllustratorAlignToolbar(CQIllustratorAlignMode *mode) :
 CQIllustratorToolbar(mode), mode_(mode)
{
}

QIcon
CQIllustratorAlignToolbar::
getIcon()
{
  return QIcon(QPixmap(align_data));
}

void
CQIllustratorAlignToolbar::
addWidgets()
{
  QBoxLayout *layout = qobject_cast<QBoxLayout *>(CQIllustratorToolbar::layout());

  QGridLayout *grid = new QGridLayout;
  grid->setMargin(0); grid->setSpacing(2);

  layout->addLayout(grid);

  //-----

  QTabWidget *tab = new QTabWidget;

  QFont font = tab->font();

  font.setPointSizeF(font.pointSizeF()*0.7);

  tab->setFont(font);

  //------

  alignw_ = new CQAlignButtons;

  tab->addTab(alignw_, "Align");

  connect(alignw_, SIGNAL(alignLeft()), this, SIGNAL(alignLeft()));
  connect(alignw_, SIGNAL(alignBottom()), this, SIGNAL(alignBottom()));
  connect(alignw_, SIGNAL(alignRight()), this, SIGNAL(alignRight()));
  connect(alignw_, SIGNAL(alignTop()), this, SIGNAL(alignTop()));
  connect(alignw_, SIGNAL(alignHorizontal()), this, SIGNAL(alignHorizontal()));
  connect(alignw_, SIGNAL(alignVertical()), this, SIGNAL(alignVertical()));

  connect(alignw_, SIGNAL(alignLeftPreview()), this, SIGNAL(alignLeftPreview()));
  connect(alignw_, SIGNAL(alignBottomPreview()), this, SIGNAL(alignBottomPreview()));
  connect(alignw_, SIGNAL(alignRightPreview()), this, SIGNAL(alignRightPreview()));
  connect(alignw_, SIGNAL(alignTopPreview()), this, SIGNAL(alignTopPreview()));
  connect(alignw_, SIGNAL(alignHorizontalPreview()), this, SIGNAL(alignHorizontalPreview()));
  connect(alignw_, SIGNAL(alignVerticalPreview()), this, SIGNAL(alignVerticalPreview()));

  connect(alignw_, SIGNAL(alignPreviewClear()), this, SIGNAL(alignPreviewClear()));

  //------

  distw_ = new CQDistButtons;

  tab->addTab(distw_, "Distribute");

  //------

  spreadw_ = new CQSpreadButtons;

  tab->addTab(spreadw_, "Spread");

  //------

  grid->addWidget(tab, 0, 0, 2, 1);

  //------

  QLabel *olabel = new QLabel("<small><b>Offset</b></small>");

  offset_ = new CQRealEdit(0.0);

  offset_->setFocusPolicy(Qt::ClickFocus);

  grid->addWidget(olabel , 0, 1);
  grid->addWidget(offset_, 1, 1);

  //------

  anchor_ = new CQAlignAnchor;

  connect(anchor_, SIGNAL(selectObject()), this, SIGNAL(selectAnchorObject()));
  connect(anchor_, SIGNAL(selectPosition()), this, SIGNAL(selectAnchorPosition()));
  connect(anchor_, SIGNAL(cancelSelect()), this, SIGNAL(cancelSelectAnchor()));

  grid->addWidget(anchor_, 0, 2, 2, 1);

  //------

  grid->setColumnStretch(3, 1);
}

double
CQIllustratorAlignToolbar::
getOffset() const
{
  return offset_->getValue();
}

CQIllustratorAlignToolbar::AnchorMode
CQIllustratorAlignToolbar::
getAnchorMode() const
{
  return anchor_->getMode();
}

QString
CQIllustratorAlignToolbar::
getAnchorObject() const
{
  return anchor_->getObject();
}

void
CQIllustratorAlignToolbar::
setAnchorObject(const QString &name)
{
  anchor_->setObject(name);
}

CQIllustratorAlignToolbar::ObjectEdgeType
CQIllustratorAlignToolbar::
getAnchorObjectEdgeType() const
{
  return anchor_->getObjectEdgeType();
}

QPointF
CQIllustratorAlignToolbar::
getAnchorPosition() const
{
  return anchor_->getPosition();
}

void
CQIllustratorAlignToolbar::
setAnchorPosition(const QPointF &pos)
{
  anchor_->setPosition(pos);
}

void
CQIllustratorAlignToolbar::
resetSelectMode()
{
  anchor_->resetSelectMode();
}

//-------

CQAlignButtons::
CQAlignButtons() :
 QWidget(0)
{
  QGridLayout *agrid = new QGridLayout(this);
  agrid->setMargin(0); agrid->setSpacing(8);

  CQToolButton *alignl  = new CQToolButton(align_to_left_16_xpm);
  CQToolButton *alignb  = new CQToolButton(align_to_bottom_16_xpm);
  CQToolButton *alignr  = new CQToolButton(align_to_right_16_xpm);
  CQToolButton *alignt  = new CQToolButton(align_to_top_16_xpm);
  CQToolButton *alignhc = new CQToolButton(align_horizontally_16_xpm);
  CQToolButton *alignvc = new CQToolButton(align_vertically_16_xpm);

  alignl ->setToolTip("Align Left");
  alignb ->setToolTip("Align Bottom");
  alignr ->setToolTip("Align Right");
  alignt ->setToolTip("Align Top");
  alignhc->setToolTip("Align Horizontal Center");
  alignvc->setToolTip("Align Vertical Center");

  agrid->addWidget(alignl , 0, 0);
  agrid->addWidget(alignb , 0, 1);
  agrid->addWidget(alignr , 0, 2);
  agrid->addWidget(alignt , 0, 3);
  agrid->addWidget(alignhc, 0, 4);
  agrid->addWidget(alignvc, 0, 5);

  agrid->setColumnStretch(6, 1);

  connect(alignl , SIGNAL(clicked()), this, SIGNAL(alignLeft()));
  connect(alignb , SIGNAL(clicked()), this, SIGNAL(alignBottom()));
  connect(alignr , SIGNAL(clicked()), this, SIGNAL(alignRight()));
  connect(alignt , SIGNAL(clicked()), this, SIGNAL(alignTop()));
  connect(alignhc, SIGNAL(clicked()), this, SIGNAL(alignHorizontal()));
  connect(alignvc, SIGNAL(clicked()), this, SIGNAL(alignVertical()));

  connect(alignl , SIGNAL(previewStart()), this, SIGNAL(alignLeftPreview()));
  connect(alignb , SIGNAL(previewStart()), this, SIGNAL(alignBottomPreview()));
  connect(alignr , SIGNAL(previewStart()), this, SIGNAL(alignRightPreview()));
  connect(alignt , SIGNAL(previewStart()), this, SIGNAL(alignTopPreview()));
  connect(alignhc, SIGNAL(previewStart()), this, SIGNAL(alignHorizontalPreview()));
  connect(alignvc, SIGNAL(previewStart()), this, SIGNAL(alignVerticalPreview()));

  connect(alignl , SIGNAL(previewStop()), this, SIGNAL(alignPreviewClear()));
  connect(alignb , SIGNAL(previewStop()), this, SIGNAL(alignPreviewClear()));
  connect(alignr , SIGNAL(previewStop()), this, SIGNAL(alignPreviewClear()));
  connect(alignt , SIGNAL(previewStop()), this, SIGNAL(alignPreviewClear()));
  connect(alignhc, SIGNAL(previewStop()), this, SIGNAL(alignPreviewClear()));
  connect(alignvc, SIGNAL(previewStop()), this, SIGNAL(alignPreviewClear()));
}

//-------

CQDistButtons::
CQDistButtons() :
 QWidget(0)
{
  QGridLayout *dgrid = new QGridLayout(this);
  dgrid->setMargin(0); dgrid->setSpacing(8);

  CQToolButton *distl = new CQToolButton(distribute_left_16_xpm);
  CQToolButton *distb = new CQToolButton(distribute_bottom_16_xpm);
  CQToolButton *distt = new CQToolButton(distribute_right_16_xpm);
  CQToolButton *distr = new CQToolButton(distribute_top_16_xpm);

  dgrid->addWidget(distl, 0, 0);
  dgrid->addWidget(distb, 0, 1);
  dgrid->addWidget(distt, 0, 2);
  dgrid->addWidget(distr, 0, 3);

  dgrid->setColumnStretch(4, 1);
}

//-------

CQSpreadButtons::
CQSpreadButtons() :
 QWidget(0)
{
  QGridLayout *sgrid = new QGridLayout(this);
  sgrid->setMargin(0); sgrid->setSpacing(8);

  CQToolButton *spreadh = new CQToolButton(spread_horz_16_xpm);
  CQToolButton *spreadv = new CQToolButton(spread_vert_16_xpm);

  sgrid->addWidget(spreadh, 0, 0);
  sgrid->addWidget(spreadv, 0, 1);

  sgrid->setColumnStretch(2, 1);
}

//--------

CQAlignAnchor::
CQAlignAnchor(QWidget *parent) :
 QWidget(parent), mode_(CQIllustratorAlignToolbar::SELECTION_MODE)
{
  QGridLayout *layout = new QGridLayout(this);
  layout->setMargin(0); layout->setSpacing(2);

  QLabel *anchorLabel = new QLabel("<small><b>Anchor</b></small>");

  layout->addWidget(anchorLabel, 0, 0, 1, 2);

  objectCombo_ = new QComboBox;

  objectCombo_->addItem("Selection");
  objectCombo_->addItem("Object");
  objectCombo_->addItem("Position");

  connect(objectCombo_, SIGNAL(activated(const QString &)),
          this, SLOT(objectSlot(const QString &)));

  layout->addWidget(objectCombo_, 1, 0);

  anchorStack_ = new QStackedWidget;

  anchorLabel_  = new QWidget;
  anchorObject_ = new CQAlignAnchorObject;
  anchorPoint_  = new CQAlignAnchorPoint;

  anchorStack_->addWidget(anchorLabel_);
  anchorStack_->addWidget(anchorObject_);
  anchorStack_->addWidget(anchorPoint_);

  layout->addWidget(anchorStack_, 1, 1);

  connect(anchorObject_, SIGNAL(selectObject()), this, SIGNAL(selectObject()));
  connect(anchorObject_, SIGNAL(cancelSelect()), this, SIGNAL(cancelSelect()));

  connect(anchorPoint_, SIGNAL(selectPoint()), this, SIGNAL(selectPosition()));
  connect(anchorPoint_, SIGNAL(cancelSelect()), this, SIGNAL(cancelSelect()));

  //-----

  updateState();
}

void
CQAlignAnchor::
updateState()
{
  if      (mode_ == CQIllustratorAlignToolbar::SELECTION_MODE) anchorStack_->setCurrentIndex(0);
  else if (mode_ == CQIllustratorAlignToolbar::OBJECT_MODE   ) anchorStack_->setCurrentIndex(1);
  else if (mode_ == CQIllustratorAlignToolbar::POSITION_MODE ) anchorStack_->setCurrentIndex(2);
}

CQIllustratorAlignToolbar::AnchorMode
CQAlignAnchor::
getMode() const
{
  return mode_;
}

QString
CQAlignAnchor::
getObject() const
{
  return anchorObject_->getName();
}

void
CQAlignAnchor::
setObject(const QString &name)
{
  anchorObject_->setName(name);
}

CQIllustratorAlignToolbar::ObjectEdgeType
CQAlignAnchor::
getObjectEdgeType() const
{
  return anchorObject_->getEdgeType();
}

QPointF
CQAlignAnchor::
getPosition() const
{
  return anchorPoint_->getValue();
}

void
CQAlignAnchor::
setPosition(const QPointF &pos)
{
  anchorPoint_->setValue(pos);
}

void
CQAlignAnchor::
resetSelectMode()
{
  anchorObject_->resetSelectMode();
  anchorPoint_ ->resetSelectMode();
}

void
CQAlignAnchor::
objectSlot(const QString &obj)
{
  if      (obj == "Selection")
    mode_ = CQIllustratorAlignToolbar::SELECTION_MODE;
  else if (obj == "Object")
    mode_ = CQIllustratorAlignToolbar::OBJECT_MODE;
  else if (obj == "Position")
    mode_ = CQIllustratorAlignToolbar::POSITION_MODE;

  updateState();
}

//--------

CQAlignAnchorObject::
CQAlignAnchorObject(QWidget *parent) :
 QWidget(parent), edgeType_(CQIllustratorAlignToolbar::EDGE_LEFT_BOTTOM)
{
  QHBoxLayout *layout = new QHBoxLayout(this);
  layout->setMargin(0); layout->setSpacing(2);

  nameEdit_ = new QLineEdit;

  nameEdit_->setFocusPolicy(Qt::ClickFocus);

  layout->addWidget(nameEdit_);

  edgeButton_ = new QToolButton;

  edgeButton_->setPopupMode(QToolButton::MenuButtonPopup);

  edgeButton_->setIcon(QIcon(QPixmap(left_bottom_data)));

  QMenu *edgeMenu = new QMenu;

  edgeMenu->addAction(QIcon(QPixmap(left_bottom_data  )), "Left/Bottom");
  edgeMenu->addAction(QIcon(QPixmap(right_top_data    )), "Right/Top");
  edgeMenu->addAction(QIcon(QPixmap(middle_middle_data)), "Middle");

  edgeButton_->setMenu(edgeMenu);

  connect(edgeButton_, SIGNAL(triggered(QAction *)), this, SLOT(edgeSlot(QAction *)));

  layout->addWidget(edgeButton_);

  selButton_ = new QToolButton;

  selButton_->setCheckable(true);
  selButton_->setAutoRaise(true);

  selButton_->setIcon(QIcon(QPixmap(select_tool_16_xpm)));

  connect(selButton_, SIGNAL(clicked(bool)), this, SLOT(selectSlot(bool)));

  layout->addWidget(selButton_);

}

QString
CQAlignAnchorObject::
getName() const
{
  return nameEdit_->text();
}

void
CQAlignAnchorObject::
setName(const QString &name)
{
  nameEdit_->setText(name);
}

void
CQAlignAnchorObject::
resetSelectMode()
{
  selButton_->setChecked(false);
}

void
CQAlignAnchorObject::
edgeSlot(QAction *action)
{
  QString str = action->text();

  if      (str == "Left/Bottom")
    edgeType_ = CQIllustratorAlignToolbar::EDGE_LEFT_BOTTOM;
  else if (str == "Right/Top")
    edgeType_ = CQIllustratorAlignToolbar::EDGE_RIGHT_TOP;
  else if (str == "Middle")
    edgeType_ = CQIllustratorAlignToolbar::EDGE_MIDDLE;

  edgeButton_->setIcon(action->icon());
}

void
CQAlignAnchorObject::
selectSlot(bool enabled)
{
  if (enabled)
    emit selectObject();
  else
    emit cancelSelect();
}

//--------

CQAlignAnchorPoint::
CQAlignAnchorPoint(QWidget *parent) :
 QWidget(parent)
{
  QHBoxLayout *layout = new QHBoxLayout(this);
  layout->setMargin(0); layout->setSpacing(2);

  pointEdit_ = new CQPointEdit(CPoint2D(0,0));

  pointEdit_->setFocusPolicy(Qt::ClickFocus);

  layout->addWidget(pointEdit_);

  selButton_ = new QToolButton;

  selButton_->setCheckable(true);
  selButton_->setAutoRaise(true);

  selButton_->setIcon(QIcon(QPixmap(select_tool_16_xpm)));

  connect(selButton_, SIGNAL(clicked(bool)), this, SLOT(selectSlot(bool)));

  layout->addWidget(selButton_);
}

QPointF
CQAlignAnchorPoint::
getValue() const
{
  return CQUtil::toQPoint(pointEdit_->getValue());
}

void
CQAlignAnchorPoint::
setValue(const QPointF &pos)
{
  pointEdit_->setValue(CQUtil::fromQPoint(pos));
}

void
CQAlignAnchorPoint::
resetSelectMode()
{
  selButton_->setChecked(false);
}

void
CQAlignAnchorPoint::
selectSlot(bool enabled)
{
  if (enabled)
    emit selectPoint();
  else
    emit cancelSelect();
}

//--------

CQToolButton::
CQToolButton(const char **xpmData) :
 QToolButton(0), preview_(false)
{
  setAutoRaise(true);

  setIcon(QIcon(QPixmap(xpmData)));
}

bool
CQToolButton::
event(QEvent *e)
{
  QEvent::Type type = e->type();

  switch (type) {
    case QEvent::ToolTip: {
      //QHelpEvent *helpEvent = static_cast<QHelpEvent *>(event);

      preview_ = true;

      emit previewStart();

      break;
    }
    case QEvent::MouseMove:
    case QEvent::Leave: {
      if (preview_) {
        preview_ = false;

        emit previewStop();
      }

      break;
    }
    default:
      break;
  }

  return QToolButton::event(e);
}
##concat##CQIllustratorCanvas.cpp
#include <CQIllustratorCanvas.h>
#include <CQIllustratorInfo.h>
#include <CQIllustrator.h>
#include <CQUtil.h>

#include <QPainter>
#include <QResizeEvent>
#include <QTimer>
#include <QMenu>
#include <QAction>

enum { TIMEOUT = 500 };

CQIllustratorCanvas::
CQIllustratorCanvas(CQIllustrator *illustrator) :
 illustrator_(illustrator), popupMenu_(0), pressed_(false), infoShape_(0)
{
  setFocusPolicy(Qt::StrongFocus);

  setMouseTracking(true);

  infoLabel_ = new CQIllustratorInfo(this);

  painter_ = new QPainter;

  timer_ = new QTimer;

  connect(timer_, SIGNAL(timeout()), this, SLOT(timeoutSlot()));
}

void
CQIllustratorCanvas::
mousePressEvent(QMouseEvent *event)
{
  if  (event->button() == Qt::RightButton) {
    showMenu(event->pos());

    return;
  }

  pressed_ = true;

  illustrator_->mousePress(CQIllustrator::MouseEvent(event, itransform_));

  timer_->start(TIMEOUT);
}

void
CQIllustratorCanvas::
mouseMoveEvent(QMouseEvent *event)
{
  if (pressed_)
    illustrator_->mouseDrag(CQIllustrator::MouseEvent(event, itransform_));
  else
    illustrator_->mouseMove(CQIllustrator::MouseEvent(event, itransform_));

  updateStatus();

  timer_->start(TIMEOUT);
}

void
CQIllustratorCanvas::
mouseReleaseEvent(QMouseEvent *event)
{
  pressed_ = false;

  illustrator_->mouseRelease(CQIllustrator::MouseEvent(event, itransform_));

  timer_->start(TIMEOUT);
}

void
CQIllustratorCanvas::
keyPressEvent(QKeyEvent *event)
{
  QPoint pos = mapFromGlobal(QCursor::pos());

  illustrator_->keyPress(CQIllustrator::KeyEvent(event, pos, itransform_));

  timer_->start(TIMEOUT);
}

void
CQIllustratorCanvas::
wheelEvent(QWheelEvent *event)
{
  CBBox2D bbox = illustrator_->getBBox();

  int num = abs(event->delta())/15;

  double dx, dy;

  if (event->modifiers() & Qt::ControlModifier)
    dx = num*bbox.getHeight()/64;
  else
    dy = num*bbox.getHeight()/64;

  if (event->delta() > 0)
    bbox.moveBy(CVector2D( dx,  dy));
  else
    bbox.moveBy(CVector2D(-dx, -dy));

  illustrator_->setBBox(bbox);
}

void
CQIllustratorCanvas::
paintEvent(QPaintEvent *)
{
  painter_->begin(this);

  const CBBox2D &bbox = illustrator_->getBBox();

  range_.setEqualScale(true);

  if (illustrator_->getFlipY())
    range_.setPixelRange(0, height() - 1, width() - 1, 0);
  else
    range_.setPixelRange(0, 0, width() - 1, height() - 1);

  range_.setWindowRange(bbox.getXMin(), bbox.getYMin(), bbox.getXMax(), bbox.getYMax());

  transform_  = CQUtil::toQTransform(getMatrix());
  itransform_ = transform_.inverted();

  //painter_->setWorldTransform(transform_);
  painter_->setTransform(transform_);

  illustrator_->draw(painter_);

  painter_->end();
}

void
CQIllustratorCanvas::
resizeEvent(QResizeEvent *e)
{
  illustrator_->resizeCanvas(e->size().width(), e->size().height());
}

void
CQIllustratorCanvas::
showMenu(const QPoint &p)
{
  if (popupMenu_ == 0) {
    popupMenu_ = new QMenu(this);

    QAction *applyAction  = new QAction("Apply" , 0);
    QAction *cancelAction = new QAction("Cancel", 0);

    popupMenu_->addAction(applyAction);
    popupMenu_->addAction(cancelAction);
  }

  popupMenu_->popup(mapToGlobal(p));
}

void
CQIllustratorCanvas::
updateStatus()
{
  QPoint pos = mapFromGlobal(QCursor::pos());

  QPointF wpos = itransform_.map(QPointF(pos));

  CQIllustratorShape *shape = illustrator_->getObjectAt(CQUtil::fromQPoint(wpos));

  if (shape)
    illustrator_->setDeltaLabel("Shape", shape->getName().c_str());
  else
    illustrator_->setDeltaLabel("Shape", "");
}

void
CQIllustratorCanvas::
timeoutSlot()
{
  QPoint pos = mapFromGlobal(QCursor::pos());

  QPointF wpos = itransform_.map(QPointF(pos));

  CQIllustratorShape *shape = illustrator_->getObjectAt(CQUtil::fromQPoint(wpos));

  if (shape != infoShape_) {
    infoShape_ = shape;

    if (infoShape_) {
      infoLabel_->setShape(infoShape_);

      infoLabel_->show();
    }
    else
      infoLabel_->hide();
  }

  timer_->start(TIMEOUT);
}
##concat##CQIllustratorCmd.cpp
#include <CQIllustratorCmd.h>
#include <CQIllustrator.h>
#include <CStrUtil.h>

class CQIllustratorHelpCmd : public CQIllustratorCmd {
 public:
  CQIllustratorHelpCmd();

  const char *getName() const { return "help"; }

  bool exec(const std::vector<std::string> &words);
};

CQIllustratorCmdMgr::
CQIllustratorCmdMgr(CQIllustrator *illustrator) :
 illustrator_(illustrator)
{
  addCommand(new CQIllustratorHelpCmd);
}

void
CQIllustratorCmdMgr::
addCommand(CQIllustratorCmd *cmd)
{
  cmd->setIllustrator(illustrator_);

  std::string name = cmd->getName();

  cmdList_[CStrUtil::toLower(name)] = cmd;
}

bool
CQIllustratorCmdMgr::
execCmd(const std::string &text) const
{
  std::vector<std::string> words;

  CStrUtil::addWords(text, words);

  uint num_words = words.size();

  if (num_words == 0) return true;

  CmdList::const_iterator p = cmdList_.find(CStrUtil::toLower(words[0]));

  if (p == cmdList_.end())
    return false;

  return (*p).second->exec(words);
}

void
CQIllustratorCmdMgr::
displayCmds() const
{
  CmdList::const_iterator p1, p2;

  for (p1 = cmdList_.begin(), p2 = cmdList_.end(); p1 != p2; ++p1) {
    const CQIllustratorCmd *cmd = (*p1).second;

    std::cout << cmd->getName() << std::endl;
  }
}

//-------

CQIllustratorCmd::
CQIllustratorCmd(const char *args) :
 illustrator_(0), args_(args)
{
}

//-------

static const char *help_opts = "\
";

CQIllustratorHelpCmd::
CQIllustratorHelpCmd() :
 CQIllustratorCmd(help_opts)
{
}

bool
CQIllustratorHelpCmd::
exec(const std::vector<std::string> &words)
{
  args_.parse(words);

  CQIllustratorCmdMgr *cmdMgr = illustrator_->getCmdMgr();

  cmdMgr->displayCmds();

  return true;
}
##concat##CQIllustrator.cpp
//#define SVG_FLIP 1

#include <CQIllustrator.h>

#include <CQApp.h>
#include <CQMenu.h>
#include <CQImage.h>
#include <CQToolBar.h>
#include <CQDockWidget.h>
#include <CQUtil.h>
#include <CSVG.h>
#include <CGenPoly.h>
#include <CAxis2D.h>
#include <CQAccelerate.h>
#include <CTriangulate2D.h>
#include <CGiftWrap.h>
#include <CDelaunay.h>

#include <CQIllustratorCanvas.h>
#include <CQIllustratorLayer.h>
#include <CQIllustratorUndo.h>
#include <CQIllustratorShapeDrawer.h>
#include <CQIllustratorAlignMode.h>
#include <CQIllustratorTransformMode.h>
#include <CQIllustratorCreateRectMode.h>
#include <CQIllustratorCreateEllipseMode.h>
#include <CQIllustratorCreatePathMode.h>
#include <CQIllustratorCreatePolygonMode.h>
#include <CQIllustratorCreateStarMode.h>
#include <CQIllustratorCreateTextMode.h>
#include <CQIllustratorPanMode.h>
#include <CQIllustratorPointSelectMode.h>
#include <CQIllustratorSelectMode.h>
#include <CQIllustratorSetAnchorObjectMode.h>
#include <CQIllustratorSetAnchorPositionMode.h>
#include <CQIllustratorSetLGradientMode.h>
#include <CQIllustratorSetRGradientMode.h>
#include <CQIllustratorSetImageMode.h>
#include <CQIllustratorSliceMode.h>
#include <CQIllustratorZoomMode.h>
#include <CQIllustratorOffsetPathMode.h>
#include <CQIllustratorUndoDock.h>
#include <CQIllustratorPreference.h>
#include <CQIllustratorSnap.h>
#include <CQIllustratorHandle.h>
#include <CQIllustratorCmd.h>

#include <CQStrokeOption.h>
#include <CQFillOption.h>
//#include <CQFontOption.h>
#include <CQObjectOption.h>
#include <CQLayerOption.h>
#include <CQPropertiesOption.h>

#ifdef PSVIEW
#include <CPSViewShapeRenderer.h>
#endif

#include <COSFile.h>

#include <QLabel>
#include <QLineEdit>
#include <QStackedWidget>
#include <QStatusBar>
#include <QPainter>
#include <QMouseEvent>
#include <QFileDialog>

#include <xpm/select_all.xpm>
#include <xpm/select_none.xpm>

#include <xpm/group.xpm>
#include <xpm/ungroup.xpm>
#include <xpm/copy.xpm>
#include <xpm/copy_color.xpm>
#include <xpm/delete.xpm>
#include <xpm/raise.xpm>
#include <xpm/lower.xpm>
#include <xpm/flip_x.xpm>
#include <xpm/flip_y.xpm>
#include <xpm/lock.xpm>
#include <xpm/unlock.xpm>
#include <xpm/add_layer.xpm>

#include <images/undo_16_png.h>
#include <images/redo_16_png.h>

#define IMAGE_DATA(I) I, sizeof(I)/sizeof(char *)

int
main(int argc, char **argv)
{
  CQApp app(argc, argv);

  CQIllustrator *w = new CQIllustrator;

  w->init();

  w->resize(1000, 800);

  if (argc > 1)
    w->loadFile(argv[1]);

  w->show();

  return app.exec();
}

//----------------

class CQIllustratorSourceCmd : public CQIllustratorCmd {
 public:
  CQIllustratorSourceCmd();

  const char *getName() const { return "source"; }

  bool exec(const std::vector<std::string> &words);
};

class CQIllustratorSelectCmd : public CQIllustratorCmd {
 public:
  CQIllustratorSelectCmd();

  const char *getName() const { return "select"; }

  bool exec(const std::vector<std::string> &words);
};

class CQIllustratorMoveCmd : public CQIllustratorCmd {
 public:
  CQIllustratorMoveCmd();

  const char *getName() const { return "move"; }

  bool exec(const std::vector<std::string> &words);
};

class CQIllustratorMovePointCmd : public CQIllustratorCmd {
 public:
  CQIllustratorMovePointCmd();

  const char *getName() const { return "move_point"; }

  bool exec(const std::vector<std::string> &words);
};

class CQIllustratorUndoCmd : public CQIllustratorCmd {
 public:
  CQIllustratorUndoCmd();

  const char *getName() const { return "undo"; }

  bool exec(const std::vector<std::string> &words);
};

class CQIllustratorRedoCmd : public CQIllustratorCmd {
 public:
  CQIllustratorRedoCmd();

  const char *getName() const { return "redo"; }

  bool exec(const std::vector<std::string> &words);
};

class CQIllustratorOffsetPathCmd : public CQIllustratorCmd {
 public:
  CQIllustratorOffsetPathCmd();

  const char *getName() const { return "offset_path"; }

  bool exec(const std::vector<std::string> &words);
};

class CQIllustratorStrokePathCmd : public CQIllustratorCmd {
 public:
  CQIllustratorStrokePathCmd();

  const char *getName() const { return "stroke_path"; }

  bool exec(const std::vector<std::string> &words);
};

class CQIllustratorIntersectCmd : public CQIllustratorCmd {
 public:
  CQIllustratorIntersectCmd();

  const char *getName() const { return "intersect"; }

  bool exec(const std::vector<std::string> &words);
};

//----------------

CQIllustrator::
CQIllustrator() :
 CQMainWindow("Illustrator"),
 fileName_   (""),
 fileType_   (CFILE_TYPE_NONE),
 flip_y_     (false),
 changed_    (true),
 escape_     (false),
 dimmed_     (false),
 dim_valid_  (false),
 quad_tree_  (false),
 mode_       (MODE_SELECT),
 currentMode_(0),
 layerStack_ (0),
 fullBBox_   (),
 bbox_       (),
 bg_         (1,1,1),
 selection_  (0),
 cmdMgr_     (0)
{
  drawer_ = new CQIllustratorShapeDrawer(this);

  selection_ = new CQIllustratorSelectedShapes(this);

  connect(selection_, SIGNAL(selectionChanged()), this, SLOT(selectionChangedSlot()));

  layerStack_ = new CQIllustratorLayerStack(this);

  connect(layerStack_, SIGNAL(objectPostModify(CQIllustratorShape *, ChangeType)),
          this, SLOT(selectionChangedSlot()));

  connect(layerStack_, SIGNAL(layerChanged()), this, SLOT(layerChangedSlot()));

  connect(layerStack_, SIGNAL(layersModified()), this, SLOT(layersModifiedSlot()));

  undo_ = new CQIllustratorUndo(this);

  connect(undo_, SIGNAL(undoChanged()), this, SLOT(undoChangedSlot()));

  sandbox_ = new CQIllustratorSandbox(this);

  cmdMgr_ = new CQIllustratorCmdMgr(this);

  double size = 1000.0;

  setFullBBox(CBBox2D(CPoint2D(0.0, 0.0), CPoint2D(size, size)));

  setBBox(getFullBBox());

  //------

  addCommand(new CQIllustratorSourceCmd);
  addCommand(new CQIllustratorSelectCmd);
  addCommand(new CQIllustratorMoveCmd);
  addCommand(new CQIllustratorMovePointCmd);
  addCommand(new CQIllustratorUndoCmd);
  addCommand(new CQIllustratorRedoCmd);
  addCommand(new CQIllustratorOffsetPathCmd);
  addCommand(new CQIllustratorStrokePathCmd);
  addCommand(new CQIllustratorIntersectCmd);

  //------

  updateTitle();
}

CQIllustrator::
~CQIllustrator()
{
}

void
CQIllustrator::
initTerm()
{
  addMode(new CQIllustratorSelectMode       (this));
  addMode(new CQIllustratorPointSelectMode  (this));
  addMode(new CQIllustratorCreateRectMode   (this));
  addMode(new CQIllustratorCreateEllipseMode(this));
  addMode(new CQIllustratorCreatePolygonMode(this));
  addMode(new CQIllustratorCreatePathMode   (this));
  addMode(new CQIllustratorCreateStarMode   (this));
  addMode(new CQIllustratorCreateTextMode   (this));
  addMode(new CQIllustratorSetLGradientMode (this));
  addMode(new CQIllustratorSetRGradientMode (this));
  addMode(new CQIllustratorSetImageMode     (this));
  addMode(new CQIllustratorSliceMode        (this));
  addMode(new CQIllustratorZoomMode         (this));
  addMode(new CQIllustratorPanMode          (this));
  addMode(new CQIllustratorAlignMode        (this));
  addMode(new CQIllustratorTransformMode    (this));
  addMode(new CQIllustratorOffsetPathMode   (this));

  addMode(new CQIllustratorSetAnchorObjectMode  (this));
  addMode(new CQIllustratorSetAnchorPositionMode(this));

  ModeMap::const_iterator p1, p2;

  for (p1 = modeMap_.begin(), p2 = modeMap_.end(); p1 != p2; ++p1) {
    CQIllustratorMode *mode = (*p1).second;

    if (mode->getParentMode() == 0) {
      if      (mode->isCreateMode())
        mode->createMenuItem(createMenu_);
      else if (mode->isSelectMode())
        mode->createMenuItem(selectMenu_);
      else
        mode->createMenuItem(modeMenu_);

      modeToolBar_->addItem(mode->getMenuItem());
    }
  }

  setMode(MODE_SELECT);
}

void
CQIllustrator::
selectionChangedSlot()
{
  emit selectionChanged();

  redraw();
}

void
CQIllustrator::
layerChangedSlot()
{
  layerTool_->updateLayer();

  redraw();
}

void
CQIllustrator::
layersModifiedSlot()
{
  layerTool_->reloadLayers();

  redraw();
}

void
CQIllustrator::
emitFillChanged()
{
  emit fillChanged();
}

void
CQIllustrator::
addMode(CQIllustratorMode *mode)
{
  mode->init();

  modeMap_[(Mode) mode->getId()] = mode;
}

CQIllustratorMode *
CQIllustrator::
getMode(Mode id) const
{
  ModeMap::const_iterator p = modeMap_.find(id);

  if (p == modeMap_.end())
    return 0;

  return (*p).second;
}

QWidget *
CQIllustrator::
createCentralWidget()
{
  canvas_ = new CQIllustratorCanvas(this);

  return canvas_;
}

void
CQIllustrator::
createWorkspace()
{
}

void
CQIllustrator::
createMenus()
{
  fileMenu_ = new CQMenu(this, "File");

  CQMenuItem *loadFileItem = new CQMenuItem(fileMenu_, "Load File");

  connect(loadFileItem->getAction(), SIGNAL(triggered()), this, SLOT(loadFileSlot()));

  CQMenuItem *saveSvgItem = new CQMenuItem(fileMenu_, "Save SVG");

  connect(saveSvgItem->getAction(), SIGNAL(triggered()), this, SLOT(saveSVGSlot()));

  CQMenuItem *saveCmdItem = new CQMenuItem(fileMenu_, "Save Cmd");

  connect(saveCmdItem->getAction(), SIGNAL(triggered()), this, SLOT(saveCmdSlot()));

  CQMenuItem *snapshotItem = new CQMenuItem(fileMenu_, "Snapshot");

  snapshotItem->setStatusTip("Screen dump");

  connect(snapshotItem->getAction(), SIGNAL(triggered()), this, SLOT(snapShotSlot()));

  CQMenuItem *quitItem = new CQMenuItem(fileMenu_, "Quit");

  quitItem->setShortcut("Ctrl+Q");
  quitItem->setStatusTip("Quit the application");

  connect(quitItem->getAction(), SIGNAL(triggered()), this, SLOT(close()));

  //--------

  createMenu_ = new CQMenu(this, "Create");
  selectMenu_ = new CQMenu(this, "Select");
  modeMenu_   = new CQMenu(this, "Mode");

  //--------

  selectAllItem_ = new CQMenuItem(selectMenu_, "Select All");

  selectAllItem_->setStatusTip("Select All");
  selectAllItem_->setXPMIcon(select_all_data);

  connect(selectAllItem_->getAction(), SIGNAL(triggered()), this, SLOT(selectAllSlot()));

  selectNoneItem_ = new CQMenuItem(selectMenu_, "Select None");

  selectNoneItem_->setStatusTip("Select None");
  selectNoneItem_->setXPMIcon(select_none_data);

  connect(selectNoneItem_->getAction(), SIGNAL(triggered()), this, SLOT(selectNoneSlot()));

  //--------

  editMenu_ = new CQMenu(this, "Edit");

  groupItem_ = new CQMenuItem(editMenu_, "Group Objects");

  groupItem_->setStatusTip("Create Group From Selected Objects");
  groupItem_->setXPMIcon(group_data);

  connect(groupItem_->getAction(), SIGNAL(triggered()), this, SLOT(groupSlot()));

  ungroupItem_ = new CQMenuItem(editMenu_, "Ungroup Objects");

  ungroupItem_->setStatusTip("Ungroup Selected Groups");
  ungroupItem_->setXPMIcon(ungroup_data);

  connect(ungroupItem_->getAction(), SIGNAL(triggered()), this, SLOT(ungroupSlot()));

  copyItem_ = new CQMenuItem(editMenu_, "Copy Objects");

  copyItem_->setStatusTip("Copy Selected Objects");
  copyItem_->setXPMIcon(copy_data);

  connect(copyItem_->getAction(), SIGNAL(triggered()), this, SLOT(copySlot()));

  deleteItem_ = new CQMenuItem(editMenu_, "Delete Objects");

  deleteItem_->setStatusTip("Delete Selected Objects");
  deleteItem_->setXPMIcon(delete_data);

  connect(deleteItem_->getAction(), SIGNAL(triggered()), this, SLOT(deleteSlot()));

  raiseItem_ = new CQMenuItem(editMenu_, "Raise Objects");

  raiseItem_->setStatusTip("Lower Selected Objects");
  raiseItem_->setXPMIcon(raise_data);

  connect(raiseItem_->getAction(), SIGNAL(triggered()), this, SLOT(raiseSlot()));

  lowerItem_ = new CQMenuItem(editMenu_, "Lower Objects");

  lowerItem_->setStatusTip("Raise Selected Objects");
  lowerItem_->setXPMIcon(lower_data);

  connect(lowerItem_->getAction(), SIGNAL(triggered()), this, SLOT(lowerSlot()));

  flipXItem_ = new CQMenuItem(editMenu_, "Flip X");

  flipXItem_->setStatusTip("Flip Objects in X Axis");
  flipXItem_->setXPMIcon(flip_x_data);

  connect(flipXItem_->getAction(), SIGNAL(triggered()), this, SLOT(flipXSlot()));

  flipYItem_ = new CQMenuItem(editMenu_, "Flip Y");

  flipYItem_->setStatusTip("Flip Objects in Y Axis");
  flipYItem_->setXPMIcon(flip_y_data);

  connect(flipYItem_->getAction(), SIGNAL(triggered()), this, SLOT(flipYSlot()));

  lockItem_ = new CQMenuItem(editMenu_, "Lock");

  lockItem_->setStatusTip("Lock Selected Objects");
  lockItem_->setXPMIcon(lock_data);

  connect(lockItem_->getAction(), SIGNAL(triggered()), this, SLOT(lockSlot()));

  unlockItem_ = new CQMenuItem(editMenu_, "Unlock");

  unlockItem_->setStatusTip("Unlock Selected Objects");
  unlockItem_->setXPMIcon(unlock_data);

  connect(unlockItem_->getAction(), SIGNAL(triggered()), this, SLOT(unlockSlot()));

  copyStroke_ = new CQMenuItem(editMenu_, "Copy Stroke and Fill");

  copyStroke_->setStatusTip("Copy Stroke and Fill");
  copyStroke_->setXPMIcon(copy_color_data);

  connect(copyStroke_->getAction(), SIGNAL(triggered()), this, SLOT(copyStrokeSlot()));

  pasteStroke_ = new CQMenuItem(editMenu_, "Paste Stroke and Fill");

  pasteStroke_->setStatusTip("Paste Stroke and Fill");

  connect(pasteStroke_->getAction(), SIGNAL(triggered()), this, SLOT(pasteStrokeSlot()));

  undoItem_ = new CQMenuItem(editMenu_, "Undo");

  undoItem_->setEnabled(false);

  undoItem_->setShortcut("Ctrl+Z");
  undoItem_->setStatusTip("Undo last change");
  undoItem_->setIcon(undo_16_data, UNDO_16_DATA_LEN);

  connect(undoItem_->getAction(), SIGNAL(triggered()), this, SLOT(undoSlot()));

  redoItem_ = new CQMenuItem(editMenu_, "Redo");

  redoItem_->setEnabled(false);

  redoItem_->setShortcut("Ctrl+Y");
  redoItem_->setStatusTip("Redo last undo");
  redoItem_->setIcon(redo_16_data, REDO_16_DATA_LEN);

  connect(redoItem_->getAction(), SIGNAL(triggered()), this, SLOT(redoSlot()));

  //----

  layerMenu_ = new CQMenu(this, "Layer");

  addLayerItem_ = new CQMenuItem(layerMenu_, "Add Layer");

  addLayerItem_->setStatusTip("Add New Layer");
  addLayerItem_->setXPMIcon(add_layer_data);

  connect(addLayerItem_->getAction(), SIGNAL(triggered()), this, SLOT(addLayerSlot()));

  //----

  viewMenu_ = new CQMenu(this, "View");

  CQMenuItem *zoomFullItem = new CQMenuItem(viewMenu_, "Zoom Full");
  CQMenuItem *zoomFitItem  = new CQMenuItem(viewMenu_, "Zoom Fit");
  CQMenuItem *zoomSelItem  = new CQMenuItem(viewMenu_, "Zoom Selected");
  CQMenuItem *gridItem     = new CQMenuItem(viewMenu_, "Grid");

  connect(zoomFullItem->getAction(), SIGNAL(triggered()), this, SLOT(zoomFullSlot()));
  connect(zoomFitItem ->getAction(), SIGNAL(triggered()), this, SLOT(zoomFitSlot()));
  connect(zoomSelItem ->getAction(), SIGNAL(triggered()), this, SLOT(zoomSelSlot()));
  connect(gridItem    ->getAction(), SIGNAL(triggered()), this, SLOT(gridSlot()));

  flipViewItem_ = new CQMenuItem(viewMenu_, "Flip Y", CQMenuItem::CHECKABLE);

  connect(flipViewItem_->getAction(), SIGNAL(toggled(bool)), this, SLOT(flipViewSlot(bool)));

  //----

  viewMenu_ = new CQMenu(this, "Geometry");

  CQMenuItem *toPolygonItem = new CQMenuItem(viewMenu_, "To Polygon");
  CQMenuItem *toPathItem    = new CQMenuItem(viewMenu_, "To Path"   );

  connect(toPolygonItem ->getAction(), SIGNAL(triggered()), this, SLOT(toPolygonSlot()));
  connect(toPathItem    ->getAction(), SIGNAL(triggered()), this, SLOT(toPathSlot   ()));

  CQMenuItem *offsetPathItem = new CQMenuItem(viewMenu_, "Offset Path");
  CQMenuItem *strokePathItem = new CQMenuItem(viewMenu_, "Stroke Path");

  connect(offsetPathItem->getAction(), SIGNAL(triggered()), this, SLOT(offsetPathSlot()));
  connect(strokePathItem->getAction(), SIGNAL(triggered()), this, SLOT(strokePathSlot()));

  CQMenuItem *geomAndItem = new CQMenuItem(viewMenu_, "And");
  CQMenuItem *geomOrItem  = new CQMenuItem(viewMenu_, "Or" );
  CQMenuItem *geomXorItem = new CQMenuItem(viewMenu_, "Xor");
  CQMenuItem *geomNotItem = new CQMenuItem(viewMenu_, "Not");

  connect(geomAndItem->getAction(), SIGNAL(triggered()), this, SLOT(geomAndSlot()));
  connect(geomOrItem ->getAction(), SIGNAL(triggered()), this, SLOT(geomOrSlot ()));
  connect(geomXorItem->getAction(), SIGNAL(triggered()), this, SLOT(geomXorSlot()));
  connect(geomNotItem->getAction(), SIGNAL(triggered()), this, SLOT(geomNotSlot()));

  CQMenuItem *toCurveItem = new CQMenuItem(viewMenu_, "To Curve");
  CQMenuItem *flattenItem = new CQMenuItem(viewMenu_, "Flatten" );

  connect(toCurveItem->getAction(), SIGNAL(triggered()), this, SLOT(toCurveSlot()));
  connect(flattenItem->getAction(), SIGNAL(triggered()), this, SLOT(flattenSlot()));

  CQMenuItem *intersectOrItem   = new CQMenuItem(viewMenu_, "Intersect (OR)");
  CQMenuItem *intersectAndItem  = new CQMenuItem(viewMenu_, "Intersect (AND)");
  CQMenuItem *intersectXor1Item = new CQMenuItem(viewMenu_, "Intersect (XOR Single)");
  CQMenuItem *intersectXor2Item = new CQMenuItem(viewMenu_, "Intersect (XOR Split)");
  CQMenuItem *combineItem       = new CQMenuItem(viewMenu_, "Combine");

  connect(intersectOrItem  ->getAction(), SIGNAL(triggered()), this, SLOT(intersectOrSlot()));
  connect(intersectAndItem ->getAction(), SIGNAL(triggered()), this, SLOT(intersectAndSlot()));
  connect(intersectXor1Item->getAction(), SIGNAL(triggered()), this, SLOT(intersectXor1Slot()));
  connect(intersectXor2Item->getAction(), SIGNAL(triggered()), this, SLOT(intersectXor2Slot()));
  connect(combineItem      ->getAction(), SIGNAL(triggered()), this, SLOT(combineSlot()));

  CQMenuItem *triangulateItem = new CQMenuItem(viewMenu_, "Triangulate");

  connect(triangulateItem->getAction(), SIGNAL(triggered()), this, SLOT(triangulateSlot()));

  CQMenuItem *giftWrapItem = new CQMenuItem(viewMenu_, "Gift Wrap");

  connect(giftWrapItem->getAction(), SIGNAL(triggered()), this, SLOT(giftWrapSlot()));

  CQMenuItem *delaunayItem = new CQMenuItem(viewMenu_, "Delaunay");

  connect(delaunayItem->getAction(), SIGNAL(triggered()), this, SLOT(delaunaySlot()));

  //----

  CQDockMgrInst->addToolsMenu(this);

  //----

  helpMenu_ = new CQMenu(this, "Help");

  //----

  CQMenuItem *aboutItem = new CQMenuItem(helpMenu_, "About");

  aboutItem->setStatusTip("Show the application's About box");

  connect(aboutItem->getAction(), SIGNAL(triggered()), this, SLOT(aboutSlot()));

  //----

  CQAccelerate::accelerateMenu(editMenu_->getMenu());
}

void
CQIllustrator::
createToolBars()
{
  modeToolBar_ = new CQToolBar(this, "Mode");

  //-------

  selectToolBar_ = new CQToolBar(this, "Select");

  selectToolBar_->addItem(selectAllItem_);
  selectToolBar_->addItem(selectNoneItem_);

  //-------

  editToolBar_ = new CQToolBar(this, "Edit");

  editToolBar_->addItem(groupItem_);
  editToolBar_->addItem(ungroupItem_);

  editToolBar_->addItem(copyItem_);
  editToolBar_->addItem(deleteItem_);
  editToolBar_->addItem(raiseItem_);
  editToolBar_->addItem(lowerItem_);

  editToolBar_->addItem(lockItem_);
  editToolBar_->addItem(unlockItem_);

  editToolBar_->addItem(undoItem_);
  editToolBar_->addItem(redoItem_);

  //-------

  layerToolBar_ = new CQToolBar(this, "Layer");

  layerToolBar_->addItem(addLayerItem_);

  //-------

  addToolBarBreak();

  //-------

  mouseToolToolBar_ = new CQToolBar(this, "Mode");

  mouseToolStack_ = new QStackedWidget;

  mouseToolToolBar_->addWidget(mouseToolStack_);

  mouseToolToolBar_->getToolBar()->setFixedHeight(48);
  mouseToolToolBar_->getToolBar()->setMovable(false);
  mouseToolToolBar_->getToolBar()->setFloatable(false);

  mouseToolToolBar_->setAllowedAreas(Qt::TopToolBarArea | Qt::BottomToolBarArea);

  //-------

  consoleToolBar_ = new CQToolBar(this, "Console", Qt::BottomToolBarArea);

  //consoleToolBar_->getToolBar()->setFixedHeight(40);
  consoleToolBar_->getToolBar()->setMovable(false);
  consoleToolBar_->getToolBar()->setFloatable(false);

  consoleToolBar_->setAllowedAreas(Qt::TopToolBarArea | Qt::BottomToolBarArea);

  consoleEdit_ = new QLineEdit;

  connect(consoleEdit_, SIGNAL(returnPressed()), this, SLOT(consoleExecSlot()));

  consoleAction_ = consoleToolBar_->addWidget(consoleEdit_);

  consoleAction_->setVisible(false);

  //-------

  toolsToolBar_ = new CQToolBar(this, "Tools", Qt::BottomToolBarArea);

  toolsToolBar_->getToolBar()->setFixedHeight(40);
  toolsToolBar_->getToolBar()->setMovable(false);
  toolsToolBar_->getToolBar()->setFloatable(false);

  toolsToolBar_->setAllowedAreas(Qt::TopToolBarArea | Qt::BottomToolBarArea);

  //-------

  CQOptionToolSet *styleSet = new CQOptionToolSet;

  styleSet->setPopupArea(canvas_);

  strokeTool_ = new CQStrokeOptionTool(this);
  fillTool_   = new CQFillOptionTool(this);
//fontTool_   = new CQFontOptionTool;

  connect(strokeTool_, SIGNAL(valueChanged(const CQIllustratorShapeStroke &)),
          this, SLOT(strokeSlot(const CQIllustratorShapeStroke &)));
  connect(fillTool_  , SIGNAL(valueChanged(const CQIllustratorShapeFill &)),
          this, SLOT(fillSlot(const CQIllustratorShapeFill &)));
  connect(fillTool_  , SIGNAL(clipChanged(bool)),
          this, SLOT(clipSlot(bool)));
//connect(fontTool_  , SIGNAL(valueChanged(const QFont &)),
//        this, SLOT(fontSlot(const QFont &)));

  styleSet->addOption(strokeTool_);
  styleSet->addOption(fillTool_  );
//styleSet->addOption(fontTool_  );

  //------

  CQOptionToolSet *objectSet = new CQOptionToolSet;

  objectSet->setPopupArea(canvas_);

  propTool_   = new CQPropertiesOptionTool(this);
  objectTool_ = new CQObjectOptionTool(this);
  layerTool_  = new CQLayerOptionTool(this);

  connect(propTool_  , SIGNAL(valueChanged()),
          this, SLOT(propSlot()));
  connect(objectTool_, SIGNAL(valueChanged(const QString &)),
          this, SLOT(objectSlot(const QString &)));

  objectSet->addOption(propTool_  );
  objectSet->addOption(objectTool_);
  objectSet->addOption(layerTool_ );

  //------

  modeLabel_ = new QLabel("<small><b>Mode</b></small><br>");

  modeLabel_->setAlignment(Qt::AlignLeft);
  modeLabel_->setFixedWidth(128);

  posLabel_ = new QLabel("<small><b>Position</b></small><br>");

  posLabel_->setAlignment(Qt::AlignLeft);
  posLabel_->setFixedWidth(128);

  deltaLabel_ = new QLabel("<small><b>Delta</b></small><br>");

  deltaLabel_->setAlignment(Qt::AlignLeft);
  deltaLabel_->setFixedWidth(128);

  //------

  toolsToolBar_->addWidget(styleSet);
  toolsToolBar_->addWidget(objectSet);
  toolsToolBar_->addWidget(modeLabel_);
  toolsToolBar_->addWidget(posLabel_);
  toolsToolBar_->addWidget(deltaLabel_);

  insertToolBarBreak(toolsToolBar_->getToolBar());
}

void
CQIllustrator::
createStatusBar()
{
}

void
CQIllustrator::
createDockWindows()
{
  undoDock_ = new CQIllustratorUndoDock(this);

  CQDockWidget *undoDock = new CQDockWidget(this, "Undo", undoDock_);

  undoDock->setAllowedAreas(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);

  undoDock->getDockWidget()->setVisible(false);

  //------

  preferenceDock_ = new CQIllustratorPreferenceDock(this);

  CQDockWidget *preferenceDock = new CQDockWidget(this, "Preference", preferenceDock_);

  preferenceDock->setAllowedAreas(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);

  preferenceDock->getDockWidget()->setVisible(false);

  //------

  snapDock_ = new CQIllustratorSnapDock(this);

  CQDockWidget *snapDock = new CQDockWidget(this, "Snap", snapDock_);

  snapDock->setAllowedAreas(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);

  snapDock->getDockWidget()->setVisible(false);
}

void
CQIllustrator::
addModeToolbar(CQIllustratorMode *mode, CQIllustratorToolbar *toolbar)
{
  mouseToolStack_->addWidget(toolbar);

  mode->setStack(mouseToolStack_);

  toolbar->init();
}

void
CQIllustrator::
updateTitle()
{
  if (fileName_ != "") {
    QString fileType;

    if      (fileType_ == CFILE_TYPE_IMAGE_SVG)
      fileType = "SVG";
    else if (fileType_ == CFILE_TYPE_IMAGE_PS)
      fileType = "PS";
    else
      fileType = "None";

    setWindowTitle(QString("CQIllustrator - %1 (%2)").arg(fileName_).arg(fileType));
  }
  else
    setWindowTitle("CQIllustrator");
}

void
CQIllustrator::
resizeCanvas(int w, int h)
{
  qimage_ = QImage(w, h, QImage::Format_ARGB32);

  dim_valid_ = false;

  changed_ = true;
}

void
CQIllustrator::
mousePress(const MouseEvent &e)
{
  escape_ = false;

  press_wpos_   = e.window;
  current_ppos_ = e.pixel;

  currentMode_->mousePress(e);

  redrawOverlay();
}

void
CQIllustrator::
mouseRelease(const MouseEvent &e)
{
  if (escape_) {
    escape_ = false;

    if (isInUndoGroup()) {
      endUndoGroup();

      undoSlot();
    }

    canvas_->updateStatus();

    return;
  }

  //------

  if (isInUndoGroup())
    endUndoGroup();

  //------

  currentMode_->mouseRelease(e);

  canvas_->updateStatus();
}

void
CQIllustrator::
mouseDrag(const MouseEvent &e)
{
  //QPointF prev_wpos = getITransform().map(QPointF(current_ppos_));

  current_ppos_ = e.pixel;

  posLabel_->setText(QString("<small><b>Position</b></small><br>"
                             "(%1,%2)").arg(e.window.x()).arg(e.window.y()));

  double pdx = e.window.x() - press_wpos_.x();
  double pdy = e.window.y() - press_wpos_.y();

  QString msg = QString("(%1,%2)").arg(pdx).arg(pdy);

  setDeltaLabel("Delta", msg);

  currentMode_->mouseDrag(e);
}

void
CQIllustrator::
mouseMove(const MouseEvent &e)
{
  current_ppos_ = e.pixel;

  CPoint2D p = CQUtil::fromQPoint(e.window);

  posLabel_->setText(QString("<small><b>Position</b></small><br>"
                             "(%1,%2)").arg(p.x).arg(p.y));

  currentMode_->mouseMove(e);
}

void
CQIllustrator::
keyPress(const KeyEvent &e)
{
  if (currentMode_->keyPress(e))
    return;

  CKeyType key = e.event->getType();

  switch (key) {
    case CKEY_TYPE_BracketLeft:
      cyclePrev();
      break;
    case CKEY_TYPE_Tab:
    case CKEY_TYPE_BracketRight:
      cycleNext();
      break;
    case CKEY_TYPE_Plus:
    case CKEY_TYPE_Equal:
      zoomIn();
      break;
    case CKEY_TYPE_Minus:
    case CKEY_TYPE_Underscore:
      zoomOut();
      break;
    case CKEY_TYPE_DEL:
      deleteSlot();
      break;
    case CKEY_TYPE_Up:
      if (e.event->isShiftKey())
        resizeSelectedShapes(CBBox2D(0,0,0,1));
      else
        moveSelectedShapes(CPoint2D(0,1));

      break;
    case CKEY_TYPE_Down:
      if (e.event->isShiftKey())
        resizeSelectedShapes(CBBox2D(0,-1,0,0));
      else
        moveSelectedShapes(CPoint2D(0,-1));

      break;
    case CKEY_TYPE_Left:
      if (e.event->isShiftKey())
        resizeSelectedShapes(CBBox2D(-1,0,0,0));
      else
        moveSelectedShapes(CPoint2D(-1,0));

      break;
    case CKEY_TYPE_Right:
      if (e.event->isShiftKey())
        resizeSelectedShapes(CBBox2D(0,0,1,0));
      else
        moveSelectedShapes(CPoint2D(1,0));

      break;
    case CKEY_TYPE_Return:
    case CKEY_TYPE_KP_Enter:
      acceptMode();
      break;
    case CKEY_TYPE_Escape:
      cancelMode();
      break;
    case CKEY_TYPE_a:
    case CKEY_TYPE_A:
      if (e.event->isControlKey())
        selectAll();
      break;
    case CKEY_TYPE_d:
    case CKEY_TYPE_D:
      if (e.event->isControlKey())
        selectNone();
      break;
    case CKEY_TYPE_e:
    case CKEY_TYPE_E:
      setMode(MODE_ELLIPSE);
      break;
    case CKEY_TYPE_p:
    case CKEY_TYPE_P:
      if (e.event->isControlKey())
        setMode(MODE_PAN);
      else
        setMode(MODE_PATH);
      break;
    case CKEY_TYPE_q:
    case CKEY_TYPE_Q:
      quad_tree_ = ! quad_tree_;
      redraw();
      break;
    case CKEY_TYPE_r:
    case CKEY_TYPE_R:
      if (e.event->isControlKey())
        redraw();
      else
        setMode(MODE_RECT);
      break;
    case CKEY_TYPE_s:
    case CKEY_TYPE_S:
      setMode(MODE_SELECT);
      break;
    case CKEY_TYPE_t:
    case CKEY_TYPE_T:
      setMode(MODE_TEXT);
      break;
    case CKEY_TYPE_v:
    case CKEY_TYPE_V:
      if (e.event->isControlKey())
        copySlot();
      break;
    case CKEY_TYPE_z:
    case CKEY_TYPE_Z:
      setMode(MODE_ZOOM);
      break;
    default:
      break;
  }
}

void
CQIllustrator::
setDeltaLabel(const QString &title, const QString &str)
{
  QString label = QString("<small><b>%1</b></small><br>%2").arg(title).arg(str);

  deltaLabel_->setText(label);

  redraw();
}

void
CQIllustrator::
setFlipY(bool flip)
{
  flip_y_ = flip;

  flipViewItem_->setChecked(flip);
}

const CQIllustratorData::ShapeStack &
CQIllustrator::
getShapes() const
{
  return getData()->getShapes();
}

CQIllustratorShape *
CQIllustrator::
selectAt(const CPoint2D &p, bool add, bool remove)
{
  CQIllustratorShape *select_shape = getObjectAt(p);

  if      (add)
    addSelectShape(select_shape);
  else if (remove)
    removeSelectShape(select_shape);
  else
    setSelectShape(select_shape);

  return select_shape;
}

CQIllustratorShape *
CQIllustrator::
getObjectAt(const CPoint2D &p) const
{
  return getData()->getObjectAt(p);
}

void
CQIllustrator::
selectIn(const CBBox2D &bbox, bool add, bool remove)
{
  if (! add && ! remove)
    clearSelection();

  CQIllustratorData::ShapeList shapes;

  getData()->getObjectsInside(bbox, shapes);

  selection_->startSelect();

  CQIllustratorData::ShapeList::const_iterator ps1, ps2;

  for (ps1 = shapes.begin(), ps2 = shapes.end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = *ps1;

    if (! remove)
      selection_->add(shape);
    else
      removeSelectShape(shape);
  }

  selection_->endSelect();
}

void
CQIllustrator::
selectOverlap(const CBBox2D &bbox, bool add, bool remove)
{
  if (! add && ! remove)
    clearSelection();

  CQIllustratorData::ShapeList shapes;

  getData()->getObjectsTouching(bbox, shapes);

  selection_->startSelect();

  CQIllustratorData::ShapeList::const_iterator ps1, ps2;

  for (ps1 = shapes.begin(), ps2 = shapes.end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = *ps1;

    if (! remove)
      selection_->add(shape);
    else
      removeSelectShape(shape);
  }

  selection_->endSelect();
}

void
CQIllustrator::
selectPointAt(const CPoint2D &p, CQIllustratorShape::ControlType type, bool add, bool remove)
{
  clearSelection();

  double                            dist  = 0.0;
  CQIllustratorShape               *shape = 0;
  CQIllustratorShapeNearestPoint2D  npoint;

  const CQIllustratorData::ShapeStack &shapes = getShapes();

  CQIllustratorData::ShapeStack::const_reverse_iterator ps1, ps2;

  for (ps1 = shapes.rbegin(), ps2 = shapes.rend(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape1 = *ps1;

    CQIllustratorShapeNearestPoint2D point = shape1->nearestPoint(p, type);

    if (shape == 0 || point.getDist() < dist) {
      shape  = shape1;
      npoint = point;
    }
  }

  if (shape) {
    setSelectShape(shape);

    CQIllustratorSelectedShape &sshape = selection_->front();

    if (! add && ! remove)
      selection_->clearShapePoints(sshape);

    if (! remove)
      selection_->addShapePoint(sshape, npoint.getPoint());
    else
      selection_->removeShapePoint(sshape, npoint.getPoint());
  }
}

void
CQIllustrator::
selectPointAt(CQIllustratorShape *shape, const CPoint2D &p, CQIllustratorShape::ControlType type,
              bool add, bool remove)
{
  CQIllustratorShapeNearestPoint2D npoint = shape->nearestPoint(p, type);

  if (! npoint.isSet())
    return;

  if      (add)
    addSelectShape(shape);
  else if (! remove)
    setSelectShape(shape);

  CQIllustratorSelectedShape &sshape = selection_->front();

  if (! add && ! remove)
    selection_->clearShapePoints(sshape);

  if (! remove)
    selection_->addShapePoint(sshape, npoint.getPoint());
  else
    selection_->removeShapePoint(sshape, npoint.getPoint());
}

void
CQIllustrator::
selectPointsIn(const CBBox2D &bbox, CQIllustratorShape::ControlType type,
               bool add, bool remove)
{
  if (! add && ! remove)
    clearSelection();

  CQIllustratorData::ShapeList shapes;

  getData()->getObjectsTouching(bbox, shapes);

  selection_->startSelect();

  CQIllustratorData::ShapeList::const_iterator ps1, ps2;

  for (ps1 = shapes.begin(), ps2 = shapes.end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = *ps1;

    CQIllustratorShape::ControlPointList controlPoints;

    shape->getControlPoints(controlPoints, type);

    uint numControlPoints = controlPoints.size();

    for (uint i = 0; i < numControlPoints; ++i) {
      CPoint2D p = controlPoints[i]->getPoint(shape);

      if (! bbox.inside(p)) continue;

      selection_->add(shape);

      CQIllustratorSelectedShape &sshape = selection_->get(shape);

      if (! remove)
        selection_->addShapePoint(sshape, controlPoints[i]);
      else
        selection_->removeShapePoint(sshape, controlPoints[i]);
    }
  }

  selection_->endSelect();
}

void
CQIllustrator::
selectLinesIn(const CBBox2D &bbox, bool add, bool remove)
{
  if (! add && ! remove)
    clearSelection();

  CQIllustratorData::ShapeList shapes;

  getData()->getObjectsTouching(bbox, shapes);

  selection_->startSelect();

  CQIllustratorData::ShapeList::const_iterator ps1, ps2;

  for (ps1 = shapes.begin(), ps2 = shapes.end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = *ps1;

    CQIllustratorShape::ControlLineList controlLines;

    shape->getControlLines(controlLines);

    uint numControlLines = controlLines.size();

    for (uint i = 0; i < numControlLines; ++i) {
      CLine2D l = controlLines[i]->getLine(shape);

      const CPoint2D &p1 = l.start();
      const CPoint2D &p2 = l.end();

      if (! bbox.inside(p1) || ! bbox.inside(p2)) continue;

      selection_->add(shape);

      CQIllustratorSelectedShape &sshape = selection_->get(shape);

      if (! remove)
        selection_->addShapeLine(sshape, controlLines[i]);
      else
        selection_->removeShapeLine(sshape, controlLines[i]);
    }
  }

  selection_->endSelect();
}

void
CQIllustrator::
cyclePrev()
{
  CQIllustratorShape *select_shape = 0;

  if (selection_->size() == 1)
    select_shape = selection_->front().getShape();

  CQIllustratorShape *shape = 0;

  const CQIllustratorData::ShapeStack &shapes = getShapes();

  CQIllustratorData::ShapeStack::const_reverse_iterator ps1, ps2;

  for (ps1 = shapes.rbegin(), ps2 = shapes.rend(); ps1 != ps2; ++ps1) {
    if      (select_shape == 0) {
      shape = *ps1;

      break;
    }
    else if (select_shape == *ps1) {
      ++ps1;

      if (ps1 != ps2)
        shape = *ps1;
      else
        shape = shapes.back();

      break;
    }
  }

  setSelectShape(shape);
}

void
CQIllustrator::
cycleNext()
{
  CQIllustratorShape *select_shape = 0;

  if (selection_->size() == 1)
    select_shape = selection_->front().getShape();

  CQIllustratorShape *shape = 0;

  const CQIllustratorData::ShapeStack &shapes = getShapes();

  CQIllustratorData::ShapeStack::const_iterator ps1, ps2;

  for (ps1 = shapes.begin(), ps2 = shapes.end(); ps1 != ps2; ++ps1) {
    if      (select_shape == 0) {
      shape = *ps1;

      break;
    }
    else if (select_shape == *ps1) {
      ++ps1;

      if (ps1 != ps2)
        shape = *ps1;
      else
        shape = shapes.front();

      break;
    }
  }

  setSelectShape(shape);
}

void
CQIllustrator::
draw(QPainter *painter)
{
  if (changed_) {
    QPainter ipainter(&qimage_);

    if (! canvas_->getPressed())
      ipainter.setRenderHints(QPainter::Antialiasing);

    ipainter.fillRect(qimage_.rect(), QBrush(CQUtil::rgbaToColor(bg_)));

    //ipainter.setWorldTransform(painter->worldTransform());
    ipainter.setTransform(painter->transform());

    drawContents(&ipainter);

    dim_valid_ = false;
  }

  painter->setWorldMatrixEnabled(false);

//painter->fillRect(qimage_.rect(), QBrush(CQUtil::rgbaToColor(bg_)));

  if (! dimmed_)
    painter->drawImage(QPoint(0, 0), qimage_);
  else {
    if (! dim_valid_) {
      dim_qimage_ = qimage_.copy();

      dimQImage(qimage_, dim_qimage_);

      dim_valid_ = true;
    }

    painter->drawImage(QPoint(0, 0), dim_qimage_);
  }

  painter->setWorldMatrixEnabled(true);

  if (! dimmed_)
    drawOverlay(painter);

  drawPreviewObjects(painter);

  if (quad_tree_)
    drawQuadTree(painter);

  changed_ = false;
}

void
CQIllustrator::
dimQImage(const QImage &qimage, QImage &dim_qimage)
{
  uint w = qimage.width();
  uint h = qimage.height();

  for (uint y = 0; y < h; ++y) {
    for (uint x = 0; x < w; ++x) {
      QRgb rgb = qimage.pixel(x, y);

      int g = std::min(int(127.0*(qGray(rgb)/255.0) + 128.0), 255);

      dim_qimage.setPixel(x, y, qRgb(g, g, g));
    }
  }
}

void
CQIllustrator::
drawContents(QPainter *painter)
{
  int w = qimage_.width ();
  int h = qimage_.height();

  QPointF tl = getITransform().map(QPointF(0    , h - 1));
  QPointF br = getITransform().map(QPointF(w - 1, 0    ));

  CBBox2D bbox = CQUtil::fromQRect(QRectF(tl, br));

  //------

  QPen pen;

  pen.setColor(QColor(0,0,0));
  pen.setStyle(Qt::SolidLine);

  painter->setPen(pen);

  drawer_->setPainter(painter);

  drawer_->pushMatrix(canvas_->getMatrix());

  //------

  grid_.draw(drawer_, bbox);

  //------

  const CQIllustratorLayerStack::LayerStack &layerStack = layerStack_->getLayerStack();

  CQIllustratorLayerStack::LayerStack::const_iterator p1, p2;

  for (p1 = layerStack.begin(), p2 = layerStack.end(); p1 != p2; ++p1) {
    const CQIllustratorLayer *layer = layerStack_->getLayer(*p1);

    CQIllustratorData *data = layer->getData();

    CQIllustratorData::ShapeList shapes;

    data->getOrderedObjectsTouching(bbox, shapes);

    CQIllustratorData::ShapeList::const_iterator ps1, ps2;

    for (ps1 = shapes.begin(), ps2 = shapes.end(); ps1 != ps2; ++ps1) {
      CQIllustratorShape *shape = *ps1;

      if (! shape->getVisible()) continue;

      const CBBox2D &bbox = shape->getBBox();

      drawer_->setBBox(bbox);

      shape->draw(drawer_);
    }
  }

  drawer_->popMatrix();
}

void
CQIllustrator::
drawOverlay(QPainter *painter)
{
  drawer_->setPainter(painter);

  drawer_->pushMatrix(canvas_->getMatrix());

  currentMode_->drawSelection(drawer_);

  sandbox_->draw(drawer_);

  currentMode_->drawOverlay(drawer_);

  drawer_->popMatrix();
}

void
CQIllustrator::
drawQuadTree(QPainter *painter)
{
  const CQIllustratorData::QuadTree *tree = getData()->getQuadTree();

  uint max_num = tree->maxElements();

  drawQuadTree(painter, tree, max_num);
}

void
CQIllustrator::
drawQuadTree(QPainter *painter, const CQIllustratorData::QuadTree *tree, uint max_num)
{
  const CQIllustratorData::QuadTree::DataList &dataList = tree->getDataList();

  const CBBox2D &bbox = tree->getBBox();

  //uint num = dataList.size();

  //double gray = 0.1;

  //if (num > 0) gray = (1.0*num)/max_num;

  painter->fillRect(CQUtil::toQRect(bbox), QBrush(CQUtil::rgbaToColor(CRGBA(0.0,0.0,0.8,0.5))));

  uint depth = tree->getDepth();

  double r = 1.0 - 0.1*depth;

  CQIllustratorData::QuadTree::DataList::const_iterator p1 = dataList.begin();
  CQIllustratorData::QuadTree::DataList::const_iterator p2 = dataList.end  ();

  for ( ; p1 != p2; ++p1) {
    const CBBox2D &bbox = (*p1)->getBBox();

    painter->fillRect(CQUtil::toQRect(bbox), QBrush(CQUtil::rgbaToColor(CRGBA(0.0,0.0,r,0.5))));
  }

  if (tree->getBLTree() != 0) {
    const CQIllustratorData::QuadTree *bl_tree = tree->getBLTree();
    const CQIllustratorData::QuadTree *br_tree = tree->getBRTree();
    const CQIllustratorData::QuadTree *tl_tree = tree->getTLTree();
    const CQIllustratorData::QuadTree *tr_tree = tree->getTRTree();

    drawQuadTree(painter, bl_tree, max_num);
    drawQuadTree(painter, br_tree, max_num);
    drawQuadTree(painter, tl_tree, max_num);
    drawQuadTree(painter, tr_tree, max_num);
  }
}

void
CQIllustrator::
anchorObjectSlot()
{
  setMode(MODE_ANCHOR_OBJECT);
}

void
CQIllustrator::
anchorPositionSlot()
{
  setMode(MODE_ANCHOR_POSITION);
}

void
CQIllustrator::
cancelAnchorSlot()
{
  setMode(MODE_SELECT);
}

void
CQIllustrator::
selectAllSlot()
{
  selectAll();
}

void
CQIllustrator::
selectNoneSlot()
{
  selectNone();
}

void
CQIllustrator::
selectAll()
{
  selection_->startSelect();

  clearSelection();

  const CQIllustratorData::ShapeStack &shapes = getShapes();

  CQIllustratorData::ShapeStack::const_iterator ps1, ps2;

  for (ps1 = shapes.begin(), ps2 = shapes.end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = *ps1;

    selection_->add(shape);
  }

  selection_->endSelect();

  redrawOverlay();
}

void
CQIllustrator::
selectNone()
{
  clearSelection();

  redrawOverlay();
}

void
CQIllustrator::
addCommand(CQIllustratorCmd *cmd)
{
  cmdMgr_->addCommand(cmd);
}

bool
CQIllustrator::
loadCmd(const std::string &filename)
{
  CFile file(filename);

  std::vector<std::string> lines;

  if (! file.toLines(lines))
    return false;

  uint num_lines = lines.size();

  for (uint i = 0; i < num_lines; ++i)
    execCommand(lines[i]);

  return true;
}

bool
CQIllustrator::
execCommand(const std::string &cmd)
{
  return cmdMgr_->execCmd(cmd);
}

void
CQIllustrator::
setCursor(QCursor cursor)
{
  canvas_->setCursor(cursor);
}

void
CQIllustrator::
setDimmed(bool dimmed)
{
  dimmed_ = dimmed;
}

void
CQIllustrator::
groupSlot()
{
  if (selection_->empty()) return;

  CQIllustratorGroupShape *group = createGroupShape();

  CQIllustratorSelectedShapes::iterator ps1, ps2;

  for (ps1 = selection_->begin(), ps2 = selection_->end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = (*ps1).getShape();

    shape->setParent(group);

    // TODO: this is not removing from database just moving in hierarchy
    //removeShape(shape);
  }

  addShape(group);

  setSelectShape(group);
}

void
CQIllustrator::
ungroupSlot()
{
  std::vector<CQIllustratorShape *> groups;

  CQIllustratorSelectedShapes::iterator ps1, ps2;

  for (ps1 = selection_->begin(), ps2 = selection_->end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = (*ps1).getShape();

    const CQIllustratorGroupShape *group = dynamic_cast<CQIllustratorGroupShape *>(shape);

    if (! group) continue;

    CQIllustratorShape *parent = group->getParent();

    const CMatrix2D &m = group->getMatrix();

    const CQIllustratorShape::ShapeList &groupShapes = group->getChildren();

    std::vector<CQIllustratorShape *> shapes;

    CQIllustratorShape::ShapeList::const_iterator pg1, pg2;

    for (pg1 = groupShapes.begin(), pg2 = groupShapes.end(); pg1 != pg2; ++pg1) {
      CQIllustratorShape *groupShape = *pg1;

      groupShape->setMatrix(m*groupShape->getMatrix());

      shapes.push_back(groupShape);
    }

    groups.push_back(shape);

    uint num_shapes = shapes.size();

    for (uint i = 0; i < num_shapes; ++i) {
      CQIllustratorShape *groupShape = shapes[i];

      if (parent)
        parent->addChild(groupShape);
      else
        groupShape->setParent(0);
    }
  }

  uint num_groups = groups.size();

  for (uint i = 0; i < num_groups; ++i)
    removeShape(groups[i]);

  clearSelection();
}

void
CQIllustrator::
copySlot()
{
  std::vector<CQIllustratorShape *> shapes;

  CQIllustratorSelectedShapes::iterator ps1, ps2;

  for (ps1 = selection_->begin(), ps2 = selection_->end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = (*ps1).getShape();

    CQIllustratorShape *shape1 = shape->dup();

    //shape1->moveBy(CPoint2D(1,1));

    getData()->addShape(shape1);

    shapes.push_back(shape1);
  }

  selection_->startSelect();

  clearSelection();

  std::vector<CQIllustratorShape *>::const_iterator pcs1, pcs2;

  for (pcs1 = shapes.begin(), pcs2 = shapes.end(); pcs1 != pcs2; ++pcs1) {
    CQIllustratorShape *shape = *pcs1;

    selection_->add(shape);
  }

  selection_->endSelect();

  redraw();
}

void
CQIllustrator::
deleteSlot()
{
  currentMode_->deleteCurrent();
}

void
CQIllustrator::
raiseSlot()
{
  if (selection_->size() == 1) {
    CQIllustratorShape *shape = selection_->front().getShape();

    getData()->raiseShape(shape);

    redraw();
  }
}

void
CQIllustrator::
lowerSlot()
{
  if (selection_->size() == 1) {
    CQIllustratorShape *shape = selection_->front().getShape();

    getData()->lowerShape(shape);

    redraw();
  }
}

void
CQIllustrator::
flipXSlot()
{
  CQIllustratorSelectedShapes::iterator ps1, ps2;

  for (ps1 = selection_->begin(), ps2 = selection_->end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = (*ps1).getShape();

    checkoutShape(shape, CQIllustratorData::CHANGE_GEOMETRY);

    shape->flip(true);

    checkinShape(shape, CQIllustratorData::CHANGE_GEOMETRY);
  }
}

void
CQIllustrator::
flipYSlot()
{
  CQIllustratorSelectedShapes::iterator ps1, ps2;

  for (ps1 = selection_->begin(), ps2 = selection_->end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = (*ps1).getShape();

    checkoutShape(shape, CQIllustratorData::CHANGE_GEOMETRY);

    shape->flip(false);

    checkinShape(shape, CQIllustratorData::CHANGE_GEOMETRY);
  }
}

void
CQIllustrator::
lockSlot()
{
  CQIllustratorSelectedShapes::iterator ps1, ps2;

  for (ps1 = selection_->begin(), ps2 = selection_->end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = (*ps1).getShape();

    checkoutShape(shape, CQIllustratorData::CHANGE_GEOMETRY);

    shape->setFixed(true);

    checkinShape(shape, CQIllustratorData::CHANGE_GEOMETRY);
  }
}

void
CQIllustrator::
unlockSlot()
{
  CQIllustratorSelectedShapes::iterator ps1, ps2;

  for (ps1 = selection_->begin(), ps2 = selection_->end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = (*ps1).getShape();

    checkoutShape(shape, CQIllustratorData::CHANGE_GEOMETRY);

    shape->setFixed(false);

    checkinShape(shape, CQIllustratorData::CHANGE_GEOMETRY);
  }
}

void
CQIllustrator::
copyStrokeSlot()
{
  if (selection_->size() == 1) {
    CQIllustratorShape *shape = selection_->front().getShape();

    save_stroke_ = shape->getStroke();
    save_fill_   = shape->getFill  ();
  }
}

void
CQIllustrator::
pasteStrokeSlot()
{
  CQIllustratorSelectedShapes::iterator ps1, ps2;

  for (ps1 = selection_->begin(), ps2 = selection_->end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = (*ps1).getShape();

    //------

    checkoutShape(shape, CQIllustratorData::CHANGE_STROKE);

    shape->setStroke(save_stroke_);

    checkinShape(shape, CQIllustratorData::CHANGE_STROKE);

    //------

    checkoutShape(shape, CQIllustratorData::CHANGE_FILL);

    shape->setFill(save_fill_);

    checkinShape(shape, CQIllustratorData::CHANGE_FILL);
  }
}

void
CQIllustrator::
loadFileSlot()
{
  QString title  = "Load Vector File";
  QString cwd    = QString(COSFile::getCurrentDir().c_str());
  QString filter = "SVG, Postscript, Cmd (*.svg *.ps *.cmd)";

  QStringList filenames = QFileDialog::getOpenFileNames(this, title, cwd, filter);

  if (filenames.size() == 0)
    return;

  QStringListIterator fi(filenames);

  while (fi.hasNext())
    loadFile(fi.next());
}

void
CQIllustrator::
saveSVGSlot()
{
  QString title  = "Save SVG File";
  QString cwd    = QString(COSFile::getCurrentDir().c_str());
  QString filter = "SVG (*.svg)";

  QString fileName = QFileDialog::getSaveFileName(this, title, cwd, filter);

  if (fileName.length() == 0)
    return;

  saveSVG(fileName);
}

void
CQIllustrator::
saveCmdSlot()
{
  QString title  = "Save Cmd File";
  QString cwd    = QString(COSFile::getCurrentDir().c_str());
  QString filter = "Cmd (*.cmd)";

  QString fileName = QFileDialog::getSaveFileName(this, title, cwd, filter);

  if (fileName.length() == 0)
    return;

  saveCmd(fileName);
}

void
CQIllustrator::
setDefaultStroke(const CQIllustratorShapeStroke &stroke)
{
  def_stroke_ = stroke;
}

const CQIllustratorShapeStroke &
CQIllustrator::
getDefaultStroke() const
{
  return def_stroke_;
}

void
CQIllustrator::
setDefaultFill(const CQIllustratorShapeFill &fill)
{
  def_fill_ = fill;
}

const CQIllustratorShapeFill &
CQIllustrator::
getDefaultFill() const
{
  return def_fill_;
}

void
CQIllustrator::
acceptMode()
{
  currentMode_->accept();
}

void
CQIllustrator::
cancelMode()
{
  escape_ = true;

  if (currentMode_->cancel()) {
    setMode(MODE_SELECT);

    setCursor(Qt::ArrowCursor);
  }
}

const QTransform &
CQIllustrator::
getTransform() const
{
  return canvas_->getTransform();
}

const QTransform &
CQIllustrator::
getITransform() const
{
  return canvas_->getITransform();
}

CQIllustratorData *
CQIllustrator::
getData() const
{
  return layerStack_->getCurrentData();
}

void
CQIllustrator::
setMode(Mode mode)
{
  static bool locked;

  if (locked) return;

  locked = true;

  //------

  if (currentMode_)
    currentMode_->showToolbar(false);

  //------

  mode_ = mode;

  currentMode_ = getMode(mode_);

  ModeMap::const_iterator p1, p2;

  for (p1 = modeMap_.begin(), p2 = modeMap_.end(); p1 != p2; ++p1) {
    CQMenuItem *menuItem = (*p1).second->getMenuItem();

    if (menuItem)
      menuItem->setChecked(mode_ == (*p1).first);
  }

  modeLabel_->setText(QString("<small><b>Mode</b></small><br>"
                              "%1").arg(currentMode_->getTitle()));

  setCursor(currentMode_->getCursor());

  if (mode_ != MODE_ANCHOR_OBJECT && mode_ != MODE_ANCHOR_POSITION)
    getAlignToolbar()->resetSelectMode();

  redrawOverlay();

  //------

  if (currentMode_)
    currentMode_->showToolbar(true);

  //------

  locked = false;
}

void
CQIllustrator::
setBackground(const CRGBA &bg)
{
  bg_ = bg;

  redraw();
}

void
CQIllustrator::
showConsole()
{
  consoleAction_->setVisible(true);

  consoleEdit_->setFocus();
}

void
CQIllustrator::
consoleExecSlot()
{
  execCommand(consoleEdit_->text().toStdString());

  consoleAction_->setVisible(false);

  consoleEdit_->setText("");

  setCanvasFocus();
}

void
CQIllustrator::
setCanvasFocus()
{
  canvas_->setFocus();
}

void
CQIllustrator::
loadFile(const QString &filename)
{
  std::string filename1 = filename.toStdString();

  CFile file(filename1);

  if (file.getSuffix() == "cmd") {
    loadCmd(filename1);
  }
  else {
    CFileType type = CFile::getType(filename.toStdString());

    if (type != CFILE_TYPE_IMAGE_SVG && type != CFILE_TYPE_IMAGE_PS)
      type = CFILE_TYPE_IMAGE_SVG;

    if      (type == CFILE_TYPE_IMAGE_SVG)
      loadSVG(filename);
    else if (type == CFILE_TYPE_IMAGE_PS)
      loadPS(filename);

    zoomFitSlot();
  }
}

void
CQIllustrator::
loadSVG(const QString &filename)
{
#ifndef SVG_FLIP
  setFlipY(true);
#endif

  CSVG svg;

  svg.setAutoName(true);

  if (! svg.read(filename.toStdString()))
    return;

  startUndoGroup("Load SVG");

#ifdef SVG_FLIP
  CPoint2D c(0,0);
#endif

  CSVGBlock *block = svg.getBlock();

  CSVGObject::ObjectList::iterator p1, p2;

  for (p1 = block->childrenBegin(), p2 = block->childrenEnd(); p1 != p2; ++p1) {
    CSVGObject *object = *p1;

    CQIllustratorShape *shape = addSVGObject(0, object);

    if (! shape) continue;

#ifdef SVG_FLIP
    CPoint2D c1 = shape->getRotateCenter();

    shape->setRotateCenter(c);

    shape->flip();

    shape->setRotateCenter(c1);
#endif

    setSVGShapeName(shape, object);

    addShape(shape);
  }

  endUndoGroup();

  //------

  fileType_ = CFILE_TYPE_IMAGE_SVG;
  fileName_ = filename;

  updateTitle();
}

void
CQIllustrator::
loadPS(const QString &filename)
{
#ifdef PSVIEW
  setFlipY(true);

  startUndoGroup("Load PS");

  CPSViewShapeRenderer renderer(this);

  CPSView psview;

  psview.setRenderer(&renderer);

  psview.openCurrentFile(filename.toStdString());

  psview.executeCurrentFile();

  psview.closeCurrentFile();

  endUndoGroup();

  //------

  fileType_ = CFILE_TYPE_IMAGE_PS;
  fileName_ = filename;

  updateTitle();
#endif
}

void
CQIllustrator::
saveSVG(const QString &filename)
{
  //CPoint2D c = bbox.getCenter();

  CFile file(filename.toStdString());

  if (! file.open(CFileBase::WRITE))
    return;

  CQIllustratorSaveData saveData;

  saveData.bbox = getBBox();
  saveData.file = &file;

  file.printf("<svg>\n");

  const CQIllustratorData::ShapeStack &shapes = getShapes();

  CQIllustratorData::ShapeStack::const_iterator ps1, ps2;

  for (ps1 = shapes.begin(), ps2 = shapes.end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = *ps1;

    if (shape->getParent()) continue;

    //CPoint2D c1 = shape->getRotateCenter();

    //shape->setRotateCenter(c);

    //shape->flip();

    shape->saveSVG(saveData);

    //shape->flip();

    //shape->setRotateCenter(c1);
  }

  file.printf("</svg>\n");

  file.flush();

  file.close();

  //------

  fileType_ = CFILE_TYPE_IMAGE_PS;
  fileName_ = filename;

  updateTitle();
}

void
CQIllustrator::
saveCmd(const QString &filename)
{
  CFile file(filename.toStdString());

  if (! file.open(CFileBase::WRITE))
    return;

  CQIllustratorSaveData saveData;

  saveData.bbox = getBBox();
  saveData.file = &file;

  const CQIllustratorData::ShapeStack &shapes = getShapes();

  CQIllustratorData::ShapeStack::const_iterator ps1, ps2;

  for (ps1 = shapes.begin(), ps2 = shapes.end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = *ps1;

    if (shape->getParent()) continue;

    shape->saveCmd(saveData);
  }

  file.flush();

  file.close();

  //------

  fileType_ = CFILE_TYPE_IMAGE_PS;
  fileName_ = filename;

  updateTitle();
}

CQIllustratorShape *
CQIllustrator::
addSVGObject(CSVGObject *, CSVGObject *object)
{
  if (! object->isDrawable()) return 0;

  CMatrix2D m = object->getTransform();

  CQIllustratorShape *shape = 0;

  uint id = object->getObjType().getId();

  switch (id) {
    case CSVG_OBJ_TYPE_PATH: {
      CPoint2D lp(0,0);

      CPathShape *pathShape = createPathShape();

      pathShape->startGroup();

      shape = pathShape;

      CSVGPath *path = dynamic_cast<CSVGPath *>(object);

      const CSVGPath::PartList &parts = path->getPartList();

      CSVGPath::PartList::const_iterator p1, p2;

      for (p1 = parts.begin(), p2 = parts.end(); p1 != p2; ++p1) {
        CSVGPathPart const *part = *p1;

        CSVGPathPartType type = part->getType();

        switch (type) {
          case CSVG_PATH_PART_MOVE_TO: {
            CSVGPathMoveTo const *pp = dynamic_cast<CSVGPathMoveTo const *>(part);

            CPoint2D pp1 = pp->getPoint();

            pathShape->addMoveTo(pp1);

            lp = pp1;

            break;
          }
          case CSVG_PATH_PART_LINE_TO: {
            CSVGPathLineTo const *pp = dynamic_cast<CSVGPathLineTo const *>(part);

            CPoint2D pp1 = pp->getPoint();

            pathShape->addLineTo(pp1);

            lp = pp1;

            break;
          }
          case CSVG_PATH_PART_RLINE_TO: {
            CSVGPathRLineTo const *pp = dynamic_cast<CSVGPathRLineTo const *>(part);

            CPoint2D pp1 = lp + pp->getPoint();

            pathShape->addLineTo(pp1);

            lp = pp1;

            break;
          }
          case CSVG_PATH_PART_HLINE_TO: {
            CSVGPathHLineTo const *pp = dynamic_cast<CSVGPathHLineTo const *>(part);

            CPoint2D pp1 = lp + CPoint2D(pp->getLength(), 0);

            pathShape->addLineTo(pp1);

            lp = pp1;

            break;
          }
          case CSVG_PATH_PART_VLINE_TO: {
            CSVGPathVLineTo const *pp = dynamic_cast<CSVGPathVLineTo const *>(part);

            CPoint2D pp1 = lp + CPoint2D(0, pp->getLength());

            pathShape->addLineTo(pp1);

            lp = pp1;

            break;
          }
          case CSVG_PATH_PART_ARC_TO: {
            CSVGPathArcTo const *pp = dynamic_cast<CSVGPathArcTo const *>(part);

            double xa = pp->getXA();
            int    fa = pp->getFA();
            int    fs = pp->getFS();

            CPoint2D r = CPoint2D(pp->getRadiusX(), pp->getRadiusY());

            double cx, cy, rx, ry, theta, delta;

            bool unit_circle = false;

            CPoint2D pp2 = pp->getPoint2();

            CSVGUtil::convertArcCoords(lp.x, lp.y, pp2.x, pp2.y, xa, r.x, r.y, fa, fs,
                                       unit_circle, &cx, &cy, &rx, &ry, &theta, &delta);

            CPoint2D c(cx, cy);

            pathShape->addArcTo(c, rx, ry, CMathGen::DegToRad(theta),
                                CMathGen::DegToRad(theta + delta));

            lp = pp2;

            break;
          }
          case CSVG_PATH_PART_RARC_TO: {
            CSVGPathRArcTo const *pp = dynamic_cast<CSVGPathRArcTo const *>(part);

            double xa = pp->getXA();
            int    fa = pp->getFA();
            int    fs = pp->getFS();

            CPoint2D r = CPoint2D(pp->getRadiusX(), pp->getRadiusY());

            double cx, cy, rx, ry, theta, delta;

            bool unit_circle = false;

            CPoint2D pp2 = lp + pp->getPoint2();

            CSVGUtil::convertArcCoords(lp.x, lp.y, pp2.x, pp2.y, xa, r.x, r.y, fa, fs,
                                       unit_circle, &cx, &cy, &rx, &ry, &theta, &delta);

            CPoint2D c(cx, cy);

            pathShape->addArcTo(c, rx, ry, CMathGen::DegToRad(theta),
                                CMathGen::DegToRad(theta + delta));

            lp = pp2;

            break;
          }
          case CSVG_PATH_PART_BEZIER2_TO: {
            CSVGPathBezier2To const *pp = dynamic_cast<CSVGPathBezier2To const *>(part);

            CPoint2D pp1 = pp->getPoint1();
            CPoint2D pp2 = pp->getPoint2();

            pathShape->addCurveTo(pp1, pp2);

            lp = pp2;

            break;
          }
          case CSVG_PATH_PART_RBEZIER2_TO: {
            CSVGPathRBezier2To const *pp = dynamic_cast<CSVGPathRBezier2To const *>(part);

            CPoint2D pp1 = lp + pp->getPoint1();
            CPoint2D pp2 = lp + pp->getPoint2();

            pathShape->addCurveTo(pp1, pp2);

            lp = pp2;

            break;
          }
          case CSVG_PATH_PART_BEZIER3_TO: {
            CSVGPathBezier3To const *pp = dynamic_cast<CSVGPathBezier3To const *>(part);

            CPoint2D pp1 = pp->getPoint1();
            CPoint2D pp2 = pp->getPoint2();
            CPoint2D pp3 = pp->getPoint3();

            pathShape->addCurveTo(pp1, pp2, pp3);

            lp = pp3;

            break;
          }
          case CSVG_PATH_PART_RBEZIER3_TO: {
            CSVGPathRBezier3To const *pp = dynamic_cast<CSVGPathRBezier3To const *>(part);

            CPoint2D pp1 = lp + pp->getPoint1();
            CPoint2D pp2 = lp + pp->getPoint2();
            CPoint2D pp3 = lp + pp->getPoint3();

            pathShape->addCurveTo(pp1, pp2, pp3);

            lp = pp3;

            break;
          }
          case CSVG_PATH_PART_CLOSE_PATH: {
            pathShape->addClose();

            break;
          }
          default:
            std::cerr << "Unhandled path part " << type << std::endl;
            break;
        }
      }

      pathShape->endGroup();

      setShapeSVGStrokeAndFill(pathShape, object);

      break;
    }
    case CSVG_OBJ_TYPE_POLYGON: {
      CPathShape *pathShape = createPathShape();

      shape = pathShape;

      CSVGPolygon *polygon = dynamic_cast<CSVGPolygon *>(object);

      const CSVGPolygon::PointList &points = polygon->getPoints();

      uint num_points = points.size();

      CPoint2D pp1 = points[0];

      pathShape->addMoveTo(pp1);

      for (uint i = 1; i < num_points; ++i) {
        CPoint2D pp1 = points[i];

        pathShape->addLineTo(pp1);
      }

      pathShape->addClose();

      setShapeSVGStrokeAndFill(pathShape, object);

      break;
    }
    case CSVG_OBJ_TYPE_RECT: {
      CSVGRect *rect = dynamic_cast<CSVGRect *>(object);

      const CBBox2D &bbox = rect->getBBox();

      double rx = fabs(rect->getRX());
      double ry = fabs(rect->getRY());

      CPoint2D p1 = bbox.getUL();
      CPoint2D p2 = bbox.getLR();

      CQIllustratorRectShape *rectShape = createRectShape(p1, p2);

      if (rx > 1E-6 && ry >= 1E-6) {
        rectShape->setRadiusX(rx);
        rectShape->setRadiusY(ry);
      }

      shape = rectShape;

      setShapeSVGStrokeAndFill(rectShape, object);

      break;
    }
    case CSVG_OBJ_TYPE_CIRCLE: {
      CSVGCircle *circle = dynamic_cast<CSVGCircle *>(object);

      const CPoint2D &c = circle->getCenter();
      double          r = circle->getRadius();

      CBBox2D bbox(CPoint2D(c.x - r, c.y - r), CPoint2D(c.x + r, c.y + r));

      CPoint2D p1 = bbox.getUL();
      CPoint2D p2 = bbox.getLR();

      CQIllustratorEllipseShape *ellipseShape = createEllipseShape(p1, p2);

      shape = ellipseShape;

      setShapeSVGStrokeAndFill(ellipseShape, object);

      break;
    }
    case CSVG_OBJ_TYPE_ELLIPSE: {
      CSVGEllipse *ellipse = dynamic_cast<CSVGEllipse *>(object);

      const CPoint2D &c  = ellipse->getCenter();
      double          rx = ellipse->getRX();
      double          ry = ellipse->getRY();

      CBBox2D bbox(CPoint2D(c.x - rx, c.y - ry), CPoint2D(c.x + rx, c.y + ry));

      CPoint2D p1 = bbox.getUL();
      CPoint2D p2 = bbox.getLR();

      CQIllustratorEllipseShape *ellipseShape = createEllipseShape(p1, p2);

      shape = ellipseShape;

      setShapeSVGStrokeAndFill(ellipseShape, object);

      break;
    }
    case CSVG_OBJ_TYPE_LINE: {
      CPathShape *pathShape = createPathShape();

      shape = pathShape;

      CSVGLine *line = dynamic_cast<CSVGLine *>(object);

      CPoint2D p1 = line->getStart();
      CPoint2D p2 = line->getEnd  ();

      pathShape->addMoveTo(p1);
      pathShape->addLineTo(p2);

      setShapeSVGStrokeAndFill(pathShape, object);

      break;
    }
    case CSVG_OBJ_TYPE_POLYLINE: {
      CPathShape *pathShape = createPathShape();

      shape = pathShape;

      CSVGPolyLine *poly = dynamic_cast<CSVGPolyLine *>(object);

      const CSVGPolyLine::PointList &points = poly->getPoints();

      uint numPoints = points.size();

      if (numPoints > 0) {
        CPoint2D p = points[0];

        pathShape->addMoveTo(p);
      }

      for (uint i = 1; i < numPoints; ++i) {
        CPoint2D p = points[i];

        pathShape->addLineTo(p);
      }

      setShapeSVGStrokeAndFill(pathShape, object);

      break;
    }
    case CSVG_OBJ_TYPE_TEXT: {
      CSVGText *text = dynamic_cast<CSVGText *>(object);

      CBBox2D bbox;

      text->getBBox(bbox);

      const std::string &str = text->getText();

      CQIllustratorTextShape *textShape = createTextShape(bbox.getLL(), bbox.getUR(), str);

      textShape->setFont(object->getFont());

      shape = textShape;

      setShapeSVGStrokeAndFill(textShape, object);

      break;
    }
    case CSVG_OBJ_TYPE_TSPAN: {
      break;
    }
    case CSVG_OBJ_TYPE_IMAGE: {
      CSVGImage *image = dynamic_cast<CSVGImage *>(object);

      CBBox2D bbox;

      image->getBBox(bbox);

      CPoint2D p1 = bbox.getUL();
      CPoint2D p2 = bbox.getLR();

      CQIllustratorRectShape *rectShape = createRectShape(p1, p2);

      shape = rectShape;

      setShapeSVGStrokeAndFill(rectShape, object);

      CImagePtr img = image->getImage();

      if (img.isValid()) {
        CQIllustratorShapeFill &fill = shape->getFill();

        fill.setImage(img);
      }

      break;
    }
    case CSVG_OBJ_TYPE_TITLE: {
      break;
    }
    case CSVG_OBJ_TYPE_USE: {
      CQIllustratorGroupShape *groupShape = createGroupShape();

      shape = groupShape;

      setShapeSVGStrokeAndFill(groupShape, object);

      CSVGUse *use = dynamic_cast<CSVGUse *>(object);

      CSVGObject *childObject = use->getObject();

      CSVGObject *parent = childObject->getParent();

      childObject->setParent(use);

      CQIllustratorShape *childShape = addSVGObject(object, childObject);

      if (childShape) {
        groupShape->addChild(childShape);

        setSVGShapeName(childShape, childObject);

        addShape(childShape);

        childShape->setParent(groupShape);
      }

      childObject->setParent(parent);

      break;
    }
    case CSVG_OBJ_TYPE_GROUP: {
      CQIllustratorGroupShape *groupShape = createGroupShape();

      shape = groupShape;

      setShapeSVGStrokeAndFill(groupShape, object);

      CSVGObject::ObjectList::iterator p1, p2;

      for (p1 = object->childrenBegin(), p2 = object->childrenEnd(); p1 != p2; ++p1) {
        CSVGObject *childObject = *p1;

        CQIllustratorShape *childShape = addSVGObject(object, childObject);

        if (! childShape) continue;

        groupShape->addChild(childShape);

        setSVGShapeName(childShape, childObject);

        addShape(childShape);

        childShape->setParent(groupShape);
      }

      break;
    }
    default:
      std::cerr << "Unhandled: " << object->getObjType().getName() << std::endl;
      break;
  }

  if (shape)
    shape->setMatrix(m);

  return shape;
}

void
CQIllustrator::
snapShotSlot()
{
  qimage_.save("snapshot.png", "PNG");
}

bool
CQIllustrator::
isInUndoGroup() const
{
  return undo_->isInGroup();
}

void
CQIllustrator::
startUndoGroup(const std::string &str)
{
  undo_->startGroup();

  undo_->getCurrentGroup()->setDesc(str);
}

void
CQIllustrator::
endUndoGroup()
{
  undo_->endGroup();
}

void
CQIllustrator::
undoSlot()
{
  undo_->undo();
}

void
CQIllustrator::
redoSlot()
{
  undo_->redo();
}

void
CQIllustrator::
undoChangedSlot()
{
  redraw();

  undoItem_->setEnabled(undo_->canUndo());
  redoItem_->setEnabled(undo_->canRedo());
}

void
CQIllustrator::
addLayerSlot()
{
  addLayer();
}

void
CQIllustrator::
zoomFullSlot()
{
  zoomFull();
}

void
CQIllustrator::
zoomFitSlot()
{
  zoomFit();
}

void
CQIllustrator::
zoomSelSlot()
{
  zoomSelected();
}

void
CQIllustrator::
gridSlot()
{
  grid_.setEnabled(! grid_.getEnabled());

  redraw();
}

void
CQIllustrator::
flipViewSlot(bool flip)
{
  setFlipY(flip);
}

void
CQIllustrator::
toPolygonSlot()
{
  std::vector<CQIllustratorShape *> old_shapes;
  std::vector<CQIllustratorShape *> new_shapes;

  startUndoGroup("To Polygon");

  CQIllustratorSelectedShapes::iterator ps1, ps2;

  for (ps1 = selection_->begin(), ps2 = selection_->end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = (*ps1).getShape();

    CQIllustratorGroupShape *group = dynamic_cast<CQIllustratorGroupShape *>(shape);

    if (group) continue;

    CPolygon2D polygon;

    if (! shape->getPolygon(polygon))
      continue;

    CQIllustratorPolygonShape *pshape = createPolygonShape();

    pshape->setStroke(shape->getStroke());
    pshape->setFill  (shape->getFill ());

    pshape->setPoints(polygon.getPoints());

    addShape(pshape);

    old_shapes.push_back(shape);
    new_shapes.push_back(pshape);
  }

  endUndoGroup();

  uint num_old_shapes = old_shapes.size();

  for (uint i = 0; i < num_old_shapes; ++i)
    removeShape(old_shapes[i]);

  setSelectShape(0);

  uint num_new_shapes = new_shapes.size();

  for (uint i = 0; i < num_new_shapes; ++i)
    addSelectShape(new_shapes[i]);
}

void
CQIllustrator::
toPathSlot()
{
  std::vector<CQIllustratorShape *> old_shapes;
  std::vector<CQIllustratorShape *> new_shapes;

  startUndoGroup("To Path");

  CQIllustratorSelectedShapes::iterator ps1, ps2;

  for (ps1 = selection_->begin(), ps2 = selection_->end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = (*ps1).getShape();

    CQIllustratorGroupShape *group = dynamic_cast<CQIllustratorGroupShape *>(shape);

    if (group) continue;

    CPathShapePartList parts;

    if (! shape->getPath(parts))
      continue;

    CPathShape *pshape = createPathShape();

    pshape->setParts(parts);

    pshape->setStroke(shape->getStroke());
    pshape->setFill  (shape->getFill ());

    addShape(pshape);

    old_shapes.push_back(shape);
    new_shapes.push_back(pshape);
  }

  endUndoGroup();

  uint num_old_shapes = old_shapes.size();

  for (uint i = 0; i < num_old_shapes; ++i)
    removeShape(old_shapes[i]);

  setSelectShape(0);

  uint num_new_shapes = new_shapes.size();

  for (uint i = 0; i < num_new_shapes; ++i)
    addSelectShape(new_shapes[i]);
}

void
CQIllustrator::
toCurveSlot()
{
  toCurve();
}

void
CQIllustrator::
toCurve()
{
  std::vector<CQIllustratorShape *> old_shapes;
  std::vector<CQIllustratorShape *> new_shapes;

  startUndoGroup("To Curve");

  CQIllustratorSelectedShapes::iterator ps1, ps2;

  for (ps1 = selection_->begin(), ps2 = selection_->end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = (*ps1).getShape();

    CQIllustratorGroupShape *group = dynamic_cast<CQIllustratorGroupShape *>(shape);

    if (group) continue;

    CPathShapePartList parts;

    if (! shape->getPath(parts))
      continue;

    CPathShapePartList parts1;

    if (! parts.removeArcs(parts1))
      parts1 = parts;

    CPathShape *pshape = createPathShape();

    pshape->setParts(parts1);

    pshape->setStroke(shape->getStroke());
    pshape->setFill  (shape->getFill ());

    addShape(pshape);

    old_shapes.push_back(shape);
    new_shapes.push_back(pshape);
  }

  endUndoGroup();

  uint num_old_shapes = old_shapes.size();

  for (uint i = 0; i < num_old_shapes; ++i)
    removeShape(old_shapes[i]);

  setSelectShape(0);

  uint num_new_shapes = new_shapes.size();

  for (uint i = 0; i < num_new_shapes; ++i)
    addSelectShape(new_shapes[i]);
}

void
CQIllustrator::
offsetPathSlot()
{
  offsetPath(10);
}

void
CQIllustrator::
offsetPath(double o)
{
  std::vector<CQIllustratorShape *> new_shapes;

  startUndoGroup("Offset Path");

  CQIllustratorSelectedShapes::iterator ps1, ps2;

  for (ps1 = selection_->begin(), ps2 = selection_->end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = (*ps1).getShape();

    CQIllustratorGroupShape *group = dynamic_cast<CQIllustratorGroupShape *>(shape);

    if (group) continue;

    CPathShapePartList parts;

    if (! shape->getPath(parts)) continue;

    CPathShapePartList parts1;

    parts.offsetPath(o, shape->getCenter(), parts1);

    CPathShape *pshape = createPathShape();

    pshape->setParts(parts1);

    pshape->setStroke(shape->getStroke());
    pshape->setFill  (shape->getFill ());

    addShape(pshape);

    new_shapes.push_back(pshape);
  }

  endUndoGroup();

  setSelectShape(0);

  uint num_new_shapes = new_shapes.size();

  for (uint i = 0; i < num_new_shapes; ++i)
    addSelectShape(new_shapes[i]);
}

void
CQIllustrator::
strokePathSlot()
{
  strokePath(10);
}

void
CQIllustrator::
strokePath(double d)
{
  std::vector<CQIllustratorShape *> old_shapes;
  std::vector<CQIllustratorShape *> new_shapes;

  startUndoGroup("Stroke Path");

  CQIllustratorSelectedShapes::iterator ps1, ps2;

  for (ps1 = selection_->begin(), ps2 = selection_->end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = (*ps1).getShape();

    CQIllustratorGroupShape *group = dynamic_cast<CQIllustratorGroupShape *>(shape);

    if (group) continue;

    CPathShapePartList parts;

    if (! shape->getPath(parts))
      continue;

    CPathShapePartList parts1;

    parts.strokePath(d, parts1);

    CPathShape *pshape = createPathShape();

    pshape->setParts(parts1);

    pshape->setStroke(shape->getStroke());
    pshape->setFill  (shape->getFill ());

    addShape(pshape);

    old_shapes.push_back(shape);
    new_shapes.push_back(pshape);
  }

  endUndoGroup();

  uint num_old_shapes = old_shapes.size();

  for (uint i = 0; i < num_old_shapes; ++i)
    removeShape(old_shapes[i]);

  setSelectShape(0);

  uint num_new_shapes = new_shapes.size();

  for (uint i = 0; i < num_new_shapes; ++i)
    addSelectShape(new_shapes[i]);
}

void
CQIllustrator::
geomAndSlot()
{
  geomOp(BOOLEAN_AND);
}

void
CQIllustrator::
geomOrSlot()
{
  geomOp(BOOLEAN_OR);
}

void
CQIllustrator::
geomXorSlot()
{
  geomOp(BOOLEAN_XOR);
}

void
CQIllustrator::
geomNotSlot()
{
  geomOp(BOOLEAN_NOT);
}

void
CQIllustrator::
geomOp(CBooleanOp op)
{
  CGenPolygon subject, clip;

  bool subjectSet = false, clipSet = false;

  CQIllustratorShape *shape1;

  CQIllustratorSelectedShapes::iterator ps1, ps2;

  for (ps1 = selection_->begin(), ps2 = selection_->end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = (*ps1).getShape();

    CQIllustratorGroupShape *group = dynamic_cast<CQIllustratorGroupShape *>(shape);

    if (! group) {
      CPolygon2D polygon;

      if (! shape->getPolygon(polygon))
        continue;

      if (! subjectSet && ! shape->getFixed()) {
        subject.addPolygon(polygon.getX(), polygon.getY(), polygon.getNumPoints());

        shape1 = shape;

        subjectSet = true;
      }
      else {
        clip.addPolygon(polygon.getX(), polygon.getY(), polygon.getNumPoints());

        clipSet = true;
      }
    }
    else {
      std::vector<CPolygon2D> polygons;

      group->getPolygons(polygons);

      uint num_polygons = polygons.size();

      for (uint i = 0; i <  num_polygons; ++i) {
        const CPolygon2D &polygon = polygons[i];

        if (! subjectSet && ! shape->getFixed()) {
          subject.addPolygon(polygon.getX(), polygon.getY(), polygon.getNumPoints());

          shape1 = shape;

          subjectSet = true;
        }
        else {
          clip.addPolygon(polygon.getX(), polygon.getY(), polygon.getNumPoints());

          clipSet = true;
        }
      }
    }
  }

  if (! subjectSet || ! clipSet) return;

  CGenPolygon result, result1;

  if      (op == BOOLEAN_AND) {
    if (! subject.andOp(clip, result))
      return;
  }
  else if (op == BOOLEAN_OR) {
    if (! subject.orOp(clip, result))
      return;
  }
  else if (op == BOOLEAN_XOR) {
    if (! subject.xorOp(clip, result))
      return;
  }
  else if (op == BOOLEAN_NOT) {
    if (! subject.diffOp(clip, result))
      return;

    //bool rc1 = subject.diffOp(clip, result);
    //bool rc2 = clip.diffOp(subject, result1);

    //if (! rc1 && ! rc2)
    //  return;
  }
  else
    return;

  //------

  startUndoGroup("Boolean Geometry Op");

  setSelectShape(0);

  std::vector<CQIllustratorShape *> shapes;

  uint num_contours = result.getNumContours();

  for (uint i = 0; i < num_contours; ++i) {
    CQIllustratorPolygonShape *pshape = createPolygonShape();

    pshape->setStroke(shape1->getStroke());
    pshape->setFill  (shape1->getFill ());

    CGenPolygonContourRef contour = result.getContour(i);

    uint num_vertices = contour.getNumVertices();

    for (uint j = 0; j < num_vertices; ++j) {
      CGenPolygonVertexRef vertex = contour.getVertex(j);

      pshape->addPoint(CPoint2D(vertex.getX(), vertex.getY()));
    }

    addShape(pshape);

    shapes.push_back(pshape);

    setSelectShape(pshape);
  }

  if (op == BOOLEAN_NOT) {
    uint num_contours = result1.getNumContours();

    for (uint i = 0; i < num_contours; ++i) {
      CQIllustratorPolygonShape *pshape = createPolygonShape();

      pshape->setStroke(shape1->getStroke());
      pshape->setFill  (shape1->getFill ());

      CGenPolygonContourRef contour = result1.getContour(i);

      uint num_vertices = contour.getNumVertices();

      for (uint j = 0; j < num_vertices; ++j) {
        CGenPolygonVertexRef vertex = contour.getVertex(j);

        pshape->addPoint(CPoint2D(vertex.getX(), vertex.getY()));
      }

      addShape(pshape);

      shapes.push_back(pshape);

      setSelectShape(pshape);
    }
  }

  removeShape(shape1);

  endUndoGroup();
}

void
CQIllustrator::
flattenSlot()
{
  flatten();
}

void
CQIllustrator::
flatten()
{
  std::vector<CQIllustratorShape *> shapes;

  startUndoGroup("Flatten");

  CQIllustratorSelectedShapes::iterator ps1, ps2;

  for (ps1 = selection_->begin(), ps2 = selection_->end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = (*ps1).getShape();

    CPathShapePartList parts;

    if (! shape->getPath(parts)) continue;

    std::vector<CPolygon2D> polygons;

    parts.flatten(shape->getFlatMatrix(), polygons);

    uint num_polygons = polygons.size();

    for (uint i = 0; i < num_polygons; ++i) {
      const CPolygon2D &polygon = polygons[i];

      const std::vector<CPoint2D> &points = polygon.getPoints();

      CQIllustratorPolygonShape *poly = createPolygonShape();

      poly->setStroke(shape->getStroke());
      poly->setFill  (shape->getFill ());

      uint num_points = points.size();

      for (uint i = 0; i < num_points; ++i)
        poly->addPoint(points[i]);

      addShape(poly);

      shapes.push_back(poly);
    }
  }

  setSelectShape(0);

  uint num_shapes = shapes.size();

  for (uint i = 0; i < num_shapes; ++i)
    addSelectShape(shapes[i]);

  endUndoGroup();
}

void
CQIllustrator::
intersectOrSlot()
{
  intersectOp(BOOLEAN_OR, false, false);
}

void
CQIllustrator::
intersectAndSlot()
{
  intersectOp(BOOLEAN_AND, false, false);
}

void
CQIllustrator::
intersectXor1Slot()
{
  intersectOp(BOOLEAN_XOR, false, false);
}

void
CQIllustrator::
intersectXor2Slot()
{
  intersectOp(BOOLEAN_XOR, true, false);
}

void
CQIllustrator::
intersectOp(CBooleanOp op, bool split, bool keepOld)
{
  CQIllustratorShape *shape1 = 0, *shape2 = 0;

  CQIllustratorSelectedShapes::iterator ps1, ps2;

  for (ps1 = selection_->begin(), ps2 = selection_->end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = (*ps1).getShape();

    if      (! shape1) shape1 = shape;
    else if (! shape2) shape2 = shape;
  }

  if (! shape1 || ! shape2) return;

  CPathShapePartList parts1, parts2;

  if (! shape1->getPath(parts1) || ! shape2->getPath(parts2)) return;

  CPathShapePartListArray ipartsList;

  CPathShapePartList::intersect(op, parts1, shape1->getFlatMatrix(),
                                    parts2, shape2->getFlatMatrix(), ipartsList, split);

  uint numParts = ipartsList.size();

  if (numParts == 0) return;

  //------

  startUndoGroup("Intersect");

  setSelectShape(0);

  if (! keepOld) {
    removeShape(shape1);
    removeShape(shape2);
  }

  for (uint i = 0; i < numParts; ++i) {
    CPathShape *path1 = createPathShape();

    path1->setParts(ipartsList[i]);

    path1->setStroke(shape1->getStroke());
    path1->setFill  (shape1->getFill ());

    addShape(path1);

    addSelectShape(path1);
  }

  endUndoGroup();
}

void
CQIllustrator::
combineSlot()
{
  CQIllustratorShape *shape1 = 0, *shape2 = 0;

  CQIllustratorSelectedShapes::iterator ps1, ps2;

  for (ps1 = selection_->begin(), ps2 = selection_->end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = (*ps1).getShape();

    if      (! shape1) shape1 = shape;
    else if (! shape2) shape2 = shape;
  }

  if (! shape1 || ! shape2) return;

  CPathShapePartList parts1, parts2;

  if (! shape1->getPath(parts1) || ! shape2->getPath(parts2)) return;

  CPathShapePartList cparts;

  if (! CPathShapePartList::combine(parts1, shape1->getFlatMatrix(),
                                                parts2, shape2->getFlatMatrix(), cparts))
    return;

  //------

  startUndoGroup("Combine");

  removeShape(shape1);
  removeShape(shape2);

  CPathShape *path1 = createPathShape();

  path1->setParts(cparts);

  path1->setStroke(shape1->getStroke());
  path1->setFill  (shape1->getFill ());

  addShape(path1);

  setSelectShape(path1);

  endUndoGroup();
}

void
CQIllustrator::
triangulateSlot()
{
  std::vector<CQIllustratorShape *> old_shapes;
  std::vector<CQIllustratorShape *> new_shapes;

  startUndoGroup("Gift Wrap");

  CQIllustratorSelectedShapes::iterator ps1, ps2;

  for (ps1 = selection_->begin(), ps2 = selection_->end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = (*ps1).getShape();

    CQIllustratorGroupShape *group = dynamic_cast<CQIllustratorGroupShape *>(shape);

    if (group) continue;

    CPolygon2D polygon;

    if (! shape->getPolygon(polygon))
      continue;

    const std::vector<CPoint2D> &points = polygon.getPoints();

    std::vector<CTriangle2D> triangleList;

    if (! CTriangulate2D::triangulate(points, triangleList))
      continue;

    uint numTriangleList = triangleList.size();

    for (uint i = 0; i < numTriangleList; ++i) {
      const CTriangle2D &t = triangleList[i];

      CQIllustratorPolygonShape *pshape = createPolygonShape();

      pshape->setStroke(shape->getStroke());
      pshape->setFill  (shape->getFill ());

      pshape->addPoint(t.getPoint1());
      pshape->addPoint(t.getPoint2());
      pshape->addPoint(t.getPoint3());

      addShape(pshape);

      new_shapes.push_back(pshape);
    }

    old_shapes.push_back(shape);
  }

  uint num_old_shapes = old_shapes.size();

  for (uint i = 0; i < num_old_shapes; ++i)
    removeShape(old_shapes[i]);

  endUndoGroup();

  setSelectShape(0);

  uint num_new_shapes = new_shapes.size();

  for (uint i = 0; i < num_new_shapes; ++i)
    addSelectShape(new_shapes[i]);
}

void
CQIllustrator::
giftWrapSlot()
{
  std::vector<CQIllustratorShape *> old_shapes;
  std::vector<CQIllustratorShape *> new_shapes;

  startUndoGroup("Gift Wrap");

  CQIllustratorSelectedShapes::iterator ps1, ps2;

  for (ps1 = selection_->begin(), ps2 = selection_->end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = (*ps1).getShape();

    CQIllustratorGroupShape *group = dynamic_cast<CQIllustratorGroupShape *>(shape);

    if (group) continue;

    CPolygon2D polygon;

    if (! shape->getPolygon(polygon))
      continue;

    const std::vector<CPoint2D> &points = polygon.getPoints();

    CGiftWrap giftWrap;

    std::vector<uint> poly_inds;

    if (! giftWrap.calc(points, poly_inds))
      continue;

    std::vector<CPoint2D> gpoints;

    uint num_inds = poly_inds.size();

    for (uint i = 0; i < num_inds; ++i)
      gpoints.push_back(points[poly_inds[i]]);

    CQIllustratorPolygonShape *pshape = createPolygonShape();

    pshape->setStroke(shape->getStroke());
    pshape->setFill  (shape->getFill ());

    pshape->setPoints(gpoints);

    addShape(pshape);

    old_shapes.push_back(shape);
    new_shapes.push_back(pshape);
  }

  endUndoGroup();

  uint num_old_shapes = old_shapes.size();

  for (uint i = 0; i < num_old_shapes; ++i)
    removeShape(old_shapes[i]);

  setSelectShape(0);

  uint num_new_shapes = new_shapes.size();

  for (uint i = 0; i < num_new_shapes; ++i)
    addSelectShape(new_shapes[i]);
}

void
CQIllustrator::
delaunaySlot()
{
  std::vector<CQIllustratorShape *> old_shapes;
  std::vector<CQIllustratorShape *> new_shapes;

  startUndoGroup("Delaunay");

  CQIllustratorSelectedShapes::iterator ps1, ps2;

  for (ps1 = selection_->begin(), ps2 = selection_->end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = (*ps1).getShape();

    CQIllustratorGroupShape *group = dynamic_cast<CQIllustratorGroupShape *>(shape);

    if (group) continue;

    CPolygon2D polygon;

    if (! shape->getPolygon(polygon))
      continue;

    const std::vector<CPoint2D> &points = polygon.getPoints();

    CDelaunay delaunay;

    uint num_points = points.size();

    for (uint i = 0; i < num_points; ++i)
      delaunay.addVertex(points[i].x, points[i].y);

    delaunay.calc();

    CDelaunay::FaceIterator pf1, pf2;

    for (pf1 = delaunay.facesBegin(), pf2 = delaunay.facesEnd(); pf1 != pf2; ++pf1) {
      const CDelaunay::Face *f = *pf1;

      if (! f->isLower()) continue;

      CDelaunay::Vertex *v1 = f->vertex(0);
      CDelaunay::Vertex *v2 = f->vertex(1);
      CDelaunay::Vertex *v3 = f->vertex(2);

      CTriangle2D triangle(CPoint2D(v1->x(), v1->y()),
                           CPoint2D(v2->x(), v2->y()),
                           CPoint2D(v3->x(), v3->y()));

      CPoint2D c = triangle.centroid();

      if (! polygon.insideEvenOdd(c)) continue;

      CQIllustratorPolygonShape *pshape = createPolygonShape();

      pshape->setStroke(shape->getStroke());
      pshape->setFill  (shape->getFill ());

      pshape->addPoint(triangle.getPoint1());
      pshape->addPoint(triangle.getPoint2());
      pshape->addPoint(triangle.getPoint3());

      addShape(pshape);

      new_shapes.push_back(pshape);
    }

    old_shapes.push_back(shape);
  }

  uint num_old_shapes = old_shapes.size();

  for (uint i = 0; i < num_old_shapes; ++i)
    removeShape(old_shapes[i]);

  endUndoGroup();

  setSelectShape(0);

  uint num_new_shapes = new_shapes.size();

  for (uint i = 0; i < num_new_shapes; ++i)
    addSelectShape(new_shapes[i]);
}

void
CQIllustrator::
addLayer()
{
  layerStack_->addLayer();
}

void
CQIllustrator::
zoomFull()
{
  setBBox(getFullBBox());
}

void
CQIllustrator::
zoomFit()
{
  CBBox2D bbox = getFitBBox();

  setBBox(bbox);
}

CBBox2D
CQIllustrator::
getFitBBox() const
{
  CBBox2D bbox;

  const CQIllustratorData::ShapeStack &shapes = getShapes();

  CQIllustratorData::ShapeStack::const_iterator ps1, ps2;

  for (ps1 = shapes.begin(), ps2 = shapes.end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = *ps1;

    bbox += shape->getBBox();
  }

  return bbox;
}

void
CQIllustrator::
zoomSelected()
{
  if (! selection_->empty()) {
    CBBox2D bbox;

    CQIllustratorSelectedShapes::iterator ps1, ps2;

    for (ps1 = selection_->begin(), ps2 = selection_->end(); ps1 != ps2; ++ps1) {
      CQIllustratorShape *shape = (*ps1).getShape();

      bbox += shape->getBBox();
    }

    setBBox(bbox);
  }
}

#if 0
uint
CQIllustrator::
getNumSelected() const
{
  return selection_->size();
}

CQIllustratorSelectedShapes::iterator
CQIllustrator::
getSelectionBegin()
{
  return selection_->begin();
}

CQIllustratorSelectedShapes::iterator
CQIllustrator::
getSelectionEnd()
{
  return selection_->end();
}

CQIllustratorSelectedShapes::const_iterator
CQIllustrator::
getSelectionBegin() const
{
  return selection_->begin();
}

CQIllustratorSelectedShapes::const_iterator
CQIllustrator::
getSelectionEnd() const
{
  return selection_->end();
}

CQIllustratorSelectedShape &
CQIllustrator::
getSelectionFront()
{
  return selection_->front();
}

const CQIllustratorSelectedShape &
CQIllustrator::
getSelectionFront() const
{
  return selection_->front();
}
#endif

void
CQIllustrator::
setLayer(const std::string &name)
{
  layerStack_->setLayer(name);

  selectNone();
}

void
CQIllustrator::
checkoutShape(CQIllustratorShape *shape, CQIllustratorData::ChangeType changeType)
{
  getData()->checkoutShape(shape, changeType);
}

void
CQIllustrator::
checkinShape(CQIllustratorShape *shape, CQIllustratorData::ChangeType changeType)
{
  getData()->checkinShape(shape, changeType);
}

void
CQIllustrator::
moveSelectedShapes(const CPoint2D &d)
{
  currentMode_->moveCurrent(d);
}

void
CQIllustrator::
moveSelectedPoints(const CPoint2D &d)
{
  currentMode_->moveCurrentPoint(d);
}

void
CQIllustrator::
resizeSelectedShapes(const CBBox2D &d)
{
  currentMode_->resizeCurrent(d);
}

void
CQIllustrator::
deleteSelectedShapes()
{
  CQIllustratorSelectedShapes::iterator ps1, ps2;

  for (ps1 = selection_->begin(), ps2 = selection_->end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = (*ps1).getShape();

    removeShape(shape);

    delete shape;
  }

  clearSelection();
}

void
CQIllustrator::
deleteSelectedPoints()
{
  CQIllustratorSelectedShapes::iterator ps1, ps2;

  for (ps1 = selection_->begin(), ps2 = selection_->end(); ps1 != ps2; ++ps1) {
    const CQIllustratorSelectedShape &sshape = *ps1;

    CQIllustratorSelectedShape &sshape1 =
      selection_->checkoutShape(sshape, CQIllustratorData::CHANGE_GEOMETRY);

    uint num_points = sshape.numPoints();

    for (uint i = 0; i < num_points; ++i) {
      const CQIllustratorShapeControlPoint *point = sshape.getPoint(i);

      sshape1.getShape()->removePoint(point);
    }
  }

  redraw();
}

void
CQIllustrator::
zoomIn()
{
  CPoint2D c = getBBox().getCenter();

  double scale = sqrt(2);

  double size = getBBox().getWidth()/scale;

  CBBox2D bbox(CPoint2D(c.x - size/2, c.y - size/2), CPoint2D(c.x + size/2, c.y + size/2));

  setBBox(bbox);
}

void
CQIllustrator::
zoomOut()
{
  CPoint2D c = getBBox().getCenter();

  double scale = sqrt(2);

  double size = getBBox().getWidth()*scale;

  CBBox2D bbox(CPoint2D(c.x - size/2, c.y - size/2), CPoint2D(c.x + size/2, c.y + size/2));

  setBBox(bbox);
}

void
CQIllustrator::
aboutSlot()
{
}

void
CQIllustrator::
strokeSlot(const CQIllustratorShapeStroke &stroke)
{
  if (! selection_->empty()) {
    CQIllustratorSelectedShapes::iterator ps1, ps2;

    for (ps1 = selection_->begin(), ps2 = selection_->end(); ps1 != ps2; ++ps1) {
      CQIllustratorShape *shape = (*ps1).getShape();

      shape->setStroke(stroke);
    }

    redraw();
  }
}

void
CQIllustrator::
fillSlot(const CQIllustratorShapeFill &fill)
{
  if (! selection_->empty()) {
    CQIllustratorSelectedShapes::iterator ps1, ps2;

    for (ps1 = selection_->begin(), ps2 = selection_->end(); ps1 != ps2; ++ps1) {
      CQIllustratorShape *shape = (*ps1).getShape();

      shape->setFill(fill);
    }

    redraw();
  }
}

void
CQIllustrator::
clipSlot(bool clip)
{
  if (! selection_->empty()) {
    CQIllustratorSelectedShapes::iterator ps1, ps2;

    for (ps1 = selection_->begin(), ps2 = selection_->end(); ps1 != ps2; ++ps1) {
      CQIllustratorShape *shape = (*ps1).getShape();

      shape->setClip(clip);
    }

    redraw();
  }
}

#if 0
void
CQIllustrator::
fontSlot(const QFont &font)
{
  CFontPtr cfont = CQUtil::fromQFont(font);

  CQIllustratorSelectedShapes::iterator ps1, ps2;

  for (ps1 = selection_->begin(), ps2 = selection_->end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = *ps1;

    CQIllustratorTextShape *text = dynamic_cast<CQIllustratorTextShape *>(shape);

    if (text) {
      checkoutShape(shape, CQIllustratorData::CHANGE_FONT);

      CQIllustratorTextShape *text = dynamic_cast<CQIllustratorTextShape *>(shape);

      text->setFont(cfont);

      checkinShape(shape, CQIllustratorData::CHANGE_FONT);
    }
  }

  redraw();
}
#endif

void
CQIllustrator::
objectSlot(const QString &)
{
}

void
CQIllustrator::
propSlot()
{
  redraw();
}

void
CQIllustrator::
setShapeSVGStrokeAndFill(CQIllustratorShape *shape, CSVGObject *object)
{
  CQIllustratorShapeStroke stroke;
  CQIllustratorShapeFill   fill;

  double opacity = object->getOpacity();

  stroke.setColor   (object->getStrokeColor());
  stroke.setOpacity (! stroke.getColor().isTransparent() ?
                     opacity*object->getStrokeOpacity() : 0.0);
  stroke.setWidth   (object->getStrokeWidth());
  stroke.setLineDash(object->getStrokeLineDash());
  stroke.setLineCap (object->getStrokeLineCap());
  stroke.setLineJoin(object->getStrokeLineJoin());

  fill.setColor   (object->getFillColor());
  fill.setOpacity (! fill.getColor().isTransparent() ?
                   opacity*object->getFillOpacity() : 0.0);
  fill.setFillRule(object->getFillRule());

  CSVGObject *fill_object = object->getFillObject();

  if (fill_object) {
    CSVGLinearGradient *lg = dynamic_cast<CSVGLinearGradient *>(fill_object);
    CSVGRadialGradient *rg = dynamic_cast<CSVGRadialGradient *>(fill_object);

    if      (lg) {
      CLinearGradient *lgradient = new CLinearGradient;

      CSVGLinearGradient::StopList::const_iterator ps1, ps2;

      for (ps1 = lg->beginStops(), ps2 = lg->endStops(); ps1 != ps2; ++ps1) {
        CSVGStop *stop = *ps1;

        lgradient->addStop(stop->getOffset(), stop->getAlphaColor());
      }

      CMatrix2D m1;

      if (lg->getGTransformValid())
        m1 = lg->getGTransform();
      else
        m1.setIdentity();

      CPoint2D p1(lg->getX1(), lg->getY1());
      CPoint2D p2(lg->getX2(), lg->getY2());

      p1 = m1*p1;
      p2 = m1*p2;

      if (lg->getUnitsValid() && lg->getUnits() != CSVG_COORD_UNITS_OBJECT_BBOX) {
        const CBBox2D &bbox = shape->getBBox();

        p1.x = (p1.x - bbox.getXMin())/(bbox.getXMax() - bbox.getXMin());
        p1.y = (p1.y - bbox.getYMin())/(bbox.getYMax() - bbox.getYMin());
        p2.x = (p2.x - bbox.getXMin())/(bbox.getXMax() - bbox.getXMin());
        p2.y = (p2.y - bbox.getYMin())/(bbox.getYMax() - bbox.getYMin());
      }

      lgradient->setLine(p1.x, p1.y, p2.x, p2.y);

      lgradient->init(1, 1);

      fill.setGradient(lgradient);

      delete lgradient;
    }
    else if (rg) {
      CRadialGradient *rgradient = new CRadialGradient;

      CSVGRadialGradient::StopList::const_iterator ps1, ps2;

      for (ps1 = rg->beginStops(), ps2 = rg->endStops(); ps1 != ps2; ++ps1) {
        CSVGStop *stop = *ps1;

        rgradient->addStop(stop->getOffset(), stop->getAlphaColor());
      }

      CMatrix2D m1;

      if (rg->getGTransformValid())
        m1 = rg->getGTransform();
      else
        m1.setIdentity();

      CPoint2D  c(rg->getCenterX(), rg->getCenterY());
      CPoint2D  f(rg->getFocusX (), rg->getFocusY ());
      CVector2D r(rg->getRadius (), rg->getRadius ());

      c = m1*c;
      f = m1*f;
      r = m1*r;

      if (rg->getUnitsValid() && rg->getUnits() != CSVG_COORD_UNITS_OBJECT_BBOX) {
        const CBBox2D &bbox = shape->getBBox();

        c.x = (c.x - bbox.getXMin())/(bbox.getXMax() - bbox.getXMin());
        c.y = (c.y - bbox.getYMin())/(bbox.getYMax() - bbox.getYMin());
        f.x = (f.x - bbox.getXMin())/(bbox.getXMax() - bbox.getXMin());
        f.y = (f.y - bbox.getYMin())/(bbox.getYMax() - bbox.getYMin());

        r.setX(2*r.getX()/(bbox.getXMax() - bbox.getXMin()));
        r.setY(2*r.getY()/(bbox.getYMax() - bbox.getYMin()));
      }

      rgradient->setCenter(c.x, c.y);
      rgradient->setFocus (f.x, f.y);
      rgradient->setRadius(std::max(r.getX(), r.getY()));

      rgradient->init(1, 1);

      fill.setGradient(rgradient);

      delete rgradient;
    }
  }

  shape->setStroke(stroke);
  shape->setFill  (fill);
}

void
CQIllustrator::
addLinearGradient(const CPoint2D &p1, const CPoint2D &p2)
{
  CLinearGradient *lgradient = new CLinearGradient;

  lgradient->addStop(0.0, CRGBA(1,1,1));
  lgradient->addStop(1.0, CRGBA(0,0,0));

  // no selection so create rectangle
  if (selection_->empty()) {
    CQIllustratorRectShape *rect = createRectShape(p1, p2);

    addShape(rect);

    setSelectShape(rect);
  }

  // apply gradient to selected shape
  CQIllustratorSelectedShapes::iterator ps1, ps2;

  for (ps1 = selection_->begin(), ps2 = selection_->end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = (*ps1).getShape();

    const CBBox2D &bbox = shape->getBBox();

    double x1 = (p1.x - bbox.getXMin())/(bbox.getXMax() - bbox.getXMin());
    double y1 = (p1.y - bbox.getYMin())/(bbox.getYMax() - bbox.getYMin());
    double x2 = (p2.x - bbox.getXMin())/(bbox.getXMax() - bbox.getXMin());
    double y2 = (p2.y - bbox.getYMin())/(bbox.getYMax() - bbox.getYMin());

    lgradient->setLine(x1, y1, x2, y2);

    lgradient->init(1, 1);

    CQIllustratorShapeFill fill = shape->getFill();

    fill.setGradient(lgradient);

    shape->setFill(fill);
  }

  delete lgradient;
}

void
CQIllustrator::
addRadialGradient(const CPoint2D &p1, const CPoint2D &p2)
{
  CRadialGradient *rgradient = new CRadialGradient;

  rgradient->addStop(0.0, CRGBA(1,1,1));
  rgradient->addStop(1.0, CRGBA(0,0,0));

  // no selection so create ellipse
  if (selection_->empty()) {
    CQIllustratorEllipseShape *ellipse = createEllipseShape(p1, p2);

    addShape(ellipse);

    setSelectShape(ellipse);
  }

  // apply gradient to selected shape
  CQIllustratorSelectedShapes::iterator ps1, ps2;

  for (ps1 = selection_->begin(), ps2 = selection_->end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = (*ps1).getShape();

    const CBBox2D &bbox = shape->getBBox();

    double x1 = (p1.x - bbox.getXMin())/(bbox.getXMax() - bbox.getXMin());
    double y1 = (p1.y - bbox.getYMin())/(bbox.getYMax() - bbox.getYMin());
    double x2 = (p2.x - bbox.getXMin())/(bbox.getXMax() - bbox.getXMin());
    double y2 = (p2.y - bbox.getYMin())/(bbox.getYMax() - bbox.getYMin());

    rgradient->setCenter(x1, y1);

    rgradient->setRadius(CPoint2D(x1, y1).distanceTo(CPoint2D(x2, y2)));

    rgradient->setFocus((x1 + x2)/2, (y1 + y2)/2);

    rgradient->init(1, 1);

    CQIllustratorShapeFill fill = shape->getFill();

    fill.setGradient(rgradient);

    shape->setFill(fill);
  }

  delete rgradient;
}

void
CQIllustrator::
setSVGShapeName(CQIllustratorShape *shape, CSVGObject *object)
{
  std::string id = object->getId();

  if (id != "") {
    CQIllustratorData *data = shape->getData();

    shape->setData(0);

    shape->setName(id);

    shape->setData(data);
  }
  else
    setShapeName(shape);
}

void
CQIllustrator::
addShape(CQIllustratorShape *shape)
{
  getData()->addShape(shape);

  setShapeName(shape);
}

void
CQIllustrator::
removeShape(CQIllustratorShape *shape)
{
  getData()->removeShape(shape);
}

void
CQIllustrator::
setShapeName(CQIllustratorShape *shape)
{
  static int num = 1;

  if (shape->getName() == "") {
    CQIllustratorData *data = shape->getData();

    shape->setData(0);

    shape->setName(CStrUtil::strprintf("%s%d", shape->getClassName(), num));

    shape->setData(data);

    ++num;
  }
}

void
CQIllustrator::
clearSelection()
{
  selection_->clear();
}

void
CQIllustrator::
setSelectShape(const std::string &name)
{
  CQIllustratorShape *shape = getShape(name);

  setSelectShape(shape);
}

void
CQIllustrator::
setSelectShape(CQIllustratorShape *shape)
{
  clearSelection();

  if (shape)
    selection_->add(shape);
}

void
CQIllustrator::
addSelectShape(CQIllustratorShape *shape)
{
  if (shape == 0)
    return;

  selection_->add(shape);
}

void
CQIllustrator::
removeSelectShape(CQIllustratorShape *shape)
{
  if (shape == 0)
    return;

  removeShapeFromSelection(shape);
}

void
CQIllustrator::
removeShapeFromSelection(CQIllustratorShape *shape)
{
  if (shape == 0)
    return;

  CQIllustratorSelectedShapes::iterator ps1, ps2;

  for (ps1 = selection_->begin(), ps2 = selection_->end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape1 = (*ps1).getShape();

    if (shape == shape1) {
      selection_->remove(ps1);

      break;
    }
  }
}

CQIllustratorShape *
CQIllustrator::
getShape(const std::string &name) const
{
  const CQIllustratorData::ShapeStack &shapes = getShapes();

  CQIllustratorData::ShapeStack::const_iterator ps1, ps2;

  for (ps1 = shapes.begin(), ps2 = shapes.end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = *ps1;

    if (shape->getName() == name)
      return shape;
  }

  return 0;
}

CQIllustratorShape *
CQIllustrator::
getShape(uint id) const
{
  const CQIllustratorData::ShapeStack &shapes = getShapes();

  CQIllustratorData::ShapeStack::const_iterator ps1, ps2;

  for (ps1 = shapes.begin(), ps2 = shapes.end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = *ps1;

    if (shape->getId() == id)
      return shape;
  }

  return 0;
}

void
CQIllustrator::
setBBox(const CBBox2D &bbox)
{
  if (REAL_EQ(bbox.getWidth(), 0.0) || REAL_EQ(bbox.getHeight(), 0.0))
    return;

  bbox_ = bbox;

  int w = bbox_.getWidth();
  int h = bbox_.getHeight();

  if (w > h) {
    double dy = (w - h)/2.0;

    bbox_.expand(0, -dy, 0, dy);
  }
  else {
    double dx = (h - w)/2.0;

    bbox_.expand(-dx, 0, dx, 0);
  }

  redraw();
}

void
CQIllustrator::
setFullBBox(const CBBox2D &bbox)
{
  if (REAL_EQ(bbox.getWidth(), 0.0) || REAL_EQ(bbox.getHeight(), 0.0))
    return;

  fullBBox_ = bbox;

  emit fullBBoxChanged();
}

#if 0
QFont
CQIllustrator::
getCurrentFont() const
{
  return fontTool_->getFont();
}
#endif

void
CQIllustrator::
redraw()
{
  if (! changed_) {
    changed_ = true;

    redrawOverlay();
  }
}

void
CQIllustrator::
redrawOverlay()
{
  canvas_->update();
}

CQIllustratorAlignToolbar *
CQIllustrator::
getAlignToolbar() const
{
  CQIllustratorMode *mode = getMode(MODE_ALIGN);

  CQIllustratorAlignMode *alignMode = dynamic_cast<CQIllustratorAlignMode *>(mode);

  if (alignMode)
    return alignMode->getToolbar();
  else
    return 0;
}

void
CQIllustrator::
clearPreviewObjects()
{
  PreviewObjectList::const_iterator p1, p2;

  for (p1 = previewObjects_.begin(), p2 = previewObjects_.end(); p1 != p2; ++p1)
    delete *p1;

  previewObjects_.clear();
}

void
CQIllustrator::
addPreviewObject(PreviewObject *object)
{
  previewObjects_.push_back(object);
}

void
CQIllustrator::
drawPreviewObjects(QPainter *painter)
{
  PreviewObjectList::const_iterator p1, p2;

  for (p1 = previewObjects_.begin(), p2 = previewObjects_.end(); p1 != p2; ++p1)
    (*p1)->draw(this, painter);
}

void
CQIllustrator::
setStroke(QPainter *painter, CQIllustratorShape *shape, const CQIllustratorShapeStroke &stroke)
{
  setStroke(painter, shape, stroke);
}

void
CQIllustrator::
setStroke(QPainter *painter, const CQIllustratorShape *shape,
          const CQIllustratorShapeStroke &stroke)
{
  QPen pen;

  CRGBA color = stroke.getColor();

  color.setAlpha(stroke.getOpacity());

  pen.setColor(CQUtil::rgbaToColor(color));

  double width = shape->getStrokeWidth();

  if (width <= 0.0) width = 0.01;

  pen.setWidthF(width);

  const CLineDash &dash = stroke.getLineDash();

  int num = dash.getNumLengths();

  if (num > 0) {
    pen.setStyle(Qt::CustomDashLine);

    pen.setDashOffset(dash.getOffset());

    QVector<qreal> dashes;

    for (int i = 0; i < num; ++i)
      dashes << dash.getLength(i)/width;

    if (num & 1)
      dashes << dash.getLength(0)/width;

    pen.setDashPattern(dashes);
  }
  else
    pen.setStyle(Qt::SolidLine);

  switch (stroke.getLineCap()) {
    case LINE_CAP_TYPE_BUTT  : pen.setCapStyle(Qt::FlatCap  ); break;
    case LINE_CAP_TYPE_ROUND : pen.setCapStyle(Qt::RoundCap ); break;
    case LINE_CAP_TYPE_SQUARE: pen.setCapStyle(Qt::SquareCap); break;
    default                  : break;
  }

  switch (stroke.getLineJoin()) {
    case LINE_JOIN_TYPE_MITRE: pen.setJoinStyle(Qt::MiterJoin); break;
    case LINE_JOIN_TYPE_ROUND: pen.setJoinStyle(Qt::RoundJoin); break;
    case LINE_JOIN_TYPE_BEVEL: pen.setJoinStyle(Qt::BevelJoin); break;
    default                  : break;
  }

  pen.setMiterLimit(stroke.getMitreLimit());

  painter->setPen(pen);
}

void
CQIllustrator::
setFill(QPainter *painter, CQIllustratorShape *shape,
        const CQIllustratorShapeFill &fill, const CBBox2D &bbox)
{
  setFill(painter, shape, fill, bbox);
}

void
CQIllustrator::
setFill(QPainter *painter, const CQIllustratorShape *,
        const CQIllustratorShapeFill &fill, const CBBox2D &bbox)
{
  if      (fill.hasGradient()) {
    painter->setBrushOrigin(QPointF(0,0));

    const CGenGradient *g = fill.getGradient();

    const CLinearGradient *lg = 0;
    const CRadialGradient *rg = 0;

    if      ((lg = dynamic_cast<const CLinearGradient *>(g)) != 0) {
      QBrush brush(CQUtil::toQGradient(lg));

      painter->setBrush(brush);
    }
    else if ((rg = dynamic_cast<const CRadialGradient *>(g)) != 0) {
      QBrush brush(CQUtil::toQGradient(rg));

      painter->setBrush(brush);
    }
  }
  else if (fill.hasImage()) {
    CImagePtr                          image  = fill.getImage();
    CQIllustratorShapeFill::ImageScale scale  = fill.getImageScale();
    CHAlignType                        halign = fill.getImageHAlign();
    CVAlignType                        valign = fill.getImageVAlign();

    QBrush brush;

    if (image.isValid()) {
      QImage qimage = image.cast<CQImage>()->getQImage();

      brush.setTextureImage(qimage);

      painter->setBrushOrigin(QPointF(0,0));

      int w = image->getWidth();
      int h = image->getHeight();

      QTransform t  = getTransform();
      QTransform it = getITransform();

      if      (scale == CQIllustratorShapeFill::IMAGE_SCALE_NONE) {
        double x, y;

        if      (halign == CHALIGN_TYPE_LEFT)   x = bbox.getXMin();
        else if (halign == CHALIGN_TYPE_RIGHT)  x = bbox.getXMax();
        else                                    x = bbox.getXMid();

        if      (valign == CVALIGN_TYPE_BOTTOM) y = bbox.getYMin();
        else if (valign == CVALIGN_TYPE_TOP   ) y = bbox.getYMax();
        else                                    y = bbox.getYMid();

        double px, py;

        t.map(x, y, &px, &py);

        if (halign == CHALIGN_TYPE_CENTER) px -= w/2;

        QTransform t1;

        t1.translate(px, py);

        brush.setTransform(t1*it);
      }
      else if (scale == CQIllustratorShapeFill::IMAGE_SCALE_FIT) {
        double x = bbox.getXMin();
        double y = bbox.getYMin();

        double px, py;

        t.map(x, y, &px, &py);

        QTransform t1;

        t1.translate(px, py);

        QTransform t2;

        double px1, py1, px2, py2;

        t.map(bbox.getXMin(), bbox.getYMin(), &px1, &py1);
        t.map(bbox.getXMax(), bbox.getYMax(), &px2, &py2);

        double xs = fabs(px2 - px1)/w;
        double ys = fabs(py2 - py1)/h;

        t2.scale(xs, ys);

        brush.setTransform(t2*t1*it);
      }
      else if (scale == CQIllustratorShapeFill::IMAGE_SCALE_EQUAL) {
        double x = bbox.getXMin();
        double y = bbox.getYMin();

        double px, py;

        t.map(x, y, &px, &py);

        QTransform t1;

        t1.translate(px, py);

        QTransform t2;

        double px1, py1, px2, py2;

        t.map(bbox.getXMin(), bbox.getYMin(), &px1, &py1);
        t.map(bbox.getXMax(), bbox.getYMax(), &px2, &py2);

        double xs = fabs(px2 - px1)/w;
        double ys = fabs(py2 - py1)/h;

        double s = std::min(xs, ys);

        t2.scale(s, s);

        QTransform t3;

        double dx = fabs(px2 - px1) - s*w;
        double dy = fabs(py2 - py1) - s*h;

        double dx1, dy1;

        if      (halign == CHALIGN_TYPE_LEFT  ) dx1 = 0;
        else if (halign == CHALIGN_TYPE_RIGHT ) dx1 = dx;
        else                                    dx1 = dx/2.0;

        if      (valign == CVALIGN_TYPE_BOTTOM) dy1 = 0;
        else if (valign == CVALIGN_TYPE_TOP   ) dy1 = dy;
        else                                    dy1 = dy/2.0;

        t3.translate(dx1, dy1);

        brush.setTransform(t3*t2*t1*it);
      }
      else {
        brush.setTransform(it);
      }
    }

    painter->setBrush(brush);
  }
  else {
    CRGBA color = fill.getColor();

    color.setAlpha(fill.getOpacity());

    QBrush brush(CQUtil::rgbaToColor(color));

    painter->setBrush(brush);
  }
}

CQIllustratorRectShape *
CQIllustrator::
createRectShape(const CPoint2D &p1, const CPoint2D &p2, double rx, double ry)
{
  CQIllustratorRectShape *rect = new CQIllustratorRectShape(p1, p2, rx, ry);

  rect->setStroke(def_stroke_);
  rect->setFill  (def_fill_);

  return rect;
}

CQIllustratorEllipseShape *
CQIllustrator::
createEllipseShape(const CPoint2D &p1, const CPoint2D &p2)
{
  CQIllustratorEllipseShape *ellipse = new CQIllustratorEllipseShape(p1, p2);

  ellipse->setStroke(def_stroke_);
  ellipse->setFill  (def_fill_);

  return ellipse;
}

CQIllustratorPolygonShape *
CQIllustrator::
createPolygonShape(const std::vector<CPoint2D> &points)
{
  CQIllustratorPolygonShape *polygon = new CQIllustratorPolygonShape(points);

  polygon->setStroke(def_stroke_);
  polygon->setFill  (def_fill_);

  return polygon;
}

CPathShape *
CQIllustrator::
createPathShape()
{
  CPathShape *path = new CPathShape();

  path->setStroke(def_stroke_);
  path->setFill  (def_fill_);

  return path;
}

CQIllustratorNPolyShape *
CQIllustrator::
createNPolyShape(const CPoint2D &c, uint n, double r, double a)
{
  CQIllustratorNPolyShape *npoly = new CQIllustratorNPolyShape(c, n, r, a);

  npoly->setStroke(def_stroke_);
  npoly->setFill  (def_fill_);

  return npoly;
}

CQIllustratorStarShape *
CQIllustrator::
createStarShape(const CPoint2D &c, uint n, double r1, double r2, double a1, double a2)
{
  CQIllustratorStarShape *star = new CQIllustratorStarShape(c, n, r1, r2, a1, a2);

  star->setStroke(def_stroke_);
  star->setFill  (def_fill_);

  return star;
}

CQIllustratorTextShape *
CQIllustrator::
createTextShape(const CPoint2D &p1, const CPoint2D &p2, const std::string &str)
{
  CQIllustratorTextShape *text = new CQIllustratorTextShape(p1, p2, str);

  text->setStroke(def_stroke_);
  text->setFill  (def_fill_);

  return text;
}

CQIllustratorGroupShape *
CQIllustrator::
createGroupShape()
{
  CQIllustratorGroupShape *group = new CQIllustratorGroupShape();

  group->setStroke(def_stroke_);
  group->setFill  (def_fill_);

  return group;
}

//----------------

void
CQIllustrator::PreviewShape::
draw(CQIllustrator *illustrator, QPainter *painter) const
{
  CQIllustratorShapeDrawer *drawer = illustrator->getDrawer();

  drawer->setPainter(painter);

  QPen pen;

  pen.setColor(QColor(0,0,0));
  pen.setStyle(Qt::DashLine);

  painter->setPen(pen);
  painter->setBrush(Qt::NoBrush);

  painter->drawRect(CQUtil::toQRect(shape_->getBBox()));

  CQIllustratorData *data = shape_->getData();

  shape_->setData(0);

  shape_->moveBy(d_);

  shape_->draw(illustrator->getDrawer());

  pen.setColor(QColor(255,0,0));
  pen.setStyle(Qt::DashLine);

  painter->setPen(pen);
  painter->setBrush(Qt::NoBrush);

  painter->drawRect(CQUtil::toQRect(shape_->getBBox()));

  shape_->moveBy(-d_);

  shape_->setData(data);
}

//------

void
CQIllustrator::PreviewLine::
draw(CQIllustrator *, QPainter *painter) const
{
  QPen pen;

  pen.setColor(QColor(255,0,0));
  pen.setStyle(Qt::SolidLine);

  painter->setPen(pen);
  painter->setBrush(Qt::NoBrush);

  painter->drawLine(CQUtil::toQPoint(p1_), CQUtil::toQPoint(p2_));
}

//------

void
CQIllustratorGrid::
draw(CQIllustratorShapeDrawer *drawer, const CBBox2D &bbox)
{
  if (! enabled_) return;

  //QTransform transform = drawer->getPainter()->worldTransform();
  QTransform transform = drawer->getPainter()->transform();

  QTransform itransform = transform.inverted();

  QPointF p1 = itransform.map(QPointF(0   , 0   ));
  QPointF p2 = itransform.map(QPointF(1000, 1000));

  CAxis2D axis(0, p2.x() - p1.x());

  double dx  = axis.getMajorIncrement();
  double dx1 = axis.getMinorIncrement();

  double dy  = dx;
  double dy1 = dx1;

  double xm = (p1.x() + p2.x())/2.0;
  double ym = (p1.y() + p2.y())/2.0;

  double xo = int(ym/dx)*dx;
  double yo = int(xm/dy)*dy;

  uint n1 = axis.getNumMinorTicks();

#if 0
  double dx = dx_;
  double dy = dy_;

  int nx = int(bbox.getWidth ()/dx);
  int ny = int(bbox.getHeight()/dy);

  while (nx > 40) {
    dx *= 2;

    nx = int(bbox.getWidth ()/dx);
  }

  while (ny > 40) {
    dy *= 2;

    ny = int(bbox.getHeight()/dy);
  }

  dx = std::min(dx, dy);
  dy = dx;

  xo = origin_.x;
  yo = origin_.y;
#endif

  for (double x1 = xo, x2 = x1 + dx; x1 <= bbox.getRight() + dx; x1 = x2, x2 += dx) {
    drawer->drawGridLine(CPoint2D(x1, bbox.getBottom()), CPoint2D(x1, bbox.getTop()));

    for (uint i = 1; i < n1; i++) {
      double x = x1 + i*dx1;

      drawer->drawGridSubLine(CPoint2D(x, bbox.getBottom()), CPoint2D(x, bbox.getTop()));
    }
  }

  for (double x1 = xo, x2 = x1 - dx; x1 >= bbox.getLeft() - dx; x1 = x2, x2 -= dx) {
    drawer->drawGridLine(CPoint2D(x1, bbox.getBottom()), CPoint2D(x1, bbox.getTop()));

    for (uint i = 1; i < n1; i++) {
      double x = x1 + i*dx1;

      drawer->drawGridSubLine(CPoint2D(x, bbox.getBottom()), CPoint2D(x, bbox.getTop()));
    }
  }

  //---

  for (double y1 = yo, y2 = y1 + dy; y1 <= bbox.getTop() + dy; y1 = y2, y2 += dy) {
    drawer->drawGridLine(CPoint2D(bbox.getLeft(), y1), CPoint2D(bbox.getRight(), y1));

    for (uint i = 1; i < n1; i++) {
      double y = y1 + i*dy1;

      drawer->drawGridSubLine(CPoint2D(bbox.getLeft(), y), CPoint2D(bbox.getRight(), y));
    }
  }

  for (double y1 = yo, y2 = y1 - dy; y1 >= bbox.getBottom() - dy; y1 = y2, y2 -= dy) {
    drawer->drawGridLine(CPoint2D(bbox.getLeft(), y1), CPoint2D(bbox.getRight(), y1));

    for (uint i = 1; i < n1; i++) {
      double y = y1 + i*dy1;

      drawer->drawGridSubLine(CPoint2D(bbox.getLeft(), y), CPoint2D(bbox.getRight(), y));
    }
  }
}

//------

CPoint2D
CQIllustratorSnap::
snapPoint(const CPoint2D &point) const
{
  if (enabled_) {
    double x = xpitch_*CMathGen::Round(point.x/xpitch_);
    double y = ypitch_*CMathGen::Round(point.y/ypitch_);

    return CPoint2D(x, y);
  }
  else
    return point;
}

//----------

static const char *source_opts = "\
-file:s=\"\"";

CQIllustratorSourceCmd::
CQIllustratorSourceCmd() :
 CQIllustratorCmd(source_opts)
{
}

bool
CQIllustratorSourceCmd::
exec(const std::vector<std::string> &words)
{
  args_.parse(words);

  std::string filename = args_.getStringArg("-file");

  if (filename == "")
    return false;

  CFile file(filename);

  std::vector<std::string> lines;

  if (! file.toLines(lines))
    return false;

  uint num_lines = lines.size();

  for (uint i = 0; i < num_lines; ++i)
    illustrator_->execCommand(lines[i]);

  return true;
}

//----------

static const char *select_opts = "\
-all:f";

CQIllustratorSelectCmd::
CQIllustratorSelectCmd() :
 CQIllustratorCmd(select_opts)
{
}

bool
CQIllustratorSelectCmd::
exec(const std::vector<std::string> &words)
{
  args_.parse(words);

  bool is_all = args_.getBooleanArg("-all");

  if (is_all)
    illustrator_->selectAll();

  return true;
}

//----------

static const char *move_opts = "\
-x:r=0 \
-y:r=0 \
-dx:r=0 \
-dy:r=0";

CQIllustratorMoveCmd::
CQIllustratorMoveCmd() :
 CQIllustratorCmd(move_opts)
{
}

bool
CQIllustratorMoveCmd::
exec(const std::vector<std::string> &words)
{
  args_.parse(words);

  //double x = args_.getRealArg("-x");
  //double y = args_.getRealArg("-y");

  double dx = args_.getRealArg("-dx");
  double dy = args_.getRealArg("-dy");

  illustrator_->moveSelectedShapes(CPoint2D(dx,dy));

  return true;
}

//----------

static const char *move_point_opts = "\
-x:r=0 \
-y:r=0 \
-dx:r=0 \
-dy:r=0";

CQIllustratorMovePointCmd::
CQIllustratorMovePointCmd() :
 CQIllustratorCmd(move_point_opts)
{
}

bool
CQIllustratorMovePointCmd::
exec(const std::vector<std::string> &words)
{
  args_.parse(words);

  //double x = args_.getRealArg("-x");
  //double y = args_.getRealArg("-y");

  double dx = args_.getRealArg("-dx");
  double dy = args_.getRealArg("-dy");

  illustrator_->moveSelectedPoints(CPoint2D(dx,dy));

  return true;
}

//----------

static const char *undo_opts = "\
-all:f";

CQIllustratorUndoCmd::
CQIllustratorUndoCmd() :
 CQIllustratorCmd(undo_opts)
{
}

bool
CQIllustratorUndoCmd::
exec(const std::vector<std::string> &words)
{
  args_.parse(words);

  illustrator_->getUndo()->undo();

  return true;
}

//----------

static const char *redo_opts = "\
-all:f";

CQIllustratorRedoCmd::
CQIllustratorRedoCmd() :
 CQIllustratorCmd(redo_opts)
{
}

bool
CQIllustratorRedoCmd::
exec(const std::vector<std::string> &words)
{
  args_.parse(words);

  illustrator_->getUndo()->redo();

  return true;
}

//----------

static const char *offset_path_opts = "\
-offset:r=10";

CQIllustratorOffsetPathCmd::
CQIllustratorOffsetPathCmd() :
 CQIllustratorCmd(offset_path_opts)
{
}

bool
CQIllustratorOffsetPathCmd::
exec(const std::vector<std::string> &words)
{
  args_.parse(words);

  double offset = args_.getRealArg("-offset");

  illustrator_->offsetPath(offset);

  return true;
}

//----------

static const char *stroke_path_opts = "\
-width:r=10";

CQIllustratorStrokePathCmd::
CQIllustratorStrokePathCmd() :
 CQIllustratorCmd(stroke_path_opts)
{
}

bool
CQIllustratorStrokePathCmd::
exec(const std::vector<std::string> &words)
{
  args_.parse(words);

  double width = args_.getRealArg("-width");

  illustrator_->strokePath(width);

  return true;
}

//----------

static const char *intersect_opts = "\
-op:s \
-split:f";

CQIllustratorIntersectCmd::
CQIllustratorIntersectCmd() :
 CQIllustratorCmd(intersect_opts)
{
}

bool
CQIllustratorIntersectCmd::
exec(const std::vector<std::string> &words)
{
  args_.parse(words);

  std::string op = args_.getStringArg("-op");

  if (op == "")
    return false;

  bool is_split = args_.getBooleanArg("-split");

  if      (op == "or")
    illustrator_->intersectOp(BOOLEAN_OR, false);
  else if (op == "and")
    illustrator_->intersectOp(BOOLEAN_AND, false);
  else if (op == "xor")
    illustrator_->intersectOp(BOOLEAN_XOR, is_split);
  else
    return false;

  return true;
}
##concat##CQIllustratorCreateEllipseMode.cpp
#include <CQIllustratorCreateEllipseMode.h>
#include <CQIllustrator.h>
#include <CQIllustratorCmd.h>
#include <CQIllustratorHandle.h>
#include <CQIllustratorShapeDrawer.h>

#include <QPainter>
#include <QHBoxLayout>

#include <CQMenu.h>
#include <CQUtil.h>
#include <CQPointEdit.h>
#include <CQRealEdit.h>
#include <CQAngleSpinBox.h>
#include <CQSwatch.h>

#include <xpm/ellipse.xpm>

#include <cursors/circle.xbm>
#include <cursors/circlemask.xbm>

class CQIllustratorCreateEllipseCmd : public CQIllustratorCmd {
 public:
  CQIllustratorCreateEllipseCmd();

  const char *getName() const { return "create_ellipse"; }

  bool exec(const std::vector<std::string> &words);
};

CQIllustratorCreateEllipseMode::
CQIllustratorCreateEllipseMode(CQIllustrator *illustrator) :
 CQIllustratorMode(illustrator, CQIllustrator::MODE_ELLIPSE), equalSize_(false)
{
  setCursor(circle_bits, circlemask_bits, 2, 2);

  illustrator_->addCommand(new CQIllustratorCreateEllipseCmd);
}

CQIllustratorCreateEllipseToolbar *
CQIllustratorCreateEllipseMode::
createToolbar()
{
  toolbar_ = new CQIllustratorCreateEllipseToolbar(this);

  return toolbar_;
}

CQIllustratorCreateEllipseSizer *
CQIllustratorCreateEllipseMode::
createSizer()
{
  sizer_ = new CQIllustratorCreateEllipseSizer(this);

  return sizer_;
}

CQMenuItem *
CQIllustratorCreateEllipseMode::
createMenuItem(CQMenu *menu)
{
  menuItem_ = new CQMenuItem(menu, "&Ellipse", CQMenuItem::CHECKABLE);

  menuItem_->setStatusTip("Create Ellipse");
  menuItem_->setXPMIcon(ellipse_data);

  connect(menuItem_->getAction(), SIGNAL(toggled(bool)), this, SLOT(menuItemSlot()));

  return menuItem_;
}

void
CQIllustratorCreateEllipseMode::
handleMouseRelease(const MouseEvent &e)
{
  CPoint2D p2 = CQUtil::fromQPoint(release_wpos_);

  if (dragging_) {
    if (! moving_) {
      selectControlPoint(e);
    }
    // dragging finished so commit
    else {
      illustrator_->getSandbox()->commit(CQIllustratorData::CHANGE_GEOMETRY);
    }
  }
  // not dragging so do a select
  else {
    CPoint2D p1 = CQUtil::fromQPoint(press_wpos_);

    // point click - select at point
    if (! moving_) {
      (void) illustrator_->selectAt(p1, e.event->isControlKey(), e.event->isShiftKey());
    }
    // drag then create rectangle using specified bbox
    else {
      CBBox2D bbox(p1, p2);

      if (e.event->isShiftKey()) {
        double w = bbox.getWidth ();
        double h = bbox.getHeight();

        if (w > h)
          bbox.setHeight(w);
        else
          bbox.setWidth(h);
      }

      CQIllustratorEllipseShape *ellipse =
        illustrator_->createEllipseShape(bbox.getLL(), bbox.getUR());

      illustrator_->addShape(ellipse);

      illustrator_->setSelectShape(ellipse);
    }
  }

  dragging_ = false;

  illustrator_->redraw();
}

void
CQIllustratorCreateEllipseMode::
handleMouseDrag(const MouseEvent &e)
{
  if (dragging_) {
    CQIllustratorShape *shape = illustrator_->getSandbox()->frontShape();

    sizer_->updatePoint(shape, curr_wpos_);
  }
  else {
    CPoint2D p1 = CQUtil::fromQPoint(press_wpos_);
    CPoint2D p2 = CQUtil::fromQPoint(curr_wpos_);

    CBBox2D bbox(p1, p2);

    equalSize_ = e.event->isShiftKey();

    if (equalSize_) {
      double w = bbox.getWidth ();
      double h = bbox.getHeight();

      if (w > h)
        bbox.setHeight(w);
      else
        bbox.setWidth(h);
    }

    toolbar_->setSize(bbox);
  }

  illustrator_->redrawOverlay();
}

void
CQIllustratorCreateEllipseMode::
drawOverlay(CQIllustratorShapeDrawer *drawer)
{
  QPainter *painter = drawer->getPainter();

  if (! dragging_) {
    // draw creation rubber band
    if (pressed_) {
      CPoint2D p1 = CQUtil::fromQPoint(press_wpos_);
      CPoint2D p2 = CQUtil::fromQPoint(curr_wpos_);

      CBBox2D bbox(p1, p2);

      if (equalSize_) {
        double w = bbox.getWidth ();
        double h = bbox.getHeight();

        if (w > h)
          bbox.setHeight(w);
        else
          bbox.setWidth(h);
      }

      QPen pen;

      pen.setColor(QColor(0,0,0));
      pen.setStyle(Qt::DashLine);

      painter->setPen(pen);
      painter->setBrush(Qt::NoBrush);

      painter->drawRect(CQUtil::toQRect(bbox));
    }

    //------

    // draw handles for single selected shape
    CQIllustratorSelectedShapes *selection = illustrator_->getSelection();

    if (selection->size() == 1) {
      const CQIllustratorSelectedShape &sshape = selection->front();

      const CQIllustratorShape *shape = sshape.getShape();

      sizer_->draw(painter, shape);

      sizer_->drawSelectionHandles(painter, sshape);
    }
  }
  else {
    CQIllustratorShape *shape = illustrator_->getSandbox()->frontShape();

    sizer_->draw(painter, shape);
  }
}

//------------

CQIllustratorCreateEllipseToolbar::
CQIllustratorCreateEllipseToolbar(CQIllustratorCreateEllipseMode *mode) :
 CQIllustratorToolbar(mode), mode_(mode)
{
}

QIcon
CQIllustratorCreateEllipseToolbar::
getIcon()
{
  return QIcon(QPixmap(ellipse_data));
}

void
CQIllustratorCreateEllipseToolbar::
addWidgets()
{
  QBoxLayout *layout = qobject_cast<QBoxLayout *>(CQIllustratorToolbar::layout());

  //-----

  posEdit_     = new CQPointEdit;
  widthEdit_   = new CQRealEdit(0.0);
  heightEdit_  = new CQRealEdit(0.0);
  angle1Edit_  = new CQAngleSpinBox(0.0);
  angle2Edit_  = new CQAngleSpinBox(0.0);
  connectEdit_ = new CQEllipseShape2DConnectType();

  posEdit_    ->setFocusPolicy(Qt::ClickFocus);
  widthEdit_  ->setFocusPolicy(Qt::ClickFocus);
  heightEdit_ ->setFocusPolicy(Qt::ClickFocus);
  angle1Edit_ ->setFocusPolicy(Qt::ClickFocus);
  angle2Edit_ ->setFocusPolicy(Qt::ClickFocus);
  connectEdit_->setFocusPolicy(Qt::ClickFocus);

  connect(posEdit_    , SIGNAL(valueChanged()), this, SLOT(updateShape()));
  connect(widthEdit_  , SIGNAL(valueChanged(double)), this, SLOT(updateShape()));
  connect(heightEdit_ , SIGNAL(valueChanged(double)), this, SLOT(updateShape()));
  connect(angle1Edit_ , SIGNAL(angleChanged(double)), this, SLOT(updateShape()));
  connect(angle2Edit_ , SIGNAL(angleChanged(double)), this, SLOT(updateShape()));
  connect(connectEdit_, SIGNAL(valueChanged()), this, SLOT(updateShape()));

  CQSwatch *posSwatch     = new CQSwatch("Position", posEdit_   );
  CQSwatch *widthSwatch   = new CQSwatch("Width"  , widthEdit_ );
  CQSwatch *heightSwatch  = new CQSwatch("Height" , heightEdit_);
  CQSwatch *angle1Swatch  = new CQSwatch("Start"  , angle1Edit_);
  CQSwatch *angle2Swatch  = new CQSwatch("End"    , angle2Edit_);
  CQSwatch *connectSwatch = new CQSwatch("Connect", connectEdit_);

  layout->addWidget(posSwatch);
  layout->addWidget(widthSwatch);
  layout->addWidget(heightSwatch);
  layout->addWidget(angle1Swatch);
  layout->addWidget(angle2Swatch);
  layout->addWidget(connectSwatch);

  posEdit_    ->setEnabled(false);
  widthEdit_  ->setEnabled(false);
  heightEdit_ ->setEnabled(false);
  angle1Edit_ ->setEnabled(false);
  angle1Edit_ ->setEnabled(false);
  connectEdit_->setEnabled(false);
}

void
CQIllustratorCreateEllipseToolbar::
setSelectedShape(const CQIllustratorShape *shape)
{
  const CQIllustratorEllipseShape *ellipse =
    dynamic_cast<const CQIllustratorEllipseShape *>(shape);

  posEdit_    ->setEnabled(ellipse != 0);
  widthEdit_  ->setEnabled(ellipse != 0);
  heightEdit_ ->setEnabled(ellipse != 0);
  angle1Edit_ ->setEnabled(ellipse != 0);
  angle1Edit_ ->setEnabled(ellipse != 0);
  connectEdit_->setEnabled(ellipse != 0);

  if (ellipse) {
    const CBBox2D &bbox = ellipse->getBBox();

    setSize(bbox);

    angle1Edit_->setValue(ellipse->getAngle1());
    angle2Edit_->setValue(ellipse->getAngle2());

    connectEdit_->setType(ellipse->getConnectType());
  }
  else {
    posEdit_   ->setValue();
    widthEdit_ ->setValue(0.0);
    heightEdit_->setValue(0.0);
    angle1Edit_->setValue(0.0);
    angle2Edit_->setValue(0.0);
  }
}

void
CQIllustratorCreateEllipseToolbar::
setSize(const CBBox2D &bbox)
{
  const CPoint2D &pos = bbox.getLL();

  posEdit_->setValue(pos);

  double w = bbox.getWidth();
  double h = bbox.getHeight();

  widthEdit_ ->setValue(w);
  heightEdit_->setValue(h);
}

void
CQIllustratorCreateEllipseToolbar::
updateShape()
{
  CQIllustrator *illustrator = mode_->getIllustrator();

  CQIllustratorEllipseShape *shape =
    CQIllustratorUtil::getCurrentShape<CQIllustratorEllipseShape>(illustrator);

  if (shape) {
    const CPoint2D &pos = posEdit_->getValue();

    double width  = widthEdit_ ->getValue();
    double height = heightEdit_->getValue();

    double angle1 = angle1Edit_->value();
    double angle2 = angle2Edit_->value();

    CEllipseConnectType connectType = connectEdit_->getType();

    illustrator->checkoutShape(shape, CQIllustratorData::CHANGE_GEOMETRY);

    CQIllustratorEllipseShape *ellipse = dynamic_cast<CQIllustratorEllipseShape *>(shape);

    CBBox2D bbox(pos, CPoint2D(pos.x + width, pos.y + height));

    ellipse->setBBox(bbox);

    ellipse->setAngle1(angle1);
    ellipse->setAngle2(angle2);

    ellipse->setConnectType(connectType);

    illustrator->checkinShape(shape, CQIllustratorData::CHANGE_GEOMETRY);
  }

  illustrator->redraw();
}

//------

CQIllustratorCreateEllipseSizer::
CQIllustratorCreateEllipseSizer(CQIllustratorCreateEllipseMode *mode) :
 CQIllustratorModeSizer(mode)
{
  CQIllustrator *illustrator = mode_->getIllustrator();

  rx_handle_ = new CQIllustratorControlPointHandle(illustrator);
  ry_handle_ = new CQIllustratorControlPointHandle(illustrator);
  a1_handle_ = new CQIllustratorControlPointHandle(illustrator);
  a2_handle_ = new CQIllustratorControlPointHandle(illustrator);

  a1_handle_->setStyle(CQIllustratorHandle::CIRCLE_STYLE);
  a2_handle_->setStyle(CQIllustratorHandle::CIRCLE_STYLE);

  addHandle(rx_handle_);
  addHandle(ry_handle_);
  addHandle(a1_handle_);
  addHandle(a2_handle_);
}

void
CQIllustratorCreateEllipseSizer::
drawHandles(QPainter *painter, const CQIllustratorShape *shape)
{
  const CQIllustratorEllipseShape *ellipse =
    dynamic_cast<const CQIllustratorEllipseShape *>(shape);

  if (ellipse) {
    CQIllustratorShape::ControlPointList controlPoints;

    ellipse->getControlPoints(controlPoints);

    rx_handle_->draw(ellipse, controlPoints[0], painter);
    ry_handle_->draw(ellipse, controlPoints[1], painter);
    a1_handle_->draw(ellipse, controlPoints[2], painter);
    a2_handle_->draw(ellipse, controlPoints[3], painter);
  }
}

//----------

static const char *create_ellipse_opts = "\
-x:r=0 \
-y:r=0 \
-xr:r=100 \
-yr:r=100 \
-a:r=0 \
-name:s";

CQIllustratorCreateEllipseCmd::
CQIllustratorCreateEllipseCmd() :
 CQIllustratorCmd(create_ellipse_opts)
{
}

bool
CQIllustratorCreateEllipseCmd::
exec(const std::vector<std::string> &words)
{
  args_.parse(words);

  double x  = args_.getRealArg("-x");
  double y  = args_.getRealArg("-y");
  double xr = args_.getRealArg("-xr");
  double yr = args_.getRealArg("-yr");
  double a  = args_.getRealArg("-a");

  CBBox2D bbox(CPoint2D(x - xr, y - yr), CSize2D(2*xr, 2*yr));

  CQIllustratorEllipseShape *ellipse =
    illustrator_->createEllipseShape(bbox.getLL(), bbox.getUR());

  std::string name = args_.getStringArg("-name");

  if (name != "")
    ellipse->setName(name);

  ellipse->rotate(M_PI*a/180.0);

  illustrator_->addShape(ellipse);

  illustrator_->setSelectShape(ellipse);

  return true;
}

//---------

CQEllipseShape2DConnectType::
CQEllipseShape2DConnectType(QWidget *parent) :
 QComboBox(parent)
{
  const char *        names [] = { "Line", "Center" };
  CEllipseConnectType values[] = { CELLIPSE_CONNECT_LINE, CELLIPSE_CONNECT_CENTER };

  uint num_names = sizeof(names)/sizeof(names[0]);

  for (uint i = 0; i < num_names; ++i) {
    if (i == 0) value_ = values[0];

    nameValue_[names [i]] = values[i];
    valueName_[values[i]] = names [i];

    addItem(names[i]);
  }

  connect(this, SIGNAL(currentIndexChanged(const QString &)),
          this, SLOT(itemSlot(const QString &)));
}

void
CQEllipseShape2DConnectType::
setType(CEllipseConnectType value)
{
  int num = count();

  for (int i = 0; i < num; ++i) {
    if (nameValue_[itemText(i)] == value) {
      setCurrentIndex(i);
      return;
    }
  }
}

void
CQEllipseShape2DConnectType::
itemSlot(const QString &name)
{
  value_ = nameValue_[name];

  emit valueChanged();
}
##concat##CQIllustratorCreatePathMode.cpp
#include <CQIllustratorCreatePathMode.h>
#include <CQIllustrator.h>
#include <CQIllustratorHandle.h>
#include <CQIllustratorShapeDrawer.h>

#include <QPainter>
#include <QHBoxLayout>
#include <QVBoxLayout>
#include <QRadioButton>

#include <CQMenu.h>
#include <CQUtil.h>
#include <CQPointEdit.h>
#include <CQImageButton.h>
#include <CQSwatch.h>

#include <xpm/path.xpm>
#include <xpm/path_line.xpm>
#include <xpm/path_curve2.xpm>
#include <xpm/path_curve3.xpm>

#include <xpm/path_free.xpm>
#include <xpm/path_rect.xpm>
#include <xpm/path_45.xpm>

#include <xpm/path_corner.xpm>
#include <xpm/path_curve.xpm>
#include <xpm/path_add.xpm>
#include <xpm/path_remove.xpm>

#include <xpm/control_point.xpm>
#include <xpm/control_point_active.xpm>

#include <xpm/snap_point.xpm>
#include <xpm/snap_point_active.xpm>

#include <cursors/select.xbm>
#include <cursors/selectmask.xbm>

#define IMAGE_DATA(I) I, sizeof(I)/sizeof(char *)

CQIllustratorCreatePathMode::
CQIllustratorCreatePathMode(CQIllustrator *illustrator) :
 CQIllustratorMode(illustrator, CQIllustrator::MODE_PATH), selMode_(POINT_SEL),
 pathMode_(CPATH_PART_TYPE_LINE_TO)
{
  setCursor(select_bits, selectmask_bits, 2, 2);
}

void
CQIllustratorCreatePathMode::
setSelMode(SelMode selMode)
{
  selMode_ = selMode;
}

void
CQIllustratorCreatePathMode::
setPathMode(CPathPartType pathMode)
{
  pathMode_ = pathMode;
}

CQIllustratorCreatePathToolbar *
CQIllustratorCreatePathMode::
createToolbar()
{
  toolbar_ = new CQIllustratorCreatePathToolbar(this);

  return toolbar_;
}

CQIllustratorCreatePathSizer *
CQIllustratorCreatePathMode::
createSizer()
{
  sizer_ = new CQIllustratorCreatePathSizer(this);

  return sizer_;
}

CQMenuItem *
CQIllustratorCreatePathMode::
createMenuItem(CQMenu *menu)
{
  menuItem_ = new CQMenuItem(menu, "&Path", CQMenuItem::CHECKABLE);

  menuItem_->setStatusTip("Create Path");
  menuItem_->setXPMIcon(path_data);

  connect(menuItem_->getAction(), SIGNAL(toggled(bool)), this, SLOT(menuItemSlot()));

  return menuItem_;
}

void
CQIllustratorCreatePathMode::
handleMousePress(const MouseEvent &e)
{
  CQIllustratorMode::handleMousePress(e);

  if (! dragging_) {
    if (editMode_ == CREATE_MODE) {
      addPoint(e.window, e.pixel);
    }
  }
}

void
CQIllustratorCreatePathMode::
handleMouseRelease(const MouseEvent &e)
{
  CPoint2D p1 = CQUtil::fromQPoint(press_wpos_);
  CPoint2D p2 = CQUtil::fromQPoint(e.window);

  if (dragging_) {
    if (! moving_) {
      selectControlPoint(e);

      // TODO: use point selection signal for this
      CQIllustratorSelectedShapes *selection = illustrator_->getSelection();

      if (selection->size() == 1) {
        const CQIllustratorSelectedShape &sshape = selection->front();

        const CQIllustratorShape *shape = sshape.getShape();

        uint num_points = sshape.numPoints();

        for (uint i = 0; i < num_points; ++i) {
          const CQIllustratorShapeControlPoint *spoint = sshape.getPoint(i);

          CPoint2D p = spoint->getPoint(shape);

          toolbar_->setSelectionPoint(p);
        }
      }

      illustrator_->getSandbox()->clear();
    }
    // dragging finished so commit
    else {
      illustrator_->getSandbox()->commit(CQIllustratorData::CHANGE_GEOMETRY);
    }
  }
  // not dragging so do a select
  else {
    if (editMode_ == CREATE_MODE) {
    }
    else {
      // point click - select at point
      if (! moving_) {
        (void) illustrator_->selectAt(p2, e.event->isControlKey(), e.event->isShiftKey());
      }
      // drag - select points in rectangle
      else {
        CBBox2D bbox(p1, p2);

        if (selMode_ == POINT_SEL)
          illustrator_->selectPointsIn(bbox, CQIllustratorShape::CONTROL_GEOMETRY,
                                       e.event->isControlKey(), e.event->isShiftKey());
        else
          illustrator_->selectLinesIn(bbox, e.event->isControlKey(), e.event->isShiftKey());
      }
    }
  }

  dragging_ = false;

  illustrator_->redraw();
}

void
CQIllustratorCreatePathMode::
handleMouseDrag(const MouseEvent &e)
{
  if (dragging_) {
    CQIllustratorShape *shape = illustrator_->getSandbox()->frontShape();

    sizer_->updatePoint(shape, e.window);

    toolbar_->setSelectionPoint(CQUtil::fromQPoint(e.window));
  }
  else {
    if (editMode_ == CREATE_MODE) {
      //CPoint2D p1 = CQUtil::fromQPoint(press_wpos_);
      CPoint2D p2 = CQUtil::fromQPoint(e.window);

      uint num_points = pathPoints_.size();

      if (num_points <= 0) return;

      double dx = p2.x - pathPoints_[num_points - 1].p.x;
      double dy = p2.y - pathPoints_[num_points - 1].p.y;

      if (num_points > 0)
        pathPoints_[num_points - 1].c1 = CPoint2D(pathPoints_[num_points - 1].p.x + dx,
                                                  pathPoints_[num_points - 1].p.y + dy);

      if (num_points > 1)
        pathPoints_[num_points - 2].c2 = CPoint2D(pathPoints_[num_points - 1].p.x - dx,
                                                  pathPoints_[num_points - 1].p.y - dy);
    }
  }

  illustrator_->redrawOverlay();

  prev_wpos_ = e.window;
}

void
CQIllustratorCreatePathMode::
handleMouseMove(const MouseEvent &e)
{
  uint numCloseHandles = closeHandles_.size();

  for (uint i = 0; i < numCloseHandles; ++i)
    closeHandles_[i]->updateActive(e.pixel);

  uint numSnapHandles = snapHandles_.size();

  for (uint i = 0; i < numSnapHandles; ++i)
    snapHandles_[i]->updateActive(e.pixel);

  CQIllustratorMode::handleMouseMove(e);
}

bool
CQIllustratorCreatePathMode::
handleKeyPress(const KeyEvent &e)
{
  CKeyType key = e.event->getType();

  if (key == CKEY_TYPE_BackSpace) {
    if (! pathPoints_.empty()) {
      pathPoints_.pop_back();

      illustrator_->redrawOverlay();

      return true;
    }
  }
  else if (key == CKEY_TYPE_Space) {
    addPoint(e.window, e.pixel);

    return true;
  }

  return CQIllustratorMode::handleKeyPress(e);
}

void
CQIllustratorCreatePathMode::
addPoint(QPointF w, QPoint p)
{
  bool closed = false;

  uint numCloseHandles = closeHandles_.size();

  for (uint i = 0; i < numCloseHandles; ++i) {
    if (closeHandles_[i]->getVisible() && closeHandles_[i]->getActive())
      closed = true;
  }

  //----

  bool snapped = false;

  uint numSnapHandles = snapHandles_.size();

  for (uint i = 0; i < numSnapHandles; ++i) {
    if (snapHandles_[i]->getVisible() && snapHandles_[i]->getActive())
      snapped = true;
  }

  //----

  uint num_points = pathPoints_.size();

  if (num_points == 0)
    pathStart_ = p;

  CPoint2D p1 = CQUtil::fromQPoint(w);

  snapPoint(p1);

  if      (closed) {
    commitPathPoints(closed);
  }
  else if (snapped) {
    for (uint i = 0; i < numSnapHandles; ++i) {
      if (snapHandles_[i]->getVisible() && snapHandles_[i]->getActive()) {
        CPathPartType pathMode = getPathMode();

        pathPoints_.push_back(PathPoint(pathMode, snapHandles_[i]->getPosition()));
      }
    }
  }
  else {
    CPathPartType pathMode = getPathMode();

    pathPoints_.push_back(PathPoint(pathMode, p1));
  }
}

void
CQIllustratorCreatePathMode::
snapPoint(CPoint2D &p)
{
  uint numCloseHandles = closeHandles_.size();

  for (uint i = 0; i < numCloseHandles; ++i)
    closeHandles_[i]->setVisible(false);

  uint numSnapHandles = snapHandles_.size();

  for (uint i = 0; i < numSnapHandles; ++i)
    snapHandles_[i]->setVisible(false);

  uint num_points = pathPoints_.size();

  if (num_points == 0) return;

  if (num_points > 0) {
    const CPoint2D &p1 = pathPoints_[0].p;

    addCloseHandle(p, p1);
  }

  closeHandleNum_ = 0;
  snapHandleNum_  = 0;

  CQIllustratorCreatePathToolbar::CreateMode createMode = toolbar_->getCreateMode();

  if      (createMode == CQIllustratorCreatePathToolbar::CREATE_RECT_MODE) {
    if      (num_points > 1) {
      const CPoint2D &p1 = pathPoints_[num_points - 2].p;
      const CPoint2D &p2 = pathPoints_[num_points - 1].p;

      double dx = fabs(p2.x - p1.x);
      double dy = fabs(p2.y - p1.y);

      if      (dx > dy) { // last horizontal, next vertical
        p.x = p2.x;
      }
      else if (dy > dx) { // last vertical, next horizontal
        p.y = p2.y;
      }
    }
    else if (num_points > 0) {
      const CPoint2D &p1 = pathPoints_[num_points - 1].p;

      double dx = fabs(p.x - p1.x);
      double dy = fabs(p.y - p1.y);

      if      (dx > dy) { // snap horizontal
        p.y = p1.y;
      }
      else if (dy > dx) { // snap vertical
        p.x = p1.x;
      }
    }

    if (num_points > 1) {
      const CPoint2D &p1 = pathPoints_[num_points - 1].p;

      CLine2D l(p1, p);

      for (uint i = 0; i < num_points; ++i) {
        const CPoint2D &pp = pathPoints_[i].p;

        CLine2D l1(pp, pp + CPoint2D(1, 0)); // H
        CLine2D l2(pp, pp + CPoint2D(0, 1)); // V

        CPoint2D pi;

        if (CMathGeom2D::IntersectLine(l, l1, &pi, 0, 0)) addSnapHandle(p, pi);
        if (CMathGeom2D::IntersectLine(l, l2, &pi, 0, 0)) addSnapHandle(p, pi);
      }
    }
  }
  else if (createMode == CQIllustratorCreatePathToolbar::CREATE_45_MODE) {
    if (num_points > 0) {
      const CPoint2D &p1 = pathPoints_[num_points - 1].p;

      double dx = fabs(p.x - p1.x);
      double dy = fabs(p.y - p1.y);

      if      (fabs(dy - dx) < dx && fabs(dy - dx) < dy) { // 45
        double d = p.x - p1.x;

        p.x = p1.x + d;

        if (p.y > p1.y)
          p.y = p1.y + fabs(d);
        else
          p.y = p1.y - fabs(d);
      }
      else if (dx > dy) { // snap horizontal
        p.y = p1.y;
      }
      else if (dy > dx) { // snap vertical
        p.x = p1.x;
      }
    }

    if (num_points > 1) {
      const CPoint2D &p1 = pathPoints_[num_points - 1].p;

      CLine2D l(p1, p);

      for (uint i = 0; i < num_points; ++i) {
        const CPoint2D &pp = pathPoints_[i].p;

        CLine2D l1(pp, pp + CPoint2D(1,  0)); // H
        CLine2D l2(pp, pp + CPoint2D(0,  1)); // V
        CLine2D l3(pp, pp + CPoint2D(1,  1)); // 45 (up)
        CLine2D l4(pp, pp + CPoint2D(1, -1)); // 45 (down)

        CPoint2D pi;

        if (CMathGeom2D::IntersectLine(l, l1, &pi, 0, 0)) addSnapHandle(p, pi);
        if (CMathGeom2D::IntersectLine(l, l2, &pi, 0, 0)) addSnapHandle(p, pi);
        if (CMathGeom2D::IntersectLine(l, l3, &pi, 0, 0)) addSnapHandle(p, pi);
        if (CMathGeom2D::IntersectLine(l, l4, &pi, 0, 0)) addSnapHandle(p, pi);
      }
    }
  }
}

void
CQIllustratorCreatePathMode::
addCloseHandle(const CPoint2D &cp, const CPoint2D &p)
{
  while (closeHandleNum_ >= closeHandles_.size()) {
    CQIllustratorHandle *closeHandle = new CQIllustratorHandle(illustrator_);

    closeHandle->setImage(IMAGE_DATA(control_point_data), IMAGE_DATA(control_point_active_data));

    closeHandles_.push_back(closeHandle);

    closeHandle->setVisible(false);
  }

  QPointF pp1 = illustrator_->getTransform().map(CQUtil::toQPoint(cp));
  QPointF pp2 = illustrator_->getTransform().map(CQUtil::toQPoint(p ));

  double dx = fabs(pp1.x() - pp2.x());
  double dy = fabs(pp1.y() - pp2.y());

  if (dx*dx + dy*dy > 100) return;

  for (uint i = 0; i < closeHandles_.size(); ++i) {
    const CPoint2D &p1 = closeHandles_[i]->getPosition();

    QPointF pp3 = illustrator_->getTransform().map(CQUtil::toQPoint(p1));

    if (fabs(pp3.x() - p.x) < 1E-3 && fabs(pp3.y() - p.y) < 1E-3)
      return;
  }

  closeHandles_[closeHandleNum_]->setPosition(p);

  closeHandles_[closeHandleNum_]->setVisible(true);

  ++closeHandleNum_;
}

void
CQIllustratorCreatePathMode::
addSnapHandle(const CPoint2D &cp, const CPoint2D &p)
{
  while (snapHandleNum_ >= snapHandles_.size()) {
    CQIllustratorHandle *snapHandle = new CQIllustratorHandle(illustrator_);

    snapHandle->setImage(IMAGE_DATA(snap_point_data), IMAGE_DATA(snap_point_active_data));

    snapHandles_.push_back(snapHandle);

    snapHandle->setVisible(false);
  }

  QPointF pp1 = illustrator_->getTransform().map(CQUtil::toQPoint(cp));
  QPointF pp2 = illustrator_->getTransform().map(CQUtil::toQPoint(p ));

  double dx = fabs(pp1.x() - pp2.x());
  double dy = fabs(pp1.y() - pp2.y());

  if (dx*dx + dy*dy > 100) return;

  for (uint i = 0; i < closeHandles_.size(); ++i) {
    const CPoint2D &p1 = closeHandles_[i]->getPosition();

    QPointF pp3 = illustrator_->getTransform().map(CQUtil::toQPoint(p1));

    if (fabs(pp3.x() - p.x) < 1E-3 && fabs(pp3.y() - p.y) < 1E-3)
      return;
  }

  for (uint i = 0; i < snapHandles_.size(); ++i) {
    const CPoint2D &p1 = snapHandles_[i]->getPosition();

    QPointF pp3 = illustrator_->getTransform().map(CQUtil::toQPoint(p1));

    if (fabs(pp3.x() - p.x) < 1E-3 && fabs(pp3.y() - p.y) < 1E-3)
      return;
  }

  snapHandles_[snapHandleNum_]->setPosition(p);

  snapHandles_[snapHandleNum_]->setVisible(true);

  ++snapHandleNum_;
}

void
CQIllustratorCreatePathMode::
accept()
{
  commitPathPoints(false);
}

bool
CQIllustratorCreatePathMode::
cancel()
{
  pathPoints_.clear();

  illustrator_->redrawOverlay();

  return false;
}

void
CQIllustratorCreatePathMode::
drawOverlay(CQIllustratorShapeDrawer *drawer)
{
  QPainter *painter = drawer->getPainter();

  drawPathPoints(painter);

  //------

  if (! dragging_) {
    if (pressed_) {
      if (editMode_ == CREATE_MODE) {
      }
      else {
        // draw rubber band
        QPen pen;

        pen.setColor(QColor(0,0,0));
        pen.setStyle(Qt::DashLine);

        painter->setPen(pen);
        painter->setBrush(Qt::NoBrush);

        painter->drawRect(QRectF(press_wpos_, curr_wpos_));
      }
    }

    //------

    // draw handles for single selected shape
    CQIllustratorSelectedShapes *selection = illustrator_->getSelection();

    if (selection->size() == 1) {
      const CQIllustratorSelectedShape &sshape = selection->front();

      const CQIllustratorShape *shape = sshape.getShape();

      sizer_->draw(painter, shape);

      sizer_->drawSelectionHandles(painter, sshape);
    }
  }
  else {
    CQIllustratorShape *shape = illustrator_->getSandbox()->frontShape();

    sizer_->draw(painter, shape);
  }
}

void
CQIllustratorCreatePathMode::
drawPathPoints(QPainter *painter)
{
  uint num_points = pathPoints_.size();

  if (num_points == 0) return;

  // draw current path points
  QPen pen;

  pen.setColor(QColor(0,0,0));
  pen.setStyle(Qt::DashLine);

  painter->setPen(pen);
  painter->setBrush(Qt::NoBrush);

  QPainterPath path;

  const CPoint2D &ps = pathPoints_[0].p;

  path.moveTo(ps.x, ps.y);

  for (uint i = 1; i < num_points; ++i) {
    const PathPoint &p1 = pathPoints_[i - 1];
    const PathPoint &p2 = pathPoints_[i];

    if      (p1.type == CPATH_PART_TYPE_LINE_TO)
      path.lineTo(p2.p.x, p2.p.y);
    else if (p1.type == CPATH_PART_TYPE_CURVE2_TO) {
      path.quadTo(CQUtil::toQPoint(p1.c1), CQUtil::toQPoint(p2.p));

      painter->drawLine(CQUtil::toQPoint(p1.p ), CQUtil::toQPoint(p1.c1));
      painter->drawLine(CQUtil::toQPoint(p1.c1), CQUtil::toQPoint(p2.p ));
    }
    else if (p1.type == CPATH_PART_TYPE_CURVE3_TO) {
      path.cubicTo(CQUtil::toQPoint(p1.c1), CQUtil::toQPoint(p1.c2), CQUtil::toQPoint(p2.p));

      painter->drawLine(CQUtil::toQPoint(p1.p ), CQUtil::toQPoint(p1.c1));
      painter->drawLine(CQUtil::toQPoint(p1.c1), CQUtil::toQPoint(p1.c2));
      painter->drawLine(CQUtil::toQPoint(p1.c2), CQUtil::toQPoint(p2.p ));
    }
  }

  const PathPoint &p1 = pathPoints_[num_points - 1];

  CPoint2D pc = CQUtil::fromQPoint(curr_wpos_);

  snapPoint(pc);

  PathPoint p2(getPathMode(), pc);

  if (! pressed_) {
    if      (p1.type == CPATH_PART_TYPE_LINE_TO)
      path.lineTo(p2.p.x, p2.p.y);
    else if (p1.type == CPATH_PART_TYPE_CURVE2_TO) {
      path.quadTo(CQUtil::toQPoint(p1.c1), CQUtil::toQPoint(p2.p));

      painter->drawLine(CQUtil::toQPoint(p1.p ), CQUtil::toQPoint(p1.c1));
      painter->drawLine(CQUtil::toQPoint(p1.c1), CQUtil::toQPoint(p2.p ));
    }
    else if (p1.type == CPATH_PART_TYPE_CURVE3_TO) {
      path.cubicTo(CQUtil::toQPoint(p1.c1), CQUtil::toQPoint(p1.c2), CQUtil::toQPoint(p2.p));

      painter->drawLine(CQUtil::toQPoint(p1.p ), CQUtil::toQPoint(p1.c1));
      painter->drawLine(CQUtil::toQPoint(p1.c1), CQUtil::toQPoint(p1.c2));
      painter->drawLine(CQUtil::toQPoint(p1.c2), CQUtil::toQPoint(p2.p ));
    }
  }

  painter->strokePath(path, QPen(QColor(255,0,0)));

  if (pressed_) {
    double dx = p2.p.x - p1.p.x;
    double dy = p2.p.y - p1.p.y;

    if      (getPathMode() == CPATH_PART_TYPE_CURVE2_TO) {
      painter->drawLine(CQUtil::toQPoint(p1.p - CPoint2D(dx, dy)),
                        CQUtil::toQPoint(p1.p + CPoint2D(dx, dy)));
    }
    else if (getPathMode() == CPATH_PART_TYPE_CURVE3_TO) {
      painter->drawLine(CQUtil::toQPoint(p1.p - CPoint2D(dx, dy)),
                        CQUtil::toQPoint(p1.p + CPoint2D(dx, dy)));
    }
  }

  //-----

  // draw close points
  uint numCloseHandles = closeHandles_.size();

  for (uint i = 0; i < numCloseHandles; ++i) {
    if (closeHandles_[i]->getVisible())
      closeHandles_[i]->draw(painter);
  }

  //-----

  // draw snap points
  uint numSnapHandles = snapHandles_.size();

  for (uint i = 0; i < numSnapHandles; ++i) {
    if (snapHandles_[i]->getVisible())
      snapHandles_[i]->draw(painter);
  }
}

QCursor
CQIllustratorCreatePathMode::
getCursor() const
{
  return Qt::ArrowCursor;
}

void
CQIllustratorCreatePathMode::
commitPathPoints(bool closed)
{
  uint num_points = pathPoints_.size();

  if (num_points == 0) return;

  CPathShape *path = illustrator_->createPathShape();

  CQIllustratorShapeFill fill;

  fill.setOpacity(0.0);

  path->setFill(fill);

  const PathPoint &ps = pathPoints_[0];

  path->addMoveTo(CPoint2D(ps.p.x, ps.p.y));

  for (uint i = 1; i < num_points; ++i) {
    const PathPoint &p1 = pathPoints_[i - 1];
    const PathPoint &p2 = pathPoints_[i];

    if      (pathPoints_[i].type == CPATH_PART_TYPE_LINE_TO)
      path->addLineTo (CPoint2D(p2.p .x, p2.p .y));
    else if (pathPoints_[i].type == CPATH_PART_TYPE_CURVE2_TO)
      path->addCurveTo(CPoint2D(p1.c1.x, p1.c1.y), CPoint2D(p2.p .x, p2.p .y));
    else if (pathPoints_[i].type == CPATH_PART_TYPE_CURVE3_TO)
      path->addCurveTo(CPoint2D(p1.c1.x, p1.c1.y), CPoint2D(p1.c2.x, p1.c2.y),
                       CPoint2D(p2.p .x, p2.p .y));
  }

  if (closed)
    path->addClose();

  illustrator_->addShape(path);

  illustrator_->setSelectShape(path);

  pathPoints_.clear();

  illustrator_->redraw();
}

void
CQIllustratorCreatePathMode::
setCurrentToCornerNode()
{
  CQIllustratorSelectedShapes *selection = illustrator_->getSelection();

  if (selection->size() != 1) return;

  const CQIllustratorSelectedShape &sshape = selection->front();

  uint num = sshape.numPoints();

  if (num == 0) return;

  illustrator_->getSandbox()->addSelection();

  CQIllustratorShape *shape = illustrator_->getSandbox()->frontShape();

  for (uint i = 0; i < num; ++i) {
    const CPathShapeControlPoint *controlPoint =
      dynamic_cast<const CPathShapeControlPoint *>(sshape.getPoint(i));

    controlPoint->setCornerNode(shape);
  }

  illustrator_->getSandbox()->commit(CQIllustratorData::CHANGE_GEOMETRY);
}

void
CQIllustratorCreatePathMode::
setCurrentToCurveNode()
{
  CQIllustratorSelectedShapes *selection = illustrator_->getSelection();

  if (selection->size() != 1) return;

  const CQIllustratorSelectedShape &sshape = selection->front();

  uint num = sshape.numPoints();

  if (num == 0) return;

  illustrator_->getSandbox()->addSelection();

  CQIllustratorShape *shape = illustrator_->getSandbox()->frontShape();

  for (uint i = 0; i < num; ++i) {
    const CPathShapeControlPoint *controlPoint =
      dynamic_cast<const CPathShapeControlPoint *>(sshape.getPoint(i));

    controlPoint->setCurveNode(shape);
  }

  illustrator_->getSandbox()->commit(CQIllustratorData::CHANGE_GEOMETRY);
}

void
CQIllustratorCreatePathMode::
addNodeToCurrent()
{
  CQIllustratorSelectedShapes *selection = illustrator_->getSelection();

  if (selection->size() != 1) return;

  const CQIllustratorSelectedShape &sshape = selection->front();

  uint num = sshape.numPoints();

  if (num != 2) return;

  illustrator_->getSandbox()->addSelection();

  CQIllustratorShape *shape = illustrator_->getSandbox()->frontShape();

  const CPathShapeControlPoint *controlPoint1 =
    dynamic_cast<const CPathShapeControlPoint *>(sshape.getPoint(0));
  const CPathShapeControlPoint *controlPoint2 =
    dynamic_cast<const CPathShapeControlPoint *>(sshape.getPoint(1));

  CPoint2D p1 = controlPoint1->getPoint(shape);
  CPoint2D p2 = controlPoint2->getPoint(shape);

  CPathShape *path = dynamic_cast<CPathShape *>(shape);

  int ind = std::min(controlPoint1->getInd(), controlPoint2->getInd());

  path->addLineTo(ind + 1, (p1 + p2)/2);

  illustrator_->getSandbox()->commit(CQIllustratorData::CHANGE_GEOMETRY);
}

void
CQIllustratorCreatePathMode::
removeNodeFromCurrent()
{
}

//------------

CQIllustratorCreatePathToolbar::
CQIllustratorCreatePathToolbar(CQIllustratorCreatePathMode *mode) :
 CQIllustratorToolbar(mode), mode_(mode), createMode_(CREATE_FREE_MODE)
{
}

QIcon
CQIllustratorCreatePathToolbar::
getIcon()
{
  return QIcon(QPixmap(path_data));
}

void
CQIllustratorCreatePathToolbar::
addWidgets()
{
  QBoxLayout *layout = qobject_cast<QBoxLayout *>(CQIllustratorToolbar::layout());

  //-----

#if 0
  QWidget *modeFrame = new QWidget;

  QVBoxLayout *modeLayout = new QVBoxLayout(modeFrame);

  createRadio_ = new QRadioButton("Create");
  editRadio_   = new QRadioButton("Edit");

  createRadio_->setChecked(true);

  createRadio_->setFocusPolicy(Qt::NoFocus);
  editRadio_  ->setFocusPolicy(Qt::NoFocus);

  modeLayout->addWidget(createRadio_);
  modeLayout->addWidget(editRadio_);

  connect(createRadio_, SIGNAL(toggled(bool)), this, SLOT(modeChangedSlot()));

  CQSwatch *modeSwatch = new CQSwatch(modeFrame);

  layout->addWidget(modeSwatch);
#endif

  //-----

  pathFreeButton_ = new CQImageButton(QPixmap(path_free_data));
  pathRectButton_ = new CQImageButton(QPixmap(path_rect_data));
  path45Button_   = new CQImageButton(QPixmap(path_45_data));

  connect(pathFreeButton_, SIGNAL(toggled(bool)), this, SLOT(pathFreeSlot(bool)));
  connect(pathRectButton_, SIGNAL(toggled(bool)), this, SLOT(pathRectSlot(bool)));
  connect(path45Button_  , SIGNAL(toggled(bool)), this, SLOT(path45Slot(bool)));

  pathFreeButton_->setCheckable(true);
  pathRectButton_->setCheckable(true);
  path45Button_  ->setCheckable(true);

  pathFreeButton_->setChecked(true);

  CQSwatch *createModeSwatch =
    new CQSwatch("Mode", pathFreeButton_, pathRectButton_, path45Button_);

  layout->addWidget(createModeSwatch);

  //-----

  QWidget *selFrame = new QWidget;

  QVBoxLayout *selLayout = new QVBoxLayout(selFrame);

  pointRadio_ = new QRadioButton("Point");
  lineRadio_  = new QRadioButton("Line");

  pointRadio_->setChecked(true);

  pointRadio_->setFocusPolicy(Qt::NoFocus);
  lineRadio_ ->setFocusPolicy(Qt::NoFocus);

  selLayout->addWidget(pointRadio_);
  selLayout->addWidget(lineRadio_);

  connect(pointRadio_, SIGNAL(toggled(bool)), this, SLOT(selChangedSlot()));

  CQSwatch *selSwatch = new CQSwatch(selFrame);

  layout->addWidget(selSwatch);

  //-----

  pathLineButton_   = new CQImageButton(QPixmap(path_line_data  ));
  pathCurve2Button_ = new CQImageButton(QPixmap(path_curve2_data));
  pathCurve3Button_ = new CQImageButton(QPixmap(path_curve3_data));

  pathLineButton_  ->setCheckable(true);
  pathCurve2Button_->setCheckable(true);
  pathCurve3Button_->setCheckable(true);

  pathLineButton_  ->setToolTip("Straight Line");
  pathCurve2Button_->setToolTip("Quadratic Curve");
  pathCurve3Button_->setToolTip("Bezier Curve");

  connect(pathLineButton_  , SIGNAL(toggled(bool)), this, SLOT(lineModeSlot  (bool)));
  connect(pathCurve2Button_, SIGNAL(toggled(bool)), this, SLOT(curve2ModeSlot(bool)));
  connect(pathCurve3Button_, SIGNAL(toggled(bool)), this, SLOT(curve3ModeSlot(bool)));

  CPathPartType pathMode = mode_->getPathMode();

  pathLineButton_  ->setChecked(pathMode == CPATH_PART_TYPE_LINE_TO);
  pathCurve2Button_->setChecked(pathMode == CPATH_PART_TYPE_CURVE2_TO);
  pathCurve3Button_->setChecked(pathMode == CPATH_PART_TYPE_CURVE3_TO);

  CQSwatch *createSwatch =
    new CQSwatch("Line Type<2>", pathLineButton_, pathCurve2Button_, pathCurve3Button_);

  layout->addWidget(createSwatch);

  //-----

  nodeCornerButton_ = new CQImageButton(QPixmap(path_corner_data));
  nodeCurveButton_  = new CQImageButton(QPixmap(path_curve_data ));

  nodeCornerButton_->setToolTip("Point Node");
  nodeCurveButton_ ->setToolTip("Curve Node");

  connect(nodeCornerButton_, SIGNAL(clicked()), this, SLOT(cornerNodeSlot()));
  connect(nodeCurveButton_ , SIGNAL(clicked()), this, SLOT(curveNodeSlot ()));

  CQSwatch *nodeSwatch = new CQSwatch("Point Type<2>", nodeCornerButton_, nodeCurveButton_);

  layout->addWidget(nodeSwatch);

  //-----

  addNodeButton_    = new CQImageButton(QPixmap(path_add_data   ));
  removeNodeButton_ = new CQImageButton(QPixmap(path_remove_data));

  addNodeButton_   ->setToolTip("Add Node");
  removeNodeButton_->setToolTip("Remove Node");

  connect(addNodeButton_   , SIGNAL(clicked()), this, SLOT(addNodeSlot   ()));
  connect(removeNodeButton_, SIGNAL(clicked()), this, SLOT(removeNodeSlot()));

  CQSwatch *modifySwatch = new CQSwatch("Modify<2>", addNodeButton_, removeNodeButton_);

  layout->addWidget(modifySwatch);

  //-----

  pointEdit_ = new CQPointEdit;

  pointEdit_->setEnabled(false);

  connect(pointEdit_, SIGNAL(valueChanged()), this, SLOT(updateNodeSlot()));

  CQSwatch *pointSwatch = new CQSwatch("Position", pointEdit_);

  layout->addWidget(pointSwatch);
}

void
CQIllustratorCreatePathToolbar::
modeChangedSlot()
{
  if (createRadio_->isChecked())
    mode_->setEditMode(CQIllustratorMode::CREATE_MODE);
  else
    mode_->setEditMode(CQIllustratorMode::EDIT_MODE);

  updateMode();
}

void
CQIllustratorCreatePathToolbar::
pathFreeSlot(bool state)
{
  if (state) {
    createMode_ = CREATE_FREE_MODE;

    pathRectButton_->setChecked(false);
    path45Button_  ->setChecked(false);
  }
}

void
CQIllustratorCreatePathToolbar::
pathRectSlot(bool state)
{
  if (state) {
    createMode_ = CREATE_RECT_MODE;

    pathFreeButton_->setChecked(false);
    path45Button_  ->setChecked(false);
  }
}

void
CQIllustratorCreatePathToolbar::
path45Slot(bool state)
{
  if (state) {
    createMode_ = CREATE_45_MODE;

    pathRectButton_->setChecked(false);
    pathFreeButton_->setChecked(false);
  }
}

void
CQIllustratorCreatePathToolbar::
selChangedSlot()
{
  if (pointRadio_->isChecked())
    mode_->setSelMode(CQIllustratorCreatePathMode::POINT_SEL);
  else
    mode_->setSelMode(CQIllustratorCreatePathMode::LINE_SEL);

  updateMode();
}

void
CQIllustratorCreatePathToolbar::
lineModeSlot(bool state)
{
  setPathMode(CPATH_PART_TYPE_LINE_TO, state);
}

void
CQIllustratorCreatePathToolbar::
curve2ModeSlot(bool state)
{
  setPathMode(CPATH_PART_TYPE_CURVE2_TO, state);
}

void
CQIllustratorCreatePathToolbar::
curve3ModeSlot(bool state)
{
  setPathMode(CPATH_PART_TYPE_CURVE3_TO, state);
}

void
CQIllustratorCreatePathToolbar::
cornerNodeSlot()
{
  mode_->setCurrentToCornerNode();
}

void
CQIllustratorCreatePathToolbar::
curveNodeSlot()
{
  mode_->setCurrentToCurveNode();
}

void
CQIllustratorCreatePathToolbar::
addNodeSlot()
{
  mode_->addNodeToCurrent();
}

void
CQIllustratorCreatePathToolbar::
removeNodeSlot()
{
  mode_->removeNodeFromCurrent();
}

void
CQIllustratorCreatePathToolbar::
updateNodeSlot()
{
  CPoint2D p = pointEdit_->getValue();

  CQIllustrator *illustrator = mode_->getIllustrator();

  CQIllustratorSelectedShapes *selection = illustrator->getSelection();

  if (selection->size() != 1) return;

  const CQIllustratorSelectedShape &sshape = selection->front();

  uint num = sshape.numPoints();

  if (num != 1) return;

  CQIllustratorSelectedShape &sshape1 =
    selection->checkoutShape(sshape, mode_->getChangeType());

  CQIllustratorShapeControlPoint *point = sshape1.getPoint(0);

  point->setPoint(sshape1.getShape(), p);

  selection->checkinShape(sshape, mode_->getChangeType());
}

void
CQIllustratorCreatePathToolbar::
setPathMode(CPathPartType pathMode, bool state)
{
  if (mode_->getEditMode() == CQIllustratorMode::CREATE_MODE) {
    if (state)
      mode_->setPathMode(pathMode);
  }
  else {
    if (state) {
      CQIllustratorCreatePathMode::SelMode selMode = mode_->getSelMode();

      if (selMode == CQIllustratorCreatePathMode::LINE_SEL) {
        CQIllustrator *illustrator = mode_->getIllustrator();

        CQIllustratorSelectedShapes *selection = illustrator->getSelection();

        if (selection->size() == 1) {
          const CQIllustratorSelectedShape &sshape = selection->front();

          uint num_lines = sshape.numLines();

          if (num_lines == 1) {
            CQIllustratorSelectedShape &sshape1 =
              selection->checkoutShape(sshape, mode_->getChangeType());

            CQIllustratorShapeControlLine *line = sshape1.getLine(0);

            line->setType(sshape1.getShape(), pathMode);

            selection->checkinShape(sshape, mode_->getChangeType());
          }
        }
      }
    }
  }

  updateMode();
}

void
CQIllustratorCreatePathToolbar::
updateMode()
{
  if (mode_->getEditMode() == CQIllustratorMode::CREATE_MODE) {
    CPathPartType pathMode = mode_->getPathMode();

    pathLineButton_  ->setChecked(pathMode == CPATH_PART_TYPE_LINE_TO);
    pathCurve2Button_->setChecked(pathMode == CPATH_PART_TYPE_CURVE2_TO);
    pathCurve3Button_->setChecked(pathMode == CPATH_PART_TYPE_CURVE3_TO);
  }
  else {
    pathLineButton_  ->setChecked(false);
    pathCurve2Button_->setChecked(false);
    pathCurve3Button_->setChecked(false);
  }
}

void
CQIllustratorCreatePathToolbar::
setSelectedShape(const CQIllustratorShape *shape)
{
  const CPathShape *path =
    dynamic_cast<const CPathShape *>(shape);

  if (! path) return;
}

void
CQIllustratorCreatePathToolbar::
setSelectedShapePoint(const CQIllustratorShape *shape,
                      const CQIllustratorShapeControlPoint *point)
{
  const CPathShape *path =
    dynamic_cast<const CPathShape *>(shape);

  if (! path) return;

  if (point)
    pointEdit_->setValue(point->getPoint(shape));
  else
    pointEdit_->setValue(CPoint2D(0,0));

  pointEdit_->setEnabled(point != 0);
}

void
CQIllustratorCreatePathToolbar::
updateShape()
{
  CQIllustrator *illustrator = mode_->getIllustrator();

  CPathShape *shape =
    CQIllustratorUtil::getCurrentShape<CPathShape>(illustrator);

  CPathShape *path = 0;

  if (shape)
    path = dynamic_cast<CPathShape *>(shape);

  if (path) {
    //illustrator->checkoutShape(shape);

    //illustrator->checkinShape(shape);
  }

  illustrator->redraw();
}

void
CQIllustratorCreatePathToolbar::
setSelectionPoint(const CPoint2D &p)
{
  pointEdit_->setValue(p);
}

//------

CQIllustratorCreatePathSizer::
CQIllustratorCreatePathSizer(CQIllustratorCreatePathMode *mode) :
 CQIllustratorModeSizer(mode)
{
}

void
CQIllustratorCreatePathSizer::
drawHandles(QPainter *painter, const CQIllustratorShape *shape)
{
  const CPathShape *path =
    dynamic_cast<const CPathShape *>(shape);

  if (path) {
    CQIllustratorShape::ControlPointList controlPoints;

    path->getControlPoints(controlPoints);

    uint numControlPoints = controlPoints.size();

    updateHandles(numControlPoints);

    for (uint i = 0; i < numControlPoints; ++i) {
      CPathShapeControlPoint *controlPoint =
        dynamic_cast<CPathShapeControlPoint *>(controlPoints[i]);

      if (controlPoint->isMaster())
        controlPointHandles_[i]->setStyle(CQIllustratorHandle::CIRCLE_STYLE);
      else
        controlPointHandles_[i]->setStyle(CQIllustratorHandle::RECT_STYLE);

      controlPointHandles_[i]->draw(path, controlPoint, painter);
    }
  }
}

void
CQIllustratorCreatePathSizer::
updateHandles(uint numHandles)
{
  CQIllustrator *illustrator = mode_->getIllustrator();

  while (controlPointHandles_.size() < numHandles) {
    CQIllustratorControlPointHandle *handle = new CQIllustratorControlPointHandle(illustrator);

    addHandle(handle);
  }

  while (controlPointHandles_.size() > numHandles) {
    CQIllustratorControlPointHandle *handle = 0;

    removeHandle(handle);
  }
}
##concat##CQIllustratorCreatePolygonMode.cpp
#include <CQIllustratorCreatePolygonMode.h>
#include <CQIllustrator.h>
#include <CQIllustratorHandle.h>
#include <CQIllustratorShapeDrawer.h>

#include <QPainter>
#include <QHBoxLayout>
#include <QRadioButton>

#include <CQMenu.h>
#include <CQUtil.h>
#include <CQPointEdit.h>
#include <CQImageButton.h>
#include <CQSwatch.h>

#include <xpm/polygon.xpm>
#include <xpm/path_add.xpm>
#include <xpm/path_remove.xpm>

#include <xpm/poly_free.xpm>
#include <xpm/poly_rect.xpm>
#include <xpm/poly_45.xpm>

#include <xpm/control_point.xpm>
#include <xpm/control_point_active.xpm>

#include <xpm/snap_point.xpm>
#include <xpm/snap_point_active.xpm>

#include <cursors/select.xbm>
#include <cursors/selectmask.xbm>

#define IMAGE_DATA(I) I, sizeof(I)/sizeof(char *)

CQIllustratorCreatePolygonMode::
CQIllustratorCreatePolygonMode(CQIllustrator *illustrator) :
 CQIllustratorMode(illustrator, CQIllustrator::MODE_POLYGON)
{
  setCursor(select_bits, selectmask_bits, 2, 2);
}

CQIllustratorCreatePolygonToolbar *
CQIllustratorCreatePolygonMode::
createToolbar()
{
  toolbar_ = new CQIllustratorCreatePolygonToolbar(this);

  return toolbar_;
}

CQIllustratorCreatePolygonSizer *
CQIllustratorCreatePolygonMode::
createSizer()
{
  sizer_ = new CQIllustratorCreatePolygonSizer(this);

  return sizer_;
}

CQMenuItem *
CQIllustratorCreatePolygonMode::
createMenuItem(CQMenu *menu)
{
  menuItem_ = new CQMenuItem(menu, "&Polygon", CQMenuItem::CHECKABLE);

  menuItem_->setStatusTip("Create Polygon");
  menuItem_->setXPMIcon(polygon_data);

  connect(menuItem_->getAction(), SIGNAL(toggled(bool)), this, SLOT(menuItemSlot()));

  return menuItem_;
}

void
CQIllustratorCreatePolygonMode::
handleMousePress(const MouseEvent &e)
{
  CQIllustratorMode::handleMousePress(e);

  if (! dragging_) {
    if (editMode_ == CREATE_MODE) {
      addPoint(e.window, e.pixel);
    }
  }
}

void
CQIllustratorCreatePolygonMode::
handleMouseRelease(const MouseEvent &e)
{
  CPoint2D p1 = CQUtil::fromQPoint(press_wpos_);
  CPoint2D p2 = CQUtil::fromQPoint(e.window);

  if (dragging_) {
    if (! moving_) {
      selectControlPoint(e);
    }
    // dragging finished so commit
    else {
      illustrator_->getSandbox()->commit(CQIllustratorData::CHANGE_GEOMETRY);
    }
  }
  // not dragging so do a select
  else {
    if (editMode_ == CREATE_MODE) {
    }
    else {
      // point click - select at point
      if (! moving_) {
        (void) illustrator_->selectAt(p2, e.event->isControlKey(), e.event->isShiftKey());
      }
      // drag - select points in rectangle
      else {
        CBBox2D bbox(p1, p2);

        illustrator_->selectPointsIn(bbox, CQIllustratorShape::CONTROL_GEOMETRY,
                                     e.event->isControlKey(), e.event->isShiftKey());
      }
    }
  }

  dragging_ = false;

  illustrator_->redraw();
}

void
CQIllustratorCreatePolygonMode::
handleMouseDrag(const MouseEvent &e)
{
  if (dragging_) {
    CQIllustratorShape *shape = illustrator_->getSandbox()->frontShape();

    if (shape)
      sizer_->updatePoint(shape, e.window);

    toolbar_->setSelectionPoint(CQUtil::fromQPoint(e.window));
  }
  else {
    if (editMode_ == CREATE_MODE) {
    }
    else {
    }
  }

  illustrator_->redrawOverlay();

  prev_wpos_ = e.window;
}

void
CQIllustratorCreatePolygonMode::
handleMouseMove(const MouseEvent &e)
{
  uint numCloseHandles = closeHandles_.size();

  for (uint i = 0; i < numCloseHandles; ++i)
    closeHandles_[i]->updateActive(e.pixel);

  uint numSnapHandles = snapHandles_.size();

  for (uint i = 0; i < numSnapHandles; ++i)
    snapHandles_[i]->updateActive(e.pixel);

  CQIllustratorMode::handleMouseMove(e);
}

bool
CQIllustratorCreatePolygonMode::
handleKeyPress(const KeyEvent &e)
{
  CKeyType key = e.event->getType();

  if      (key == CKEY_TYPE_BackSpace) {
    if (! polygonPoints_.empty()) {
      polygonPoints_.pop_back();

      illustrator_->redrawOverlay();

      return true;
    }
  }
  else if (key == CKEY_TYPE_Space) {
    addPoint(e.window, e.pixel);

    return true;
  }

  return CQIllustratorMode::handleKeyPress(e);
}

void
CQIllustratorCreatePolygonMode::
addPoint(QPointF w, QPoint p)
{
  bool closed = false;

  uint numCloseHandles = closeHandles_.size();

  for (uint i = 0; i < numCloseHandles; ++i) {
    if (closeHandles_[i]->getVisible() && closeHandles_[i]->getActive())
      closed = true;
  }

  //----

  bool snapped = false;

  uint numSnapHandles = snapHandles_.size();

  for (uint i = 0; i < numSnapHandles; ++i) {
    if (snapHandles_[i]->getVisible() && snapHandles_[i]->getActive())
      snapped = true;
  }

  //----

  uint num_points = polygonPoints_.size();

  if (num_points == 0)
    polygonStart_ = p;

  CPoint2D p1 = CQUtil::fromQPoint(w);

  snapPoint(p1);

  if      (closed)
    commitPolygonPoints();
  else if (snapped) {
    for (uint i = 0; i < numSnapHandles; ++i) {
      if (snapHandles_[i]->getVisible() && snapHandles_[i]->getActive())
        polygonPoints_.push_back(snapHandles_[i]->getPosition());
    }
  }
  else
    polygonPoints_.push_back(p1);
}

void
CQIllustratorCreatePolygonMode::
snapPoint(CPoint2D &p)
{
  uint numCloseHandles = closeHandles_.size();

  for (uint i = 0; i < numCloseHandles; ++i)
    closeHandles_[i]->setVisible(false);

  uint numSnapHandles = snapHandles_.size();

  for (uint i = 0; i < numSnapHandles; ++i)
    snapHandles_[i]->setVisible(false);

  uint num_points = polygonPoints_.size();

  if (num_points == 0) return;

  if (num_points > 0) {
    const CPoint2D &p1 = polygonPoints_[0];

    addCloseHandle(p, p1);
  }

  closeHandleNum_ = 0;
  snapHandleNum_  = 0;

  CQIllustratorCreatePolygonToolbar::CreateMode createMode = toolbar_->getCreateMode();

  if      (createMode == CQIllustratorCreatePolygonToolbar::CREATE_RECT_MODE) {
    if      (num_points > 1) {
      const CPoint2D &p1 = polygonPoints_[num_points - 2];
      const CPoint2D &p2 = polygonPoints_[num_points - 1];

      double dx = fabs(p2.x - p1.x);
      double dy = fabs(p2.y - p1.y);

      if      (dx > dy) { // last horizontal, next vertical
        p.x = p2.x;
      }
      else if (dy > dx) { // last vertical, next horizontal
        p.y = p2.y;
      }
    }
    else if (num_points > 0) {
      const CPoint2D &p1 = polygonPoints_[num_points - 1];

      double dx = fabs(p.x - p1.x);
      double dy = fabs(p.y - p1.y);

      if      (dx > dy) { // snap horizontal
        p.y = p1.y;
      }
      else if (dy > dx) { // snap vertical
        p.x = p1.x;
      }
    }

    if (num_points > 1) {
      const CPoint2D &p1 = polygonPoints_[num_points - 1];

      CLine2D l(p1, p);

      for (uint i = 0; i < num_points; ++i) {
        const CPoint2D &pp = polygonPoints_[i];

        CLine2D l1(pp, pp + CPoint2D(1, 0)); // H
        CLine2D l2(pp, pp + CPoint2D(0, 1)); // V

        CPoint2D pi;

        if (CMathGeom2D::IntersectLine(l, l1, &pi, 0, 0)) addSnapHandle(p, pi);
        if (CMathGeom2D::IntersectLine(l, l2, &pi, 0, 0)) addSnapHandle(p, pi);
      }
    }
  }
  else if (createMode == CQIllustratorCreatePolygonToolbar::CREATE_45_MODE) {
    if (num_points > 0) {
      const CPoint2D &p1 = polygonPoints_[num_points - 1];

      double dx = fabs(p.x - p1.x);
      double dy = fabs(p.y - p1.y);

      if      (fabs(dy - dx) < dx && fabs(dy - dx) < dy) { // 45
        double d = p.x - p1.x;

        p.x = p1.x + d;

        if (p.y > p1.y)
          p.y = p1.y + fabs(d);
        else
          p.y = p1.y - fabs(d);
      }
      else if (dx > dy) { // snap horizontal
        p.y = p1.y;
      }
      else if (dy > dx) { // snap vertical
        p.x = p1.x;
      }
    }

    if (num_points > 1) {
      const CPoint2D &p1 = polygonPoints_[num_points - 1];

      CLine2D l(p1, p);

      for (uint i = 0; i < num_points; ++i) {
        const CPoint2D &pp = polygonPoints_[i];

        CLine2D l1(pp, pp + CPoint2D(1,  0)); // H
        CLine2D l2(pp, pp + CPoint2D(0,  1)); // V
        CLine2D l3(pp, pp + CPoint2D(1,  1)); // 45 (up)
        CLine2D l4(pp, pp + CPoint2D(1, -1)); // 45 (down)

        CPoint2D pi;

        if (CMathGeom2D::IntersectLine(l, l1, &pi, 0, 0)) addSnapHandle(p, pi);
        if (CMathGeom2D::IntersectLine(l, l2, &pi, 0, 0)) addSnapHandle(p, pi);
        if (CMathGeom2D::IntersectLine(l, l3, &pi, 0, 0)) addSnapHandle(p, pi);
        if (CMathGeom2D::IntersectLine(l, l4, &pi, 0, 0)) addSnapHandle(p, pi);
      }
    }
  }
}

void
CQIllustratorCreatePolygonMode::
addCloseHandle(const CPoint2D &cp, const CPoint2D &p)
{
  while (closeHandleNum_ >= closeHandles_.size()) {
    CQIllustratorHandle *closeHandle = new CQIllustratorHandle(illustrator_);

    closeHandle->setImage(IMAGE_DATA(control_point_data), IMAGE_DATA(control_point_active_data));

    closeHandles_.push_back(closeHandle);

    closeHandle->setVisible(false);
  }

  QPointF pp1 = illustrator_->getTransform().map(CQUtil::toQPoint(cp));
  QPointF pp2 = illustrator_->getTransform().map(CQUtil::toQPoint(p ));

  double dx = fabs(pp1.x() - pp2.x());
  double dy = fabs(pp1.y() - pp2.y());

  if (dx*dx + dy*dy > 100) return;

  for (uint i = 0; i < closeHandles_.size(); ++i) {
    const CPoint2D &p1 = closeHandles_[i]->getPosition();

    QPointF pp3 = illustrator_->getTransform().map(CQUtil::toQPoint(p1));

    if (fabs(pp3.x() - p.x) < 1E-3 && fabs(pp3.y() - p.y) < 1E-3)
      return;
  }

  closeHandles_[closeHandleNum_]->setPosition(p);

  closeHandles_[closeHandleNum_]->setVisible(true);

  ++closeHandleNum_;
}

void
CQIllustratorCreatePolygonMode::
addSnapHandle(const CPoint2D &cp, const CPoint2D &p)
{
  while (snapHandleNum_ >= snapHandles_.size()) {
    CQIllustratorHandle *snapHandle = new CQIllustratorHandle(illustrator_);

    snapHandle->setImage(IMAGE_DATA(snap_point_data), IMAGE_DATA(snap_point_active_data));

    snapHandles_.push_back(snapHandle);

    snapHandle->setVisible(false);
  }

  QPointF pp1 = illustrator_->getTransform().map(CQUtil::toQPoint(cp));
  QPointF pp2 = illustrator_->getTransform().map(CQUtil::toQPoint(p ));

  double dx = fabs(pp1.x() - pp2.x());
  double dy = fabs(pp1.y() - pp2.y());

  if (dx*dx + dy*dy > 100) return;

  for (uint i = 0; i < closeHandles_.size(); ++i) {
    const CPoint2D &p1 = closeHandles_[i]->getPosition();

    QPointF pp3 = illustrator_->getTransform().map(CQUtil::toQPoint(p1));

    if (fabs(pp3.x() - p.x) < 1E-3 && fabs(pp3.y() - p.y) < 1E-3)
      return;
  }

  for (uint i = 0; i < snapHandles_.size(); ++i) {
    const CPoint2D &p1 = snapHandles_[i]->getPosition();

    QPointF pp3 = illustrator_->getTransform().map(CQUtil::toQPoint(p1));

    if (fabs(pp3.x() - p.x) < 1E-3 && fabs(pp3.y() - p.y) < 1E-3)
      return;
  }

  snapHandles_[snapHandleNum_]->setPosition(p);

  snapHandles_[snapHandleNum_]->setVisible(true);

  ++snapHandleNum_;
}

void
CQIllustratorCreatePolygonMode::
accept()
{
  commitPolygonPoints();
}

bool
CQIllustratorCreatePolygonMode::
cancel()
{
  polygonPoints_.clear();

  illustrator_->redrawOverlay();

  return false;
}

void
CQIllustratorCreatePolygonMode::
drawOverlay(CQIllustratorShapeDrawer *drawer)
{
  QPainter *painter = drawer->getPainter();

  drawPolygonPoints(painter);

  //------

  if (! dragging_) {
    if (pressed_) {
      if (editMode_ == CREATE_MODE) {
      }
      else {
        // draw rubber band
        QPen pen;

        pen.setColor(QColor(0,0,0));
        pen.setStyle(Qt::DashLine);

        painter->setPen(pen);
        painter->setBrush(Qt::NoBrush);

        painter->drawRect(QRectF(press_wpos_, curr_wpos_));
      }
    }

    //------

    // draw handles for single selected shape
    CQIllustratorSelectedShapes *selection = illustrator_->getSelection();

    if (selection->size() == 1) {
      const CQIllustratorSelectedShape &sshape = selection->front();

      const CQIllustratorShape *shape = sshape.getShape();

      sizer_->draw(painter, shape);

      sizer_->drawSelectionHandles(painter, sshape);
    }
  }
  else {
    CQIllustratorShape *shape = illustrator_->getSandbox()->frontShape();

    if (shape)
      sizer_->draw(painter, shape);
  }
}

void
CQIllustratorCreatePolygonMode::
drawPolygonPoints(QPainter *painter)
{
  uint num_points = polygonPoints_.size();

  if (num_points == 0) return;

  // draw current polygon points
  QPen pen;

  pen.setColor(QColor(0,0,0));
  pen.setStyle(Qt::DashLine);

  painter->setPen(pen);
  painter->setBrush(Qt::NoBrush);

  QPainterPath path;

  const CPoint2D &ps = polygonPoints_[0];

  path.moveTo(ps.x, ps.y);

  for (uint i = 1; i < num_points; ++i) {
    const CPoint2D &p = polygonPoints_[i];

    path.lineTo(p.x, p.y);
  }

  CPoint2D pc = CQUtil::fromQPoint(curr_wpos_);

  snapPoint(pc);

  if (! pressed_)
    path.lineTo(pc.x, pc.y);

  path.lineTo(ps.x, ps.y);

  painter->strokePath(path, QPen(QColor(255,0,0)));

  //-----

  // draw close points
  uint numCloseHandles = closeHandles_.size();

  for (uint i = 0; i < numCloseHandles; ++i) {
    if (closeHandles_[i]->getVisible())
      closeHandles_[i]->draw(painter);
  }

  //-----

  // draw snap points
  uint numSnapHandles = snapHandles_.size();

  for (uint i = 0; i < numSnapHandles; ++i) {
    if (snapHandles_[i]->getVisible())
      snapHandles_[i]->draw(painter);
  }
}

QCursor
CQIllustratorCreatePolygonMode::
getCursor() const
{
  return Qt::ArrowCursor;
}

void
CQIllustratorCreatePolygonMode::
commitPolygonPoints()
{
  uint num_points = polygonPoints_.size();

  if (num_points == 0) return;

  CQIllustratorPolygonShape *polygon = illustrator_->createPolygonShape();

  polygon->setPoints(polygonPoints_);

  illustrator_->addShape(polygon);

  illustrator_->setSelectShape(polygon);

  polygonPoints_.clear();

  illustrator_->redraw();
}

void
CQIllustratorCreatePolygonMode::
addPointToCurrent()
{
  CQIllustratorSelectedShapes *selection = illustrator_->getSelection();

  if (selection->size() != 1) return;

  const CQIllustratorSelectedShape &sshape = selection->front();

  uint num = sshape.numPoints();

  if (num != 2) return;

  illustrator_->getSandbox()->addSelection();

  CQIllustratorShape *shape = illustrator_->getSandbox()->frontShape();

  CQIllustratorPolygonShape *polygon = dynamic_cast<CQIllustratorPolygonShape *>(shape);

  const CQIllustratorPolygonShapeControlPoint *controlPoint1 =
    dynamic_cast<const CQIllustratorPolygonShapeControlPoint *>(sshape.getPoint(0));
  const CQIllustratorPolygonShapeControlPoint *controlPoint2 =
    dynamic_cast<const CQIllustratorPolygonShapeControlPoint *>(sshape.getPoint(1));

  CPoint2D p1 = controlPoint1->getPoint(shape);
  CPoint2D p2 = controlPoint2->getPoint(shape);

  if (controlPoint1->getInd() < controlPoint2->getInd())
    polygon->addPoint(controlPoint2, (p1 + p2)/2);
  else
    polygon->addPoint(controlPoint1, (p1 + p2)/2);

  illustrator_->getSandbox()->commit(CQIllustratorData::CHANGE_GEOMETRY);
}

void
CQIllustratorCreatePolygonMode::
removePointFromCurrent()
{
  CQIllustratorSelectedShapes *selection = illustrator_->getSelection();

  if (selection->size() < 1) return;

  const CQIllustratorSelectedShape &sshape = selection->front();

  uint num = sshape.numPoints();

  illustrator_->getSandbox()->addSelection();

  CQIllustratorShape *shape = illustrator_->getSandbox()->frontShape();

  CQIllustratorPolygonShape *polygon = dynamic_cast<CQIllustratorPolygonShape *>(shape);

  for (uint i = 0; i < num; ++i) {
    int i1 = num - i - 1;

    const CQIllustratorPolygonShapeControlPoint *controlPoint =
      dynamic_cast<const CQIllustratorPolygonShapeControlPoint *>(sshape.getPoint(i1));

    polygon->removePoint(controlPoint);
  }

  illustrator_->getSandbox()->commit(CQIllustratorData::CHANGE_GEOMETRY);
}

//------------

CQIllustratorCreatePolygonToolbar::
CQIllustratorCreatePolygonToolbar(CQIllustratorCreatePolygonMode *mode) :
 CQIllustratorToolbar(mode), mode_(mode), createMode_(CREATE_FREE_MODE)
{
}

QIcon
CQIllustratorCreatePolygonToolbar::
getIcon()
{
  return QIcon(QPixmap(polygon_data));
}

void
CQIllustratorCreatePolygonToolbar::
addWidgets()
{
  QBoxLayout *layout = qobject_cast<QBoxLayout *>(CQIllustratorToolbar::layout());

  //-----

#if 0
  QWidget *modeFrame = new QWidget;

  QVBoxLayout *modeLayout = new QVBoxLayout(modeFrame);

  createRadio_ = new QRadioButton("Create");
  editRadio_   = new QRadioButton("Edit");

  createRadio_->setChecked(true);

  createRadio_->setFocusPolicy(Qt::NoFocus);
  editRadio_  ->setFocusPolicy(Qt::NoFocus);

  modeLayout->addWidget(createRadio_);
  modeLayout->addWidget(editRadio_);

  connect(createRadio_, SIGNAL(toggled(bool)), this, SLOT(modeChangedSlot()));

  CQSwatch *modeSwatch = new CQSwatch(modeFrame);

  layout->addWidget(modeSwatch);
#endif

  //-----

  polyFreeButton_ = new CQImageButton(QPixmap(poly_free_data));
  polyRectButton_ = new CQImageButton(QPixmap(poly_rect_data));
  poly45Button_   = new CQImageButton(QPixmap(poly_45_data));

  connect(polyFreeButton_, SIGNAL(toggled(bool)), this, SLOT(polyFreeSlot(bool)));
  connect(polyRectButton_, SIGNAL(toggled(bool)), this, SLOT(polyRectSlot(bool)));
  connect(poly45Button_  , SIGNAL(toggled(bool)), this, SLOT(poly45Slot(bool)));

  polyFreeButton_->setCheckable(true);
  polyRectButton_->setCheckable(true);
  poly45Button_  ->setCheckable(true);

  polyFreeButton_->setChecked(true);

  CQSwatch *createModeSwatch =
    new CQSwatch("Mode", polyFreeButton_, polyRectButton_, poly45Button_);

  layout->addWidget(createModeSwatch);

  //-----

  addPointButton_    = new CQImageButton(QPixmap(path_add_data));
  removePointButton_ = new CQImageButton(QPixmap(path_remove_data));

  addPointButton_   ->setToolTip("Add Point");
  removePointButton_->setToolTip("Remove Point");

  connect(addPointButton_   , SIGNAL(clicked()), this, SLOT(addPointSlot   ()));
  connect(removePointButton_, SIGNAL(clicked()), this, SLOT(removePointSlot()));

  CQSwatch *modifySwatch = new CQSwatch("Modify<2>", addPointButton_, removePointButton_);

  layout->addWidget(modifySwatch);

  //-----

  pointEdit_ = new CQPointEdit;

  connect(pointEdit_, SIGNAL(valueChanged()), this, SLOT(updatePointSlot()));

  CQSwatch *pointSwatch = new CQSwatch("Position", pointEdit_);

  layout->addWidget(pointSwatch);
}

void
CQIllustratorCreatePolygonToolbar::
modeChangedSlot()
{
  if (createRadio_->isChecked())
    mode_->setEditMode(CQIllustratorMode::CREATE_MODE);
  else
    mode_->setEditMode(CQIllustratorMode::EDIT_MODE);
}

void
CQIllustratorCreatePolygonToolbar::
polyFreeSlot(bool state)
{
  if (state) {
    createMode_ = CREATE_FREE_MODE;

    polyRectButton_->setChecked(false);
    poly45Button_  ->setChecked(false);
  }
}

void
CQIllustratorCreatePolygonToolbar::
polyRectSlot(bool state)
{
  if (state) {
    createMode_ = CREATE_RECT_MODE;

    polyFreeButton_->setChecked(false);
    poly45Button_  ->setChecked(false);
  }
}

void
CQIllustratorCreatePolygonToolbar::
poly45Slot(bool state)
{
  if (state) {
    createMode_ = CREATE_45_MODE;

    polyRectButton_->setChecked(false);
    polyFreeButton_->setChecked(false);
  }
}

void
CQIllustratorCreatePolygonToolbar::
addPointSlot()
{
  mode_->addPointToCurrent();
}

void
CQIllustratorCreatePolygonToolbar::
removePointSlot()
{
  mode_->removePointFromCurrent();
}

void
CQIllustratorCreatePolygonToolbar::
updatePointSlot()
{
  CPoint2D p = pointEdit_->getValue();

  CQIllustrator *illustrator = mode_->getIllustrator();

  CQIllustratorSelectedShapes *selection = illustrator->getSelection();

  if (selection->size() != 1) return;

  const CQIllustratorSelectedShape &sshape = selection->front();

  uint num = sshape.numPoints();

  if (num != 1) return;

  CQIllustratorSelectedShape &sshape1 =
    selection->checkoutShape(sshape, mode_->getChangeType());

  CQIllustratorShapeControlPoint *point = sshape1.getPoint(0);

  point->setPoint(sshape1.getShape(), p);

  selection->checkinShape(sshape, mode_->getChangeType());
}

void
CQIllustratorCreatePolygonToolbar::
setSelectedShape(const CQIllustratorShape *shape)
{
  const CQIllustratorPolygonShape *polygon =
    dynamic_cast<const CQIllustratorPolygonShape *>(shape);

  if (! polygon) return;
}

void
CQIllustratorCreatePolygonToolbar::
setSelectedShapePoint(const CQIllustratorShape *shape,
                      const CQIllustratorShapeControlPoint *point)
{
  const CQIllustratorPolygonShape *polygon =
    dynamic_cast<const CQIllustratorPolygonShape *>(shape);

  if (! polygon) return;

  if (point)
    pointEdit_->setValue(point->getPoint(shape));
  else
    pointEdit_->setValue(CPoint2D(0,0));
}

void
CQIllustratorCreatePolygonToolbar::
updateShape()
{
  CQIllustrator *illustrator = mode_->getIllustrator();

  CQIllustratorPolygonShape *shape =
    CQIllustratorUtil::getCurrentShape<CQIllustratorPolygonShape>(illustrator);

  CQIllustratorPolygonShape *polygon = 0;

  if (shape)
    polygon = dynamic_cast<CQIllustratorPolygonShape *>(shape);

  if (polygon) {
    //illustrator->checkoutShape(shape);

    //illustrator->checkinShape(shape);
  }

  illustrator->redraw();
}

void
CQIllustratorCreatePolygonToolbar::
setSelectionPoint(const CPoint2D &p)
{
  pointEdit_->setValue(p);
}

//------

CQIllustratorCreatePolygonSizer::
CQIllustratorCreatePolygonSizer(CQIllustratorCreatePolygonMode *mode) :
 CQIllustratorModeSizer(mode)
{
}

void
CQIllustratorCreatePolygonSizer::
drawHandles(QPainter *painter, const CQIllustratorShape *shape)
{
  const CQIllustratorPolygonShape *polygon =
    dynamic_cast<const CQIllustratorPolygonShape *>(shape);

  if (polygon) {
    CQIllustratorShape::ControlPointList controlPoints;

    polygon->getControlPoints(controlPoints);

    uint numControlPoints = controlPoints.size();

    updateHandles(numControlPoints);

    for (uint i = 0; i < numControlPoints; ++i) {
      CQIllustratorPolygonShapeControlPoint *controlPoint =
        dynamic_cast<CQIllustratorPolygonShapeControlPoint *>(controlPoints[i]);

      controlPointHandles_[i]->draw(polygon, controlPoint, painter);
    }
  }
}

void
CQIllustratorCreatePolygonSizer::
updateHandles(uint numHandles)
{
  CQIllustrator *illustrator = mode_->getIllustrator();

  while (controlPointHandles_.size() < numHandles) {
    CQIllustratorControlPointHandle *handle = new CQIllustratorControlPointHandle(illustrator);

    addHandle(handle);
  }

  while (controlPointHandles_.size() > numHandles) {
    CQIllustratorControlPointHandle *handle = 0;

    removeHandle(handle);
  }
}
##concat##CQIllustratorCreateRectMode.cpp
#include <CQIllustratorCreateRectMode.h>
#include <CQIllustrator.h>
#include <CQIllustratorCmd.h>
#include <CQIllustratorHandle.h>
#include <CQIllustratorShapeDrawer.h>

#include <QPainter>
#include <QHBoxLayout>

#include <CQMenu.h>
#include <CQUtil.h>
#include <CQPointEdit.h>
#include <CQRealEdit.h>
#include <CQSwatch.h>

#include <xpm/rect.xpm>

#include <cursors/rect.xbm>
#include <cursors/rectmask.xbm>

class CQIllustratorCreateRectCmd : public CQIllustratorCmd {
 public:
  CQIllustratorCreateRectCmd();

  const char *getName() const { return "create_rect"; }

  bool exec(const std::vector<std::string> &words);
};

CQIllustratorCreateRectMode::
CQIllustratorCreateRectMode(CQIllustrator *illustrator) :
 CQIllustratorMode(illustrator, CQIllustrator::MODE_RECT), equalSize_(false)
{
  setCursor(rect_bits, rectmask_bits, 2, 2);

  illustrator_->addCommand(new CQIllustratorCreateRectCmd);
}

CQIllustratorCreateRectToolbar *
CQIllustratorCreateRectMode::
createToolbar()
{
  toolbar_ = new CQIllustratorCreateRectToolbar(this);

  return toolbar_;
}

CQIllustratorCreateRectSizer *
CQIllustratorCreateRectMode::
createSizer()
{
  sizer_ = new CQIllustratorCreateRectSizer(this);

  return sizer_;
}

CQMenuItem *
CQIllustratorCreateRectMode::
createMenuItem(CQMenu *menu)
{
  menuItem_ = new CQMenuItem(menu, "&Rectangle", CQMenuItem::CHECKABLE);

  menuItem_->setStatusTip("Create Rectangle");
  menuItem_->setXPMIcon(rect_data);

  connect(menuItem_->getAction(), SIGNAL(toggled(bool)), this, SLOT(menuItemSlot()));

  return menuItem_;
}

void
CQIllustratorCreateRectMode::
handleMouseRelease(const MouseEvent &e)
{
  CPoint2D p1 = CQUtil::fromQPoint(press_wpos_);
  CPoint2D p2 = CQUtil::fromQPoint(release_wpos_);

  if (dragging_) {
    if (! moving_) {
      selectControlPoint(e);
    }
    // dragging finished so commit
    else {
      illustrator_->getSandbox()->commit(CQIllustratorData::CHANGE_GEOMETRY);
    }
  }
  // not dragging so do a select
  else {
    if (editMode_ == CREATE_MODE) {
      // drag then create rectangle using specified bbox
      if (moving_) {
        CBBox2D bbox(p1, p2);

        if (e.event->isShiftKey()) {
          double w = bbox.getWidth ();
          double h = bbox.getHeight();

          if (w > h)
            bbox.setHeight(w);
          else
            bbox.setWidth(h);
        }

        CQIllustratorRectShape *rect =
          illustrator_->createRectShape(bbox.getLL(), bbox.getUR());

        illustrator_->addShape(rect);

        illustrator_->setSelectShape(rect);
      }
    }
    else {
      // point click - select at point
      if (! moving_) {
        (void) illustrator_->selectAt(p2, e.event->isControlKey(), e.event->isShiftKey());
      }
      // drag - select points in rectangle
      else {
        CBBox2D bbox(p1, p2);

        illustrator_->selectPointsIn(bbox, CQIllustratorShape::CONTROL_GEOMETRY,
                                     e.event->isControlKey(), e.event->isShiftKey());
      }
    }
  }

  dragging_ = false;

  illustrator_->redraw();
}

void
CQIllustratorCreateRectMode::
handleMouseDrag(const MouseEvent &e)
{
  if (dragging_) {
    CQIllustratorShape *shape = illustrator_->getSandbox()->frontShape();

    sizer_->updatePoint(shape, e.window);
  }
  else {
    CPoint2D p1 = CQUtil::fromQPoint(press_wpos_);
    CPoint2D p2 = CQUtil::fromQPoint(curr_wpos_);

    CBBox2D bbox(p1, p2);

    equalSize_ = e.event->isShiftKey();

    if (equalSize_) {
      double w = bbox.getWidth ();
      double h = bbox.getHeight();

      if (w > h)
        bbox.setHeight(w);
      else
        bbox.setWidth(h);
    }

    toolbar_->setSize(bbox);
  }

  illustrator_->redrawOverlay();
}

void
CQIllustratorCreateRectMode::
drawOverlay(CQIllustratorShapeDrawer *drawer)
{
  QPainter *painter = drawer->getPainter();

  if (! dragging_) {
    // draw creation rubber band
    if (pressed_) {
      CPoint2D p1 = CQUtil::fromQPoint(press_wpos_);
      CPoint2D p2 = CQUtil::fromQPoint(curr_wpos_);

      CBBox2D bbox(p1, p2);

      if (equalSize_) {
        double w = bbox.getWidth ();
        double h = bbox.getHeight();

        if (w > h)
          bbox.setHeight(w);
        else
          bbox.setWidth(h);
      }

      QPen pen;

      pen.setColor(QColor(0,0,0));
      pen.setStyle(Qt::DashLine);

      painter->setPen(pen);
      painter->setBrush(Qt::NoBrush);

      painter->drawRect(CQUtil::toQRect(bbox));
    }

    //------

    // draw handles for single selected shape
    CQIllustratorSelectedShapes *selection = illustrator_->getSelection();

    if (selection->size() == 1) {
      const CQIllustratorSelectedShape &sshape = selection->front();

      const CQIllustratorShape *shape = sshape.getShape();

      sizer_->draw(painter, shape);

      sizer_->drawSelectionHandles(painter, sshape);
    }
  }
  else {
    CQIllustratorShape *shape = illustrator_->getSandbox()->frontShape();

    sizer_->draw(painter, shape);
  }
}

//------------

CQIllustratorCreateRectToolbar::
CQIllustratorCreateRectToolbar(CQIllustratorCreateRectMode *mode) :
 CQIllustratorToolbar(mode), mode_(mode)
{
}

QIcon
CQIllustratorCreateRectToolbar::
getIcon()
{
  return QIcon(QPixmap(rect_data));
}

void
CQIllustratorCreateRectToolbar::
addWidgets()
{
  QBoxLayout *layout = qobject_cast<QBoxLayout *>(CQIllustratorToolbar::layout());

  //-----

  posEdit_    = new CQPointEdit;
  widthEdit_  = new CQRealEdit(0.0);
  heightEdit_ = new CQRealEdit(0.0);
  xRadEdit_   = new CQRealEdit(0.0);
  yRadEdit_   = new CQRealEdit(0.0);

  posEdit_   ->setFocusPolicy(Qt::ClickFocus);
  widthEdit_ ->setFocusPolicy(Qt::ClickFocus);
  heightEdit_->setFocusPolicy(Qt::ClickFocus);
  xRadEdit_  ->setFocusPolicy(Qt::ClickFocus);
  yRadEdit_  ->setFocusPolicy(Qt::ClickFocus);

  connect(posEdit_   , SIGNAL(valueChanged()), this, SLOT(updateShape()));
  connect(widthEdit_ , SIGNAL(valueChanged(double)), this, SLOT(updateShape()));
  connect(heightEdit_, SIGNAL(valueChanged(double)), this, SLOT(updateShape()));
  connect(xRadEdit_  , SIGNAL(valueChanged(double)), this, SLOT(updateShape()));
  connect(yRadEdit_  , SIGNAL(valueChanged(double)), this, SLOT(updateShape()));

  CQSwatch *posSwatch    = new CQSwatch("Position", posEdit_   );
  CQSwatch *widthSwatch  = new CQSwatch("Width"   , widthEdit_ );
  CQSwatch *heightSwatch = new CQSwatch("Height"  , heightEdit_);
  CQSwatch *xRadSwatch   = new CQSwatch("X Radius", xRadEdit_  );
  CQSwatch *yRadSwatch   = new CQSwatch("Y Radius", yRadEdit_  );

  layout->addWidget(posSwatch);
  layout->addWidget(widthSwatch);
  layout->addWidget(heightSwatch);
  layout->addWidget(xRadSwatch);
  layout->addWidget(yRadSwatch);

  posEdit_   ->setEnabled(false);
  widthEdit_ ->setEnabled(false);
  heightEdit_->setEnabled(false);
  xRadEdit_  ->setEnabled(false);
  yRadEdit_  ->setEnabled(false);
}

void
CQIllustratorCreateRectToolbar::
setSelectedShape(const CQIllustratorShape *shape)
{
  const CQIllustratorRectShape *rect = dynamic_cast<const CQIllustratorRectShape *>(shape);

  posEdit_   ->setEnabled(rect != 0);
  widthEdit_ ->setEnabled(rect != 0);
  heightEdit_->setEnabled(rect != 0);
  xRadEdit_  ->setEnabled(rect != 0);
  yRadEdit_  ->setEnabled(rect != 0);

  if (rect) {
    const CBBox2D &bbox = rect->getBBox();

    setSize(bbox);

    xRadEdit_->setValue(rect->getRadiusX());
    yRadEdit_->setValue(rect->getRadiusY());
  }
  else {
    posEdit_   ->setValue();
    widthEdit_ ->setValue(0.0);
    heightEdit_->setValue(0.0);
    xRadEdit_  ->setValue(0.0);
    yRadEdit_  ->setValue(0.0);
  }
}

void
CQIllustratorCreateRectToolbar::
setSize(const CBBox2D &bbox)
{
  const CPoint2D &pos = bbox.getLL();

  posEdit_->setValue(pos);

  double w = bbox.getWidth();
  double h = bbox.getHeight();

  widthEdit_ ->setValue(w);
  heightEdit_->setValue(h);
}

void
CQIllustratorCreateRectToolbar::
updateShape()
{
  CQIllustrator *illustrator = mode_->getIllustrator();

  CQIllustratorRectShape *shape =
    CQIllustratorUtil::getCurrentShape<CQIllustratorRectShape>(illustrator);

  if (shape) {
    const CPoint2D &pos = posEdit_->getValue();

    double width  = widthEdit_ ->getValue();
    double height = heightEdit_->getValue();

    double xRad = xRadEdit_->getValue();
    double yRad = yRadEdit_->getValue();

    illustrator->checkoutShape(shape, CQIllustratorData::CHANGE_GEOMETRY);

    CQIllustratorRectShape *rect = dynamic_cast<CQIllustratorRectShape *>(shape);

    CBBox2D bbox(pos, CPoint2D(pos.x + width, pos.y + height));

    rect->setBBox(bbox);

    rect->setRadiusX(xRad);
    rect->setRadiusY(yRad);

    illustrator->checkinShape(shape, CQIllustratorData::CHANGE_GEOMETRY);
  }

  illustrator->redraw();
}

//------

CQIllustratorCreateRectSizer::
CQIllustratorCreateRectSizer(CQIllustratorCreateRectMode *mode) :
 CQIllustratorModeSizer(mode)
{
  CQIllustrator *illustrator = mode_->getIllustrator();

  ll_handle_ = new CQIllustratorControlPointHandle(illustrator);
  ur_handle_ = new CQIllustratorControlPointHandle(illustrator);
  rx_handle_ = new CQIllustratorControlPointHandle(illustrator);
  ry_handle_ = new CQIllustratorControlPointHandle(illustrator);

  rx_handle_->setStyle(CQIllustratorHandle::CIRCLE_STYLE);
  ry_handle_->setStyle(CQIllustratorHandle::CIRCLE_STYLE);

  addHandle(ll_handle_);
  addHandle(ur_handle_);
  addHandle(rx_handle_);
  addHandle(ry_handle_);
}

void
CQIllustratorCreateRectSizer::
drawHandles(QPainter *painter, const CQIllustratorShape *shape)
{
  const CQIllustratorRectShape *rect = dynamic_cast<const CQIllustratorRectShape *>(shape);

  if (rect) {
    CQIllustratorShape::ControlPointList controlPoints;

    rect->getControlPoints(controlPoints);

    ll_handle_->draw(rect, controlPoints[0], painter);
    ur_handle_->draw(rect, controlPoints[1], painter);
    rx_handle_->draw(rect, controlPoints[2], painter);
    ry_handle_->draw(rect, controlPoints[3], painter);
  }
}

//----------

static const char *create_rect_opts = "\
-x:r=0 \
-y:r=0 \
-w:r=100 \
-h:r=100 \
-rx:r=0 \
-ry:r=0 \
-a:r=0 \
-name:s";

CQIllustratorCreateRectCmd::
CQIllustratorCreateRectCmd() :
 CQIllustratorCmd(create_rect_opts)
{
}

bool
CQIllustratorCreateRectCmd::
exec(const std::vector<std::string> &words)
{
  args_.parse(words);

  double x  = args_.getRealArg("-x");
  double y  = args_.getRealArg("-y");
  double w  = args_.getRealArg("-w");
  double h  = args_.getRealArg("-h");
  double rx = args_.getRealArg("-rx");
  double ry = args_.getRealArg("-ry");
  double a  = args_.getRealArg("-a");

  CBBox2D bbox(CPoint2D(x, y), CSize2D(w, h));

  CQIllustratorRectShape *rect =
    illustrator_->createRectShape(bbox.getLL(), bbox.getUR(), rx, ry);

  std::string name = args_.getStringArg("-name");

  if (name != "")
    rect->setName(name);

  rect->rotate(M_PI*a/180.0);

  illustrator_->addShape(rect);

  illustrator_->setSelectShape(rect);

  return true;
}
##concat##CQIllustratorCreateStarMode.cpp
#include <CQIllustratorCreateStarMode.h>
#include <CQIllustrator.h>
#include <CQIllustratorHandle.h>
#include <CQIllustratorShapeDrawer.h>

#include <QPainter>
#include <QHBoxLayout>

#include <CQMenu.h>
#include <CQUtil.h>
#include <CQImageButton.h>
#include <CQPointEdit.h>
#include <CQIntegerEdit.h>
#include <CQRealEdit.h>
#include <CQAngleSpinBox.h>
#include <CQSwatch.h>

#include <xpm/star_poly.xpm>
#include <xpm/poly.xpm>
#include <xpm/star.xpm>
#include <xpm/center.xpm>
#include <xpm/center_active.xpm>

#include <cursors/star.xbm>
#include <cursors/starmask.xbm>

#define IMAGE_DATA(I) I, sizeof(I)/sizeof(char *)

CQIllustratorCreateStarMode::
CQIllustratorCreateStarMode(CQIllustrator *illustrator) :
 CQIllustratorMode(illustrator, CQIllustrator::MODE_STAR)
{
  setCursor(star_bits, starmask_bits, 2, 2);
}

CQIllustratorCreateStarToolbar *
CQIllustratorCreateStarMode::
createToolbar()
{
  toolbar_ = new CQIllustratorCreateStarToolbar(this);

  return toolbar_;
}

CQIllustratorCreateStarSizer *
CQIllustratorCreateStarMode::
createSizer()
{
  sizer_ = new CQIllustratorCreateStarSizer(this);

  return sizer_;
}

CQMenuItem *
CQIllustratorCreateStarMode::
createMenuItem(CQMenu *menu)
{
  menuItem_ = new CQMenuItem(menu, "&Star", CQMenuItem::CHECKABLE);

  menuItem_->setStatusTip("Create Star or Polygon");
  menuItem_->setXPMIcon(star_poly_data);

  connect(menuItem_->getAction(), SIGNAL(toggled(bool)), this, SLOT(menuItemSlot()));

  return menuItem_;
}

void
CQIllustratorCreateStarMode::
handleMouseRelease(const MouseEvent &e)
{
  CPoint2D p2 = CQUtil::fromQPoint(e.window);

  if (dragging_) {
    if (! moving_) {
      selectControlPoint(e);
    }
    // dragging finished so commit
    else {
      illustrator_->getSandbox()->commit(CQIllustratorData::CHANGE_GEOMETRY);
    }
  }
  // not dragging so do a select
  else {
    CPoint2D p1 = CQUtil::fromQPoint(press_wpos_);

    // point click - select at point and toggle sizer mode if same shape selected
    if (! moving_) {
      (void) illustrator_->selectAt(p1, e.event->isControlKey(), e.event->isShiftKey());
    }
    // drag then create star or rectangle using specified bbox
    else {
      double r = CVector2D(p2, p1).length()/2.0;

      uint n = 5;

      double da = 2.0*M_PI/n;

      double a2 = CMathGen::RadToDeg(M_PI/2.0);
      double a1 = a2 - CMathGen::RadToDeg(da/2.0);

      if (toolbar_->getCreateMode() == CQIllustratorCreateStarToolbar::CREATE_STAR_MODE) {
        CQIllustratorStarShape *star =
          illustrator_->createStarShape((p1 + p2)/2, n, r/2.0, r, a1, a2);

        illustrator_->addShape(star);

        illustrator_->setSelectShape(star);
      }
      else {
        CQIllustratorNPolyShape *poly =
          illustrator_->createNPolyShape((p1 + p2)/2, n, r, a2);

        illustrator_->addShape(poly);

        illustrator_->setSelectShape(poly);
      }
    }
  }

  dragging_ = false;

  illustrator_->redraw();
}

void
CQIllustratorCreateStarMode::
handleMouseDrag(const MouseEvent &e)
{
  if (dragging_) {
    CQIllustratorShape *shape = illustrator_->getSandbox()->frontShape();

    sizer_->updatePoint(shape, e.window);
  }
  else {
    CPoint2D p1 = CQUtil::fromQPoint(press_wpos_);
    CPoint2D p2 = CQUtil::fromQPoint(e.window);

    toolbar_->setSize(CBBox2D(p1, p2));
  }

  illustrator_->redrawOverlay();

  prev_wpos_ = e.window;
}

void
CQIllustratorCreateStarMode::
drawOverlay(CQIllustratorShapeDrawer *drawer)
{
  QPainter *painter = drawer->getPainter();

  if (! dragging_) {
    // draw creation rubber band
    if (pressed_) {
      QPointF current_wpos = illustrator_->getITransform().map(QPointF(curr_ppos_));

      QPen pen;

      pen.setColor(QColor(0,0,0));
      pen.setStyle(Qt::DashLine);

      painter->setPen(pen);
      painter->setBrush(Qt::NoBrush);

      painter->drawRect(QRectF(press_wpos_, current_wpos));
    }

    //------

    // draw handles for single selected shape
    CQIllustratorSelectedShapes *selection = illustrator_->getSelection();

    if (selection->size() == 1) {
      const CQIllustratorSelectedShape &sshape = selection->front();

      const CQIllustratorShape *shape = sshape.getShape();

      sizer_->draw(painter, shape);

      sizer_->drawSelectionHandles(painter, sshape);
    }
  }
  else {
    CQIllustratorShape *shape = illustrator_->getSandbox()->frontShape();

    sizer_->draw(painter, shape);
  }
}

//------------

CQIllustratorCreateStarToolbar::
CQIllustratorCreateStarToolbar(CQIllustratorCreateStarMode *mode) :
 CQIllustratorToolbar(mode), mode_(mode), createMode_(CREATE_STAR_MODE)
{
}

QIcon
CQIllustratorCreateStarToolbar::
getIcon()
{
  return QIcon(QPixmap(star_poly_data));
}

void
CQIllustratorCreateStarToolbar::
addWidgets()
{
  QBoxLayout *layout = qobject_cast<QBoxLayout *>(CQIllustratorToolbar::layout());

  //-----

  starButton_ = new CQImageButton(QPixmap(star_data));
  polyButton_ = new CQImageButton(QPixmap(poly_data));

  connect(starButton_, SIGNAL(toggled(bool)), this, SLOT(starModeSlot(bool)));
  connect(polyButton_, SIGNAL(toggled(bool)), this, SLOT(polyModeSlot(bool)));

  starButton_->setCheckable(true);
  polyButton_->setCheckable(true);

  starButton_->setChecked(true);

  CQSwatch *modeSwatch = new CQSwatch("Mode", starButton_, polyButton_);

  layout->addWidget(modeSwatch);

  //-----

  centerEdit_  = new CQPointEdit;
  numEdit_     = new QSpinBox(0);
  radius1Edit_ = new CQRealEdit(0.0);
  radius2Edit_ = new CQRealEdit(0.0);
  angle1Edit_  = new CQAngleSpinBox(0.0);
  angle2Edit_  = new CQAngleSpinBox(0.0);

  numEdit_->setRange(0, 100);

  centerEdit_ ->setFocusPolicy(Qt::ClickFocus);
  numEdit_    ->setFocusPolicy(Qt::ClickFocus);
  radius1Edit_->setFocusPolicy(Qt::ClickFocus);
  radius2Edit_->setFocusPolicy(Qt::ClickFocus);
  angle1Edit_ ->setFocusPolicy(Qt::ClickFocus);
  angle2Edit_ ->setFocusPolicy(Qt::ClickFocus);

  connect(centerEdit_ , SIGNAL(valueChanged()), this, SLOT(updateShape()));
  connect(numEdit_    , SIGNAL(valueChanged(int)), this, SLOT(updateShape()));
  connect(radius1Edit_, SIGNAL(valueChanged(double)), this, SLOT(updateShape()));
  connect(radius2Edit_, SIGNAL(valueChanged(double)), this, SLOT(updateShape()));
  connect(angle1Edit_ , SIGNAL(angleChanged(double)), this, SLOT(updateShape()));
  connect(angle2Edit_ , SIGNAL(angleChanged(double)), this, SLOT(updateShape()));

  CQSwatch *centerSwatch  = new CQSwatch("Center"       , centerEdit_ );
  CQSwatch *numSwatch     = new CQSwatch("Num Sides"    , numEdit_    );
  CQSwatch *radius1Swatch = new CQSwatch("Innner Radius", radius1Edit_);
  CQSwatch *radius2Swatch = new CQSwatch("Outer Radius" , radius2Edit_);
  CQSwatch *angle1Swatch  = new CQSwatch("Inner Angle"  , angle1Edit_ );
  CQSwatch *angle2Swatch  = new CQSwatch("Outer Angle"  , angle2Edit_ );

  layout->addWidget(centerSwatch);
  layout->addWidget(numSwatch);
  layout->addWidget(radius1Swatch);
  layout->addWidget(radius2Swatch);
  layout->addWidget(angle1Swatch);
  layout->addWidget(angle2Swatch);

  centerEdit_ ->setEnabled(false);
  numEdit_    ->setEnabled(false);
  radius1Edit_->setEnabled(false);
  radius2Edit_->setEnabled(false);
  angle1Edit_ ->setEnabled(false);
  angle2Edit_ ->setEnabled(false);
}

void
CQIllustratorCreateStarToolbar::
setSelectedShape(const CQIllustratorShape *shape)
{
  const CQIllustratorStarShape  *star = dynamic_cast<const CQIllustratorStarShape  *>(shape);
  const CQIllustratorNPolyShape *poly = dynamic_cast<const CQIllustratorNPolyShape *>(shape);

  centerEdit_ ->setEnabled(star != 0 || poly != 0);
  numEdit_    ->setEnabled(star != 0 || poly != 0);
  radius1Edit_->setEnabled(star != 0 || poly != 0);
  radius2Edit_->setEnabled(star != 0);
  angle1Edit_ ->setEnabled(star != 0 || poly != 0);
  angle2Edit_ ->setEnabled(star != 0);

  disconnect(numEdit_   , SIGNAL(valueChanged(int)), this, SLOT(updateShape()));
  disconnect(angle1Edit_, SIGNAL(angleChanged(double)), this, SLOT(updateShape()));
  disconnect(angle2Edit_, SIGNAL(angleChanged(double)), this, SLOT(updateShape()));

  if      (star) {
    const CBBox2D &bbox = star->getBBox();

    setSize(bbox);

    numEdit_    ->setValue(star->getNum());
    radius1Edit_->setValue(star->getInnerRadius());
    radius2Edit_->setValue(star->getOuterRadius());
    angle1Edit_ ->setValue(star->getInnerAngle());
    angle2Edit_ ->setValue(star->getOuterAngle());
  }
  else if (poly) {
    const CBBox2D &bbox = poly->getBBox();

    setSize(bbox);

    numEdit_    ->setValue(poly->getNum());
    radius1Edit_->setValue(poly->getRadius());
    angle1Edit_ ->setValue(poly->getAngle());
  }
  else {
    numEdit_    ->setValue(0);
    radius1Edit_->setValue(0.0);
    radius2Edit_->setValue(0.0);
    angle1Edit_ ->setValue(0.0);
    angle2Edit_ ->setValue(0.0);
  }

  connect(numEdit_   , SIGNAL(valueChanged(int)), this, SLOT(updateShape()));
  connect(angle1Edit_, SIGNAL(angleChanged(double)), this, SLOT(updateShape()));
  connect(angle2Edit_, SIGNAL(angleChanged(double)), this, SLOT(updateShape()));
}

void
CQIllustratorCreateStarToolbar::
setSize(const CBBox2D &bbox)
{
  CPoint2D c = bbox.getCenter();

  centerEdit_->setValue(c);
}

void
CQIllustratorCreateStarToolbar::
starModeSlot(bool state)
{
  if (state) {
    createMode_ = CREATE_STAR_MODE;

    polyButton_->setChecked(false);
  }
}

void
CQIllustratorCreateStarToolbar::
polyModeSlot(bool state)
{
  if (state) {
    createMode_ = CREATE_POLY_MODE;

    starButton_->setChecked(false);
  }
}

void
CQIllustratorCreateStarToolbar::
updateShape()
{
  CQIllustrator *illustrator = mode_->getIllustrator();

  CQIllustratorStarShape  *star =
    CQIllustratorUtil::getCurrentShape<CQIllustratorStarShape>(illustrator);
  CQIllustratorNPolyShape *poly =
    CQIllustratorUtil::getCurrentShape<CQIllustratorNPolyShape>(illustrator);

  if      (star) {
    CPoint2D c  = centerEdit_ ->getValue();
    int      n  = numEdit_    ->value();
    double   r1 = radius1Edit_->getValue();
    double   r2 = radius2Edit_->getValue();
    double   a1 = angle1Edit_ ->value();
    double   a2 = angle2Edit_ ->value();

    illustrator->checkoutShape(star, CQIllustratorData::CHANGE_GEOMETRY);

    star->setCenterPoint(c);
    star->setNum        (n);
    star->setInnerRadius(r1);
    star->setOuterRadius(r2);
    star->setInnerAngle (a1);
    star->setOuterAngle (a2);

    illustrator->checkinShape(star, CQIllustratorData::CHANGE_GEOMETRY);
  }
  else if (poly) {
    CPoint2D c = centerEdit_ ->getValue();
    int      n = numEdit_    ->value();
    double   r = radius1Edit_->getValue();
    double   a = angle1Edit_ ->value();

    illustrator->checkoutShape(poly, CQIllustratorData::CHANGE_GEOMETRY);

    poly->setCenterPoint(c);
    poly->setNum        (n);
    poly->setRadius     (r);
    poly->setAngle      (a);

    illustrator->checkinShape(poly, CQIllustratorData::CHANGE_GEOMETRY);
  }

  illustrator->redraw();
}

//------

CQIllustratorCreateStarSizer::
CQIllustratorCreateStarSizer(CQIllustratorCreateStarMode *mode) :
 CQIllustratorModeSizer(mode)
{
  CQIllustrator *illustrator = mode_->getIllustrator();

  c_handle_  = new CQIllustratorControlPointHandle(illustrator);
  ir_handle_ = new CQIllustratorControlPointHandle(illustrator);
  or_handle_ = new CQIllustratorControlPointHandle(illustrator);

  c_handle_->setImage(IMAGE_DATA(center_data), IMAGE_DATA(center_active_data));

  addHandle(c_handle_ );
  addHandle(ir_handle_);
  addHandle(or_handle_);
}

void
CQIllustratorCreateStarSizer::
drawHandles(QPainter *painter, const CQIllustratorShape *shape)
{
  const CQIllustratorStarShape  *star = dynamic_cast<const CQIllustratorStarShape  *>(shape);
  const CQIllustratorNPolyShape *poly = dynamic_cast<const CQIllustratorNPolyShape *>(shape);

  if      (star) {
    CQIllustratorShape::ControlPointList controlPoints;

    star->getControlPoints(controlPoints);

    c_handle_ ->draw(star, controlPoints[0], painter);
    ir_handle_->draw(star, controlPoints[1], painter);
    or_handle_->draw(star, controlPoints[2], painter);
  }
  else if (poly) {
    CQIllustratorShape::ControlPointList controlPoints;

    poly->getControlPoints(controlPoints);

    c_handle_ ->draw(poly, controlPoints[0], painter);
    ir_handle_->draw(poly, controlPoints[1], painter);
  }
}
##concat##CQIllustratorCreateTextMode.cpp
#include <CQIllustratorCreateTextMode.h>
#include <CQIllustrator.h>
#include <CQIllustratorHandle.h>
#include <CQIllustratorShapeDrawer.h>

#include <QPainter>
#include <QHBoxLayout>
#include <QFontComboBox>

#include <CQMenu.h>
#include <CQUtil.h>
#include <CQRealEdit.h>
#include <CQImageButton.h>
#include <CQSwatch.h>

#include <xpm/text.xpm>
#include <xpm/lalign.xpm>
#include <xpm/hcalign.xpm>
#include <xpm/ralign.xpm>
#include <xpm/balign.xpm>
#include <xpm/vcalign.xpm>
#include <xpm/talign.xpm>
#include <xpm/bold.xpm>
#include <xpm/italic.xpm>

#include <cursors/text.xbm>
#include <cursors/textmask.xbm>

CQIllustratorCreateTextMode::
CQIllustratorCreateTextMode(CQIllustrator *illustrator) :
 CQIllustratorMode(illustrator, CQIllustrator::MODE_TEXT), equalSize_(false),
 text_("Hello"), cursor_pos_(0)
{
  setCursor(text_bits, textmask_bits, 2, 2);
}

CQIllustratorCreateTextToolbar *
CQIllustratorCreateTextMode::
createToolbar()
{
  toolbar_ = new CQIllustratorCreateTextToolbar(this);

  return toolbar_;
}

CQIllustratorCreateTextSizer *
CQIllustratorCreateTextMode::
createSizer()
{
  sizer_ = new CQIllustratorCreateTextSizer(this);

  return sizer_;
}

CQMenuItem *
CQIllustratorCreateTextMode::
createMenuItem(CQMenu *menu)
{
  menuItem_ = new CQMenuItem(menu, "&Text", CQMenuItem::CHECKABLE);

  menuItem_->setStatusTip("Create Text");
  menuItem_->setXPMIcon(text_data);

  connect(menuItem_->getAction(), SIGNAL(toggled(bool)), this, SLOT(menuItemSlot()));

  return menuItem_;
}

void
CQIllustratorCreateTextMode::
handleMouseRelease(const MouseEvent &e)
{
  CPoint2D p2 = CQUtil::fromQPoint(e.window);

  if (dragging_) {
    if (! moving_) {
      selectControlPoint(e);
    }
    // dragging finished so commit
    else {
      illustrator_->getSandbox()->commit(CQIllustratorData::CHANGE_GEOMETRY);
    }
  }
  // not dragging so do a select
  else {
    CPoint2D p1 = CQUtil::fromQPoint(press_wpos_);

    // point click - select at point
    if (! moving_) {
      (void) illustrator_->selectAt(p2, e.event->isControlKey(), e.event->isShiftKey());
    }
    // drag then create text using specified bbox
    else {
      CBBox2D bbox(p1, p2);

      if (e.event->isShiftKey()) {
        double w = bbox.getWidth ();
        double h = bbox.getHeight();

        if (w > h)
          bbox.setHeight(w);
        else
          bbox.setWidth(h);
      }

      CQIllustratorTextShape *text =
        illustrator_->createTextShape(bbox.getLL(), bbox.getUR(), text_.toStdString());

      CQIllustratorShapeStroke stroke;
      CQIllustratorShapeFill   fill;

      stroke.setOpacity(0.0);
      fill  .setColor  (CRGBA(0,0,0));

      text->setStroke(stroke);
      text->setFill  (fill);

      text->setFont(CQUtil::fromQFont(toolbar_->getFont()));

      illustrator_->addShape(text);

      illustrator_->setSelectShape(text);
    }
  }

  dragging_ = false;

  illustrator_->redraw();
}

void
CQIllustratorCreateTextMode::
handleMouseDrag(const MouseEvent &e)
{
  if (dragging_) {
    CQIllustratorShape *shape = illustrator_->getSandbox()->frontShape();

    sizer_->updatePoint(shape, e.window);
  }
  else {
    CPoint2D p1 = CQUtil::fromQPoint(press_wpos_);
    CPoint2D p2 = CQUtil::fromQPoint(curr_wpos_);

    CBBox2D bbox(p1, p2);

    equalSize_ = e.event->isShiftKey();

    if (equalSize_) {
      double w = bbox.getWidth ();
      double h = bbox.getHeight();

      if (w > h)
        bbox.setHeight(w);
      else
        bbox.setWidth(h);
    }

    toolbar_->setSize(bbox);
  }

  illustrator_->redrawOverlay();
}

bool
CQIllustratorCreateTextMode::
handleKeyPress(const KeyEvent &e)
{
  CQIllustratorSelectedShapes *selection = illustrator_->getSelection();

  if (selection->size() != 1) return false;

  const CQIllustratorSelectedShape &sshape = selection->front();

  const CQIllustratorShape *shape = sshape.getShape();

  const CQIllustratorTextShape *text = dynamic_cast<const CQIllustratorTextShape *>(shape);

  if (! text) return false;

  std::string str  = text->getText();
  std::string str1 = str;

  CKeyType key = e.event->getType();

  if      (key >= CKEY_TYPE_Space && key <= CKEY_TYPE_AsciiTilde) {
    str1 += (char) key;
  }
  else if (key == CKEY_TYPE_Return) {
    str1 += '\n';
  }
  else if (key == CKEY_TYPE_BackSpace) {
    if (str1 != "")
      str1 = str1.substr(0, str1.size() - 1);
  }
  else
    return CQIllustratorMode::handleKeyPress(e);

  if (str != str1) {
    CQIllustratorTextShape *text1 = const_cast<CQIllustratorTextShape *>(text);

    illustrator_->checkoutShape(text1, CQIllustratorData::CHANGE_GEOMETRY);

    text1->setText(str1);

    illustrator_->checkinShape(text1, CQIllustratorData::CHANGE_GEOMETRY);
  }

  return true;
}

void
CQIllustratorCreateTextMode::
drawOverlay(CQIllustratorShapeDrawer *drawer)
{
  QPainter *painter = drawer->getPainter();

  if (! dragging_) {
    // draw creation rubber band
    if (pressed_) {
      QPointF current_wpos = illustrator_->getITransform().map(QPointF(curr_ppos_));

      QPen pen;

      pen.setColor(QColor(0,0,0));
      pen.setStyle(Qt::DashLine);

      painter->setPen(pen);
      painter->setBrush(Qt::NoBrush);

      painter->drawRect(QRectF(press_wpos_, current_wpos));
    }

    //------

    // draw handles for single selected shape
    CQIllustratorSelectedShapes *selection = illustrator_->getSelection();

    if (selection->size() == 1) {
      const CQIllustratorSelectedShape &sshape = selection->front();

      const CQIllustratorShape *shape = sshape.getShape();

      sizer_->draw(painter, shape);

      sizer_->drawSelectionHandles(painter, sshape);
    }
  }
  else {
    CQIllustratorShape *shape = illustrator_->getSandbox()->frontShape();

    sizer_->draw(painter, shape);
  }
}

void
CQIllustratorCreateTextMode::
setText(const QString &text)
{
  text_ = text;
}

//------------

CQIllustratorCreateTextToolbar::
CQIllustratorCreateTextToolbar(CQIllustratorCreateTextMode *mode) :
 CQIllustratorToolbar(mode), mode_(mode), font_ind_(-1), font_size_(-1),
 halign_(CHALIGN_TYPE_CENTER), valign_(CVALIGN_TYPE_CENTER)
{
}

QIcon
CQIllustratorCreateTextToolbar::
getIcon()
{
  return QIcon(QPixmap(text_data));
}

void
CQIllustratorCreateTextToolbar::
addWidgets()
{
  QBoxLayout *layout = qobject_cast<QBoxLayout *>(CQIllustratorToolbar::layout());

  //-----

  fontCombo_    = new QFontComboBox;
  sizeCombo_    = new QComboBox;
  boldButton_   = new CQImageButton(QPixmap(bold_data  ));
  italicButton_ = new CQImageButton(QPixmap(italic_data));

  boldButton_  ->setCheckable(true);
  italicButton_->setCheckable(true);

  fontCombo_->setWritingSystem(QFontDatabase::Latin);

  connect(fontCombo_   , SIGNAL(activated(int)), this, SLOT(fontComboSlot()));
  connect(sizeCombo_   , SIGNAL(activated(int)), this, SLOT(sizeComboSlot()));
  connect(boldButton_  , SIGNAL(clicked(bool)),  this, SLOT(boldSlot()));
  connect(italicButton_, SIGNAL(clicked(bool)),  this, SLOT(italicSlot()));

  CQSwatch *fontSwatch = new CQSwatch("Font", fontCombo_, sizeCombo_, boldButton_, italicButton_);

  layout->addWidget(fontSwatch);

  //-----

  textEdit_   = new QLineEdit(mode_->getText());
  widthEdit_  = new CQRealEdit(0.0);
  heightEdit_ = new CQRealEdit(0.0);

  textEdit_  ->setFocusPolicy(Qt::ClickFocus);
  widthEdit_ ->setFocusPolicy(Qt::ClickFocus);
  heightEdit_->setFocusPolicy(Qt::ClickFocus);

  connect(textEdit_  , SIGNAL(returnPressed()), this, SLOT(updateShape()));
  connect(widthEdit_ , SIGNAL(valueChanged(double)),  this, SLOT(updateShape()));
  connect(heightEdit_, SIGNAL(valueChanged(double)),  this, SLOT(updateShape()));

  CQSwatch *textSwatch   = new CQSwatch("Text"  , textEdit_);
  CQSwatch *widthSwatch  = new CQSwatch("Width" , widthEdit_ );
  CQSwatch *heightSwatch = new CQSwatch("Height", heightEdit_);

  layout->addWidget(textSwatch);
  layout->addWidget(widthSwatch);
  layout->addWidget(heightSwatch);

  //-----

  lalignButton_  = new CQImageButton(QPixmap(lalign_data ));
  hcalignButton_ = new CQImageButton(QPixmap(hcalign_data));
  ralignButton_  = new CQImageButton(QPixmap(ralign_data ));

  lalignButton_ ->setCheckable(true);
  hcalignButton_->setCheckable(true);
  ralignButton_ ->setCheckable(true);

  lalignButton_ ->setToolTip("Left Align");
  hcalignButton_->setToolTip("Horizontal Center Align");
  ralignButton_ ->setToolTip("Right Align");

  connect(lalignButton_ , SIGNAL(clicked()), this, SLOT(lalignSlot ()));
  connect(hcalignButton_, SIGNAL(clicked()), this, SLOT(hcalignSlot()));
  connect(ralignButton_ , SIGNAL(clicked()), this, SLOT(ralignSlot ()));

  CQSwatch *halignSwatch = new CQSwatch("Align<3>", lalignButton_, hcalignButton_, ralignButton_);

  layout->addWidget(halignSwatch);

  //-----

  talignButton_  = new CQImageButton(QPixmap(talign_data ));
  vcalignButton_ = new CQImageButton(QPixmap(vcalign_data));
  balignButton_  = new CQImageButton(QPixmap(balign_data ));

  talignButton_ ->setCheckable(true);
  vcalignButton_->setCheckable(true);
  balignButton_ ->setCheckable(true);

  talignButton_ ->setToolTip("Top Align");
  vcalignButton_->setToolTip("Vertical Center Align");
  balignButton_ ->setToolTip("Bottom Align");

  connect(talignButton_ , SIGNAL(clicked()), this, SLOT(talignSlot ()));
  connect(vcalignButton_, SIGNAL(clicked()), this, SLOT(vcalignSlot()));
  connect(balignButton_ , SIGNAL(clicked()), this, SLOT(balignSlot ()));

  CQSwatch *valignSwatch = new CQSwatch("Align<3>", talignButton_, vcalignButton_, balignButton_);

  layout->addWidget(valignSwatch);

  //-----

  updateWidgets();
}

void
CQIllustratorCreateTextToolbar::
setSelectedShape(const CQIllustratorShape *shape)
{
  const CQIllustratorTextShape *text = dynamic_cast<const CQIllustratorTextShape *>(shape);

  if (text) {
    qfont_  = CQUtil::toQFont(text->getFont());
    halign_ = text->getHAlign();
    valign_ = text->getVAlign();

    textEdit_->setText(text->getText().c_str());

    updateWidgets();

    const CBBox2D &bbox = text->getBBox();

    setSize(bbox);
  }
  else
    textEdit_->setText("");
}

void
CQIllustratorCreateTextToolbar::
setSize(const CBBox2D &bbox)
{
  double w = bbox.getWidth();
  double h = bbox.getHeight();

  widthEdit_ ->setValue(w);
  heightEdit_->setValue(h);
}

void
CQIllustratorCreateTextToolbar::
updateShape()
{
  CQIllustrator *illustrator = mode_->getIllustrator();

  CQIllustratorTextShape *shape =
    CQIllustratorUtil::getCurrentShape<CQIllustratorTextShape>(illustrator);

  QString str = textEdit_->text();

  if (shape) {
    illustrator->checkoutShape(shape, CQIllustratorData::CHANGE_GEOMETRY);

    CQIllustratorTextShape *text = dynamic_cast<CQIllustratorTextShape *>(shape);

    text->setText(str.toStdString());

    text->setFont(CQUtil::fromQFont(qfont_));

    text->setHAlign(halign_);
    text->setVAlign(valign_);

    const CBBox2D &bbox = text->getBBox();

    double width1  = bbox.getWidth ();
    double height1 = bbox.getHeight();

    double width  = widthEdit_ ->getValue();
    double height = heightEdit_->getValue();

    text->scale(bbox.getCenter(), width/width1, height/height1);

    illustrator->checkinShape(shape, CQIllustratorData::CHANGE_GEOMETRY);
  }

  mode_->setText(str);

  illustrator->redraw();
}

void
CQIllustratorCreateTextToolbar::
updateWidgets()
{
  updateFontWidgets();

  lalignButton_ ->setChecked(halign_ == CHALIGN_TYPE_LEFT);
  hcalignButton_->setChecked(halign_ == CHALIGN_TYPE_CENTER);
  ralignButton_ ->setChecked(halign_ == CHALIGN_TYPE_RIGHT);

  talignButton_ ->setChecked(valign_ == CVALIGN_TYPE_TOP);
  vcalignButton_->setChecked(valign_ == CVALIGN_TYPE_CENTER);
  balignButton_ ->setChecked(valign_ == CVALIGN_TYPE_BOTTOM);
}

void
CQIllustratorCreateTextToolbar::
updateFontWidgets()
{
  int nind = fontCombo_->findText(qfont_.family());

  if (nind >= 0 && nind != font_ind_) {
    font_ind_ = nind;

    fontCombo_->setCurrentIndex(nind);

    QFontDatabase database;

    const QString &family = fontCombo_->itemText(fontCombo_->currentIndex());

    QList<int> sizes = database.pointSizes(family);

    int font_diff     = INT_MAX;
    int font_size     = -1;
    int font_size_ind = -1;

    sizeCombo_->clear();

    for (int i = 0; i < sizes.size(); ++i) {
      int size = sizes[i];

      if (font_size_ == -1)
        font_size_ = size;

      if (abs(font_size_ - size) < font_diff) {
        font_diff     = abs(font_size_ - size);
        font_size     = size;
        font_size_ind = i;
      }

      sizeCombo_->addItem(QString("%1").arg(size));
    }

    if (font_size_ > 0) {
      font_size_ = font_size;

      sizeCombo_->setCurrentIndex(font_size_ind);
    }
  }

  int font_size = qfont_.pointSize();

  if (font_size != font_size_) {
    int ind = sizeCombo_->findText(QString("%1").arg(font_size));

    if (ind >= 0 && ind != sizeCombo_->currentIndex()) {
      sizeCombo_->setCurrentIndex(ind);

      font_size_ = font_size;
    }
  }

  boldButton_  ->setChecked(qfont_.bold());
  italicButton_->setChecked(qfont_.italic());
}

void
CQIllustratorCreateTextToolbar::
fontComboSlot()
{
  updateFontFromWidgets();
}

void
CQIllustratorCreateTextToolbar::
sizeComboSlot()
{
  updateFontFromWidgets();
}

void
CQIllustratorCreateTextToolbar::
boldSlot()
{
  updateFontFromWidgets();
}

void
CQIllustratorCreateTextToolbar::
italicSlot()
{
  updateFontFromWidgets();
}

void
CQIllustratorCreateTextToolbar::
updateFontFromWidgets()
{
  QString name = fontCombo_->itemText(fontCombo_->currentIndex());

  font_size_ = sizeCombo_->itemText(sizeCombo_->currentIndex()).toInt();

  int weight = QFont::Normal;

  if (boldButton_->isChecked())
    weight = QFont::Bold;

  bool italic = italicButton_->isChecked();

  QFont qfont(name, font_size_, weight, italic);

  qfont_ = qfont;

  updateShape();

  updateFontWidgets();
}

void
CQIllustratorCreateTextToolbar::
lalignSlot()
{
  halign_ = CHALIGN_TYPE_LEFT;

  updateShape();
}

void
CQIllustratorCreateTextToolbar::
hcalignSlot()
{
  halign_ = CHALIGN_TYPE_CENTER;

  updateShape();
}

void
CQIllustratorCreateTextToolbar::
ralignSlot()
{
  halign_ = CHALIGN_TYPE_RIGHT;

  updateShape();
}

void
CQIllustratorCreateTextToolbar::
talignSlot()
{
  valign_ = CVALIGN_TYPE_TOP;

  updateShape();
}

void
CQIllustratorCreateTextToolbar::
vcalignSlot()
{
  valign_ = CVALIGN_TYPE_CENTER;

  updateShape();
}

void
CQIllustratorCreateTextToolbar::
balignSlot()
{
  valign_ = CVALIGN_TYPE_BOTTOM;

  updateShape();
}

//------

CQIllustratorCreateTextSizer::
CQIllustratorCreateTextSizer(CQIllustratorCreateTextMode *mode) :
 CQIllustratorModeSizer(mode)
{
  CQIllustrator *illustrator = mode_->getIllustrator();

  ll_handle_ = new CQIllustratorControlPointHandle(illustrator);
  ur_handle_ = new CQIllustratorControlPointHandle(illustrator);

  addHandle(ll_handle_);
  addHandle(ur_handle_);
}

void
CQIllustratorCreateTextSizer::
drawHandles(QPainter *painter, const CQIllustratorShape *shape)
{
  const CQIllustratorTextShape *text = dynamic_cast<const CQIllustratorTextShape *>(shape);

  if (text) {
    CQIllustratorShape::ControlPointList controlPoints;

    text->getControlPoints(controlPoints);

    ll_handle_->draw(text, controlPoints[0], painter);
    ur_handle_->draw(text, controlPoints[1], painter);
  }
}
##concat##CQIllustratorData.cpp
#include <CQIllustratorData.h>
#include <CQIllustratorShape.h>
#include <set>

CQIllustratorData::
CQIllustratorData(CQIllustrator *illustrator) :
 illustrator_(illustrator)
{
  quadTree_ = new QuadTree(CBBox2D(0, 0, 1000, 1000));
}

CQIllustratorData::
~CQIllustratorData()
{
  delete quadTree_;
}

void
CQIllustratorData::
raiseShape(CQIllustratorShape *shape)
{
  shapes_.raise(shape);
}

void
CQIllustratorData::
lowerShape(CQIllustratorShape *shape)
{
  shapes_.lower(shape);
}

void
CQIllustratorData::
addShape(CQIllustratorShape *shape)
{
  shape->setData(this);

  shapes_.push(shape);

  quadTree_->add(shape);

  emit objectCreated(shape);
}

void
CQIllustratorData::
removeShape(CQIllustratorShape *shape)
{
  shapes_.remove(shape);

  quadTree_->remove(shape);

  shape->setData(0);

  emit objectDeleted(shape);
}

void
CQIllustratorData::
checkoutShape(CQIllustratorShape *shape, ChangeType changeType)
{
  if (! shape->getLocked()) {
    emit objectPreModify(shape, changeType);

    quadTree_->remove(shape);

    //const CQIllustratorShape::ShapeList &children = shape->getChildren();

    //CQIllustratorShape::ShapeList::const_iterator pc1, pc2;

    //for (pc1 = children.begin(), pc2 = children.end(); pc1 != pc2; ++pc1) {
    //  const CQIllustratorShape *child = *pc1;

    //  checkoutShape(child, changeType);
    //}
  }

  shape->lockShape();
}

void
CQIllustratorData::
checkinShape(CQIllustratorShape *shape, ChangeType changeType)
{
  shape->unlockShape();

  if (! shape->getLocked()) {
    //const CQIllustratorShape::ShapeList &children = shape->getChildren();

    //CQIllustratorShape::ShapeList::const_iterator pc1, pc2;

    //for (pc1 = children.begin(), pc2 = children.end(); pc1 != pc2; ++pc1) {
    //  const CQIllustratorShape *child = *pc1;

    //  checkinShape(child, changeType);
    //}

    quadTree_->add(shape);

    emit objectPostModify(shape, changeType);
  }
}

void
CQIllustratorData::
getObjectsAt(const CPoint2D &p, ShapeList &shapes) const
{
  QuadTree::DataList dataList;

  quadTree_->getDataAtPoint(p.x, p.y, dataList);

  QuadTree::DataList::const_iterator ps1, ps2;

  for (ps1 = dataList.begin(), ps2 = dataList.end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = *ps1;

    if (shape->getParent()) continue;

    shapes.push_back(shape);
  }
}

CQIllustratorShape *
CQIllustratorData::
getObjectAt(const CPoint2D &p) const
{
  ShapeList shapes;

  getObjectsAt(p, shapes);

  CQIllustratorShape *select_shape = 0;
  double              select_area  = 0.0;

  ShapeList::const_iterator ps1, ps2;

  for (ps1 = shapes.begin(), ps2 = shapes.end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = *ps1;

    double area = shape->getBBox().area();

    if (select_shape == 0 || area < select_area) {
      select_shape = shape;
      select_area  = area;
    }
  }

  return select_shape;
}

void
CQIllustratorData::
getObjectsInside(const CBBox2D &bbox, ShapeList &shapes)
{
  QuadTree::DataList dataList;

  quadTree_->getDataInsideBBox(bbox, dataList);

  QuadTree::DataList::const_iterator ps1, ps2;

  for (ps1 = dataList.begin(), ps2 = dataList.end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = *ps1;

    if (shape->getParent()) continue;

    shapes.push_back(shape);
  }
}

void
CQIllustratorData::
getObjectsTouching(const CBBox2D &bbox, ShapeList &shapes)
{
  QuadTree::DataList dataList;

  quadTree_->getDataTouchingBBox(bbox, dataList);

  QuadTree::DataList::const_iterator ps1, ps2;

  for (ps1 = dataList.begin(), ps2 = dataList.end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = *ps1;

    if (shape->getParent()) continue;

    shapes.push_back(shape);
  }
}

void
CQIllustratorData::
getOrderedObjectsTouching(const CBBox2D &bbox, ShapeList &shapes)
{
  typedef std::set<CQIllustratorShape *> ShapeSet;

  ShapeSet shapeSet;

  QuadTree::DataList dataList;

  quadTree_->getDataTouchingBBox(bbox, dataList);

  QuadTree::DataList::const_iterator ps1, ps2;

  for (ps1 = dataList.begin(), ps2 = dataList.end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = *ps1;

    if (shape->getParent()) continue;

    shapeSet.insert(shape);
  }

  ShapeStack::const_iterator p1, p2;

  for (p1 = shapes_.begin(), p2 = shapes_.end(); p1 != p2; ++p1) {
    CQIllustratorShape *shape = *p1;

    if (shapeSet.find(shape) != shapeSet.end())
      shapes.push_back(shape);
  }
}
##concat##CQIllustratorHandle.cpp
#include <CQIllustratorHandle.h>
#include <CQIllustrator.h>

#include <CQImage.h>
#include <CQUtil.h>

#include <QPainter>

//#include <xpm/control_point.xpm>
//#include <xpm/control_point_active.xpm>

CQIllustratorHandle::
CQIllustratorHandle(CQIllustrator *illustrator) :
 illustrator_(illustrator), style_(RECT_STYLE), active_(false), visible_(true), pos_(0,0)
{
}

void
CQIllustratorHandle::
setImage(const char **strings, uint num_strings,
         const char **active_strings, uint num_active_strings)
{
  image_ = CImageMgrInst->createImage(CImageXPMSrc(strings, num_strings));

  if (active_strings)
    active_image_ = CImageMgrInst->createImage(CImageXPMSrc(active_strings, num_active_strings));
  else
    active_image_ = image_;

  style_ = IMAGE_STYLE;
}

void
CQIllustratorHandle::
setStyle(Style style)
{
  style_ = style;
}

CISize2D
CQIllustratorHandle::
getSize()
{
  if (image_.isValid())
    return CISize2D(image_->getWidth(), image_->getHeight());
  else
    return CISize2D(7, 7);
}

bool
CQIllustratorHandle::
updateActive(const QPointF &p)
{
  bool old_active = active_;

  QPointF p1 = illustrator_->getTransform().map(CQUtil::toQPoint(pos_));

  CISize2D size = getSize();

  QPointF ll = p1 - CQUtil::toQPoint(offset_);
  QPointF ur = QPointF(p1.x() + size.getWidth(), p1.y() + size.getHeight());

  active_ = (p.x() >= ll.x() && p.x() <= ur.x() && p.y() >= ll.y() && p.y() <= ur.y());

  return (old_active != active_);
}

void
CQIllustratorHandle::
setPosition(const CPoint2D &pos)
{
  pos_ = pos;
}

void
CQIllustratorHandle::
draw(QPainter *painter, const CPoint2D &pos, const CIPoint2D &offset)
{
  pos_    = pos;
  offset_ = offset;

  drawI(painter);
}

void
CQIllustratorHandle::
draw(QPainter *painter, const CPoint2D &pos)
{
  CISize2D size = getSize();

  pos_    = pos;
  offset_ = CIPoint2D(size.getWidth()/2, size.getHeight()/2);

  drawI(painter);
}

void
CQIllustratorHandle::
draw(QPainter *painter)
{
  CISize2D size = getSize();

  offset_ = CIPoint2D(size.getWidth()/2, size.getHeight()/2);

  drawI(painter);
}

void
CQIllustratorHandle::
drawI(QPainter *painter)
{
  if (style_ == IMAGE_STYLE && image_.isValid()) {
    QPointF p1 = illustrator_->getTransform().map(CQUtil::toQPoint(pos_));

    QImage image1;

    if (! active_)
      image1 = image_.cast<CQImage>()->getQImage();
    else
      image1 = active_image_.cast<CQImage>()->getQImage();

    QPointF ll = p1 - CQUtil::toQPoint(offset_);

    painter->setWorldMatrixEnabled(false);

    painter->drawImage(ll, image1);

    painter->setWorldMatrixEnabled(true);
  }
  else {
    QPointF p1 = CQUtil::toQPoint(pos_);

    CISize2D size = getSize();

    QPointF po    = illustrator_->getITransform().map(QPointF(0, 0));
    QPointF psize = illustrator_->getITransform().map(QPointF(size.getWidth(), size.getHeight()));

    double pw = fabs(psize.x() - po.x());
    double ph = fabs(psize.y() - po.y());

    QRectF rect(p1.x() - pw/2.0, p1.y() - ph/2.0, pw, ph);

    QBrush brush;

    if (active_) {
      brush = QBrush(QColor(0,255,0));

      painter->setPen(QColor(0,0,0));
    }
    else {
      brush = QBrush(Qt::NoBrush);

      painter->setPen(QColor(80,80,80));
    }

    painter->setBrush(brush);

    if (style_ == RECT_STYLE)
      painter->drawRect(rect);
    else {
      painter->drawEllipse(p1, pw/2.0, ph/2.0);
    }

    painter->drawLine(p1, QPointF(p1.x(), p1.y() + ph/2));
  }
}

//----------

#define IMAGE_DATA(I) I, sizeof(I)/sizeof(char *)

CQIllustratorControlPointHandle::
CQIllustratorControlPointHandle(CQIllustrator *illustrator) :
 CQIllustratorHandle(illustrator), point_(0)
{
  //setImage(IMAGE_DATA(control_point_data), IMAGE_DATA(control_point_active_data));
}

CQIllustratorControlPointHandle::
~CQIllustratorControlPointHandle()
{
  delete point_;
}

void
CQIllustratorControlPointHandle::
updatePoint(CQIllustratorShape *shape, const CPoint2D &point)
{
  assert(point_);

  point_->setPoint(shape, point);
}

void
CQIllustratorControlPointHandle::
draw(const CQIllustratorShape *shape, CQIllustratorShapeControlPoint *point, QPainter *painter)
{
  assert(point);

  delete point_;

  point_ = point->dup();

  pos_ = point_->getPoint(shape);

  CQIllustratorHandle::draw(painter);
}
##concat##CQIllustratorInfo.cpp
#include <CQIllustratorInfo.h>
#include <CQIllustratorCanvas.h>
#include <CQIllustratorShape.h>

#include <QVBoxLayout>
#include <QLabel>

#include <CQUtil.h>

CQIllustratorInfo::
CQIllustratorInfo(CQIllustratorCanvas *canvas) :
 QWidget(canvas), canvas_(canvas)
{
  setAutoFillBackground(true);

  CQUtil::setBackground(this, QColor(255,255,204));

  QVBoxLayout *layout = new QVBoxLayout(this);

  label_ = new QLabel("Info");

  layout->addWidget(label_);

  hide();
}

void
CQIllustratorInfo::
setShape(const CQIllustratorShape *shape)
{
  const CBBox2D &bbox = shape->getBBox();

  QStringList lines;

  lines.push_back(QString("<b>%1</b>: %2").
    arg(shape->getClassName()).arg(shape->getName().c_str()));
  lines.push_back(QString("<b>BBox</b>: {{%1 %2} {%3 %4}}").
    arg(bbox.getXMin()).arg(bbox.getYMin()).arg(bbox.getXMax()).arg(bbox.getYMax()));

  int num_lines = lines.length();

  QString text;

  text += "<small>";

  for (int i = 0; i < num_lines; ++i) {
    if (i > 0) text += "<br>";

    text += lines[i];
  }

  text += "</small>";

  label_->setText(text);
}
##concat##CQIllustratorLayer.cpp
#include <CQIllustratorLayer.h>
#include <CQIllustratorData.h>
#include <CStrUtil.h>
#include <QString>

CQIllustratorLayer::
CQIllustratorLayer(CQIllustratorLayerStack *stack, uint id) :
 stack_(stack), id_(id)
{
  name_ = QString("Layer%1").arg(id_).toStdString();

  data_ = new CQIllustratorData(stack->getIllustrator());

  connect(data_, SIGNAL(objectPostModify(CQIllustratorShape *, ChangeType)),
          this, SIGNAL(objectPostModify(CQIllustratorShape *, ChangeType)));
}

CQIllustratorLayer::
~CQIllustratorLayer()
{
  delete data_;
}

void
CQIllustratorLayer::
setName(const std::string &name)
{
  name_ = name;
}

//--------

CQIllustratorLayerStack::
CQIllustratorLayerStack(CQIllustrator *illustrator) :
 illustrator_(illustrator), id_(0), current_(0)
{
  addLayer();
}

uint
CQIllustratorLayerStack::
getCurrent() const
{
  return current_;
}

CQIllustratorLayer *
CQIllustratorLayerStack::
getCurrentLayer() const
{
  return getLayer(getCurrent());
}

CQIllustratorData *
CQIllustratorLayerStack::
getCurrentData() const
{
  return getCurrentLayer()->getData();
}

uint
CQIllustratorLayerStack::
addLayer(const std::string &name)
{
  ++id_;

  CQIllustratorLayer *layer = new CQIllustratorLayer(this, id_);

  connect(layer, SIGNAL(objectPostModify(CQIllustratorShape *, ChangeType)),
          this, SIGNAL(objectPostModify(CQIllustratorShape *, ChangeType)));

  if (name != "")
    layer->setName(name);

  layerMap_[id_] = layer;

  layerStack_.push_back(id_);

  if (! current_)
    current_ = id_;

  emit layersModified();

  return id_;
}

void
CQIllustratorLayerStack::
deleteLayer(uint id)
{
  assert(layerStack_.size() > 1);

  LayerMap::iterator p = layerMap_.find(id);
  assert(p != layerMap_.end());

  CQIllustratorLayer *layer = (*p).second;

  layerMap_.erase(p);

  layerStack_.remove(id);

  delete layer;

  emit layersModified();
}

CQIllustratorLayer *
CQIllustratorLayerStack::
getLayer(uint id) const
{
  LayerMap::const_iterator p = layerMap_.find(id);
  assert(p != layerMap_.end());

  return (*p).second;
}

void
CQIllustratorLayerStack::
setLayer(const std::string &name)
{
  LayerStack::const_iterator p1, p2;

  for (p1 = layerStack_.begin(), p2 = layerStack_.end(); p1 != p2; ++p1) {
    uint id = *p1;

    CQIllustratorLayer *layer = getLayer(id);

    if (layer->getName() == name) {
      current_ = id;

      emit layerChanged();

      return;
    }
  }
}
##concat##CQIllustratorMode.cpp
#include <CQIllustratorMode.h>
#include <CQIllustrator.h>
#include <CQIllustratorHandle.h>
#include <CQIllustratorToolbar.h>
#include <CQIllustratorShapeDrawer.h>
#include <CQUtil.h>

#include <QBitmap>
#include <QPainter>
#include <QMouseEvent>
#include <QStackedWidget>

#include <xpm/selected_point.xpm>
#include <xpm/selected_hline.xpm>
#include <xpm/selected_vline.xpm>

#define IMAGE_DATA(I) I, sizeof(I)/sizeof(char *)

CQIllustratorMode::
CQIllustratorMode(CQIllustrator *illustrator, uint id) :
 illustrator_(illustrator), parentMode_(0), id_(id), menuItem_(0),
 editMode_(CREATE_MODE), stack_(0), pressed_(false), moving_(false), dragging_(false)
{
}

CQIllustratorMode::
CQIllustratorMode(CQIllustratorMode *parentMode, uint id) :
 illustrator_(parentMode->getIllustrator()), parentMode_(parentMode), id_(id), menuItem_(0),
 editMode_(CREATE_MODE), pressed_(false), moving_(false), dragging_(false)
{
}

void
CQIllustratorMode::
init()
{
  toolbar_ = createToolbar();

  if (toolbar_)
    illustrator_->addModeToolbar(this, toolbar_);

  sizer_ = createSizer();

  connect(illustrator_, SIGNAL(selectionChanged()), this, SLOT(selectionSlot()));
}

CQIllustratorModeSizer *
CQIllustratorMode::
createSizer()
{
  return 0;
}

void
CQIllustratorMode::
setCursor(const uchar *bits, const uchar *mask, int xo, int yo)
{
  cursor_ = QCursor(QBitmap::fromData(QSize(16,16), bits),
                    QBitmap::fromData(QSize(16,16), mask),
                    xo, yo);
}

QCursor
CQIllustratorMode::
getCursor() const
{
  return cursor_;
}

void
CQIllustratorMode::
setStack(QStackedWidget *stack)
{
  stack_ = stack;
}

void
CQIllustratorMode::
setEditMode(EditMode editMode)
{
  editMode_ = editMode;
}

//----------

void
CQIllustratorMode::
mousePress(const MouseEvent &e)
{
  if (e.event->getButton() == CBUTTON_RIGHT) return;

  pressed_ = true;
  moving_  = false;

  press_ppos_ = e.pixel;
  press_wpos_ = e.window;

  prev_ppos_  = press_ppos_;
  prev_wpos_  = press_wpos_;

  curr_ppos_  = press_ppos_;
  curr_wpos_  = press_wpos_;

  press_wpos_ = CQUtil::toQPoint(illustrator_->snapPoint(CQUtil::fromQPoint(press_wpos_)));

  handleMousePress(e);
}

void
CQIllustratorMode::
mouseRelease(const MouseEvent &e)
{
  if (e.event->getButton() == CBUTTON_RIGHT) return;

  pressed_ = false;

  release_ppos_ = e.pixel;
  release_wpos_ = e.window;

  release_wpos_ = CQUtil::toQPoint(illustrator_->snapPoint(CQUtil::fromQPoint(release_wpos_)));

  handleMouseRelease(e);
}

void
CQIllustratorMode::
mouseDrag(const MouseEvent &e)
{
  if (e.event->getButton() == CBUTTON_RIGHT) return;

  prev_ppos_ = curr_ppos_;

  curr_ppos_ = e.pixel;
  curr_wpos_ = e.window;

  curr_wpos_ = CQUtil::toQPoint(illustrator_->snapPoint(CQUtil::fromQPoint(curr_wpos_)));

  if (! moving_) {
    int dx = abs(curr_ppos_.x() - press_ppos_.x());
    int dy = abs(curr_ppos_.y() - press_ppos_.y());

    if (dx >= 4 || dy >= 4)
      moving_ = true;
  }

  handleMouseDrag(e);

  prev_wpos_ = curr_wpos_;
}

void
CQIllustratorMode::
mouseMove(const MouseEvent &e)
{
  prev_ppos_ = curr_ppos_;
  prev_wpos_ = curr_wpos_;

  curr_ppos_ = e.pixel;
  curr_wpos_ = e.window;

  handleMouseMove(e);
}

bool
CQIllustratorMode::
keyPress(const KeyEvent &e)
{
  return handleKeyPress(e);
}

void
CQIllustratorMode::
handleMousePress(const MouseEvent &)
{
  if (sizer_) {
    dragging_ = sizer_->isActive();

    if (dragging_) {
      addSelectionToSandbox();

      illustrator_->redraw();
    }
  }

  prev_wpos_ = press_wpos_;
}

void
CQIllustratorMode::
handleMouseMove(const MouseEvent &e)
{
  if (sizer_) {
    sizer_->updateActive(e.window);

    illustrator_->redrawOverlay();
  }
}

void
CQIllustratorMode::
handleMouseRelease(const MouseEvent &)
{
  dragging_ = false;

  illustrator_->redraw();
}

bool
CQIllustratorMode::
handleKeyPress(const KeyEvent &e)
{
  if (sizer_) {
    if (sizer_->handleKeyPress(e))
      return true;
  }

  CKeyType key = e.event->getType();

  if (key == CKEY_TYPE_Colon)
    illustrator_->showConsole();

  return false;
}

void
CQIllustratorMode::
selectControlPoint(const MouseEvent &e)
{
  CPoint2D p2 = CQUtil::fromQPoint(release_wpos_);

  CQIllustratorSelectedShapes *selection = illustrator_->getSelection();

  if (selection->size() == 1) {
    CQIllustratorSelectedShape &sshape = selection->front();

    CQIllustratorShape *shape = sshape.getShape();

    (void) illustrator_->selectPointAt(shape, p2, getControlType(), e.event->isControlKey(),
                                       e.event->isShiftKey());

    CQIllustratorSelectedShape &sshape1 = selection->front();

    sizer_->updateSelectionHandles(sshape1);
  }

  illustrator_->getSandbox()->clear();
}

//----------

void
CQIllustratorMode::
addSelectionToSandbox()
{
  illustrator_->getSandbox()->addSelection();
}

//----------

void
CQIllustratorMode::
menuItemSlot()
{
  illustrator_->setMode((CQIllustrator::Mode) id_);
}

void
CQIllustratorMode::
selectionSlot()
{
  CQIllustratorSelectedShapes *selection = illustrator_->getSelection();

  uint num_shapes = selection->size();

  if      (num_shapes == 0) {
    setSelectedShape(0);

    setSelectedShapePoint(0, 0);
  }
  else if (num_shapes == 1) {
    const CQIllustratorSelectedShape &sshape = selection->front();

    const CQIllustratorShape *shape = sshape.getShape();

    setSelectedShape(shape);

    uint num_points = sshape.numPoints();

    if      (num_points == 0)
      setSelectedShapePoint(shape, 0);
    else if (num_points == 1) {
      const CQIllustratorShapeControlPoint *point = sshape.getPoint(0);

      setSelectedShapePoint(shape, point);
    }
    else
      setSelectedShapePoint(shape, 0);
  }
  else {
    setSelectedShape(0);

    setSelectedShapePoint(0, 0);
  }
}

void
CQIllustratorMode::
showToolbar(bool show)
{
  if (parentMode_)
    parentMode_->showToolbar(show);
  else if (stack_) {
    if (show)
      stack_->setCurrentWidget(getToolbar());
  }
}

void
CQIllustratorMode::
moveCurrent(const CPoint2D &d)
{
  bool snap_x = (fabs(d.x) > 0);
  bool snap_y = (fabs(d.y) > 0);

  illustrator_->startUndoGroup("Move Current");

  CQIllustratorSelectedShapes *selection = illustrator_->getSelection();

  CQIllustratorSelectedShapes::iterator ps1, ps2;

  for (ps1 = selection->begin(), ps2 = selection->end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = (*ps1).getShape();

    if (shape->getFixed()) continue;

    const CBBox2D &bbox = shape->getBBox();

    CPoint2D ll = bbox.getLL() + d;

    if (snap_x) ll.x = CMathGen::Round(ll.x);
    if (snap_y) ll.y = CMathGen::Round(ll.y);

    shape->moveTo(ll);
  }

  illustrator_->endUndoGroup();

  illustrator_->redraw();
}

void
CQIllustratorMode::
moveCurrentPoint(const CPoint2D &d)
{
  bool snap_x = (fabs(d.x) > 0);
  bool snap_y = (fabs(d.y) > 0);

  illustrator_->startUndoGroup("Move Current Point");

  CQIllustratorSelectedShapes *selection = illustrator_->getSelection();

  CQIllustratorSelectedShapes::iterator ps1, ps2;

  for (ps1 = selection->begin(), ps2 = selection->end(); ps1 != ps2; ++ps1) {
    const CQIllustratorSelectedShape &sshape = *ps1;

    const CQIllustratorShape *shape = sshape.getShape();

    if (shape->getFixed()) continue;

    uint num_points = sshape.numPoints();

    if (num_points == 0) continue;

    CQIllustratorSelectedShape &sshape1 =
      selection->checkoutShape(sshape, getChangeType());

    for (uint i = 0; i < num_points; ++i) {
      CQIllustratorShapeControlPoint *point = sshape1.getPoint(i);

      CPoint2D p = point->getPoint(sshape.getShape());

      p += d;

      if (snap_x) p.x = CMathGen::Round(p.x);
      if (snap_y) p.y = CMathGen::Round(p.y);

      point->setPoint(sshape1.getShape(), p);
    }

    selection->checkinShape(sshape, getChangeType());
  }

  illustrator_->endUndoGroup();

  illustrator_->redraw();
}

void
CQIllustratorMode::
resizeCurrent(const CBBox2D &d)
{
  bool snap_x1 = (fabs(d.getLL().x) > 0);
  bool snap_y1 = (fabs(d.getLL().y) > 0);
  bool snap_x2 = (fabs(d.getUR().x) > 0);
  bool snap_y2 = (fabs(d.getUR().y) > 0);

  illustrator_->startUndoGroup("Resize Current");

  CQIllustratorSelectedShapes *selection = illustrator_->getSelection();

  CQIllustratorSelectedShapes::iterator ps1, ps2;

  for (ps1 = selection->begin(), ps2 = selection->end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = (*ps1).getShape();

    if (shape->getFixed()) continue;

    const CBBox2D &bbox = shape->getBBox();

    CPoint2D ll = bbox.getLL() + d.getLL();
    CPoint2D ur = bbox.getUR() + d.getUR();

    if (snap_x1) ll.x = CMathGen::Round(ll.x);
    if (snap_y1) ll.y = CMathGen::Round(ll.y);
    if (snap_x2) ur.x = CMathGen::Round(ur.x);
    if (snap_y2) ur.y = CMathGen::Round(ur.y);

    shape->setBBox(CBBox2D(ll, ur));
  }

  illustrator_->endUndoGroup();

  illustrator_->redraw();
}

void
CQIllustratorMode::
deleteCurrent()
{
  illustrator_->deleteSelectedShapes();
}

bool
CQIllustratorMode::
cancel()
{
  pressed_  = false;
  moving_   = false;
  dragging_ = false;

  return true;
}

void
CQIllustratorMode::
escape()
{
  pressed_  = false;
  moving_   = false;
  dragging_ = false;
}

void
CQIllustratorMode::
drawSelection(CQIllustratorShapeDrawer *drawer)
{
  CQIllustratorSelectedShapes *selection = illustrator_->getSelection();

  CQIllustratorSelectedShapes::iterator ps1, ps2;

  for (ps1 = selection->begin(), ps2 = selection->end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = (*ps1).getShape();

    if (! shape->getVisible()) continue;

    shape->drawSelect(drawer);
  }
}

void
CQIllustratorMode::
drawOverlay(CQIllustratorShapeDrawer *)
{
}

void
CQIllustratorMode::
setSelectedShape(const CQIllustratorShape *shape)
{
  if (toolbar_)
    toolbar_->setSelectedShape(shape);
}

void
CQIllustratorMode::
setSelectedShapePoint(const CQIllustratorShape *shape,
                      const CQIllustratorShapeControlPoint *point)
{
  if (toolbar_)
    toolbar_->setSelectedShapePoint(shape, point);
}

//------

CQIllustratorMode::MouseEvent::
MouseEvent(QMouseEvent *e, const QTransform &transform)
{
  pixel  = e->pos();
  window = transform.map(QPointF(pixel));
  event  = CQUtil::convertEvent(e);
}

CQIllustratorMode::KeyEvent::
KeyEvent(QKeyEvent *e, const QPoint &pos, const QTransform &transform)
{
  pixel  = pos;
  window = transform.map(QPointF(pixel));
  event  = CQUtil::convertEvent(e);
}

//------

CQIllustratorModeSizer::
CQIllustratorModeSizer(CQIllustratorMode *mode) :
 mode_(mode)
{
}

void
CQIllustratorModeSizer::
addHandle(CQIllustratorControlPointHandle *handle)
{
  controlPointHandles_.push_back(handle);
}

void
CQIllustratorModeSizer::
addHandle(CQIllustratorHandle *handle)
{
  handles_.push_back(handle);
}

void
CQIllustratorModeSizer::
removeHandle(CQIllustratorControlPointHandle *)
{
  CQIllustratorControlPointHandle *handle = controlPointHandles_.back();

  controlPointHandles_.pop_back();

  delete handle;
}

void
CQIllustratorModeSizer::
removeHandle(CQIllustratorHandle *)
{
  CQIllustratorHandle *handle = handles_.back();

  handles_.pop_back();

  delete handle;
}

void
CQIllustratorModeSizer::
draw(QPainter *painter, const CQIllustratorShape *shape)
{
  //transform_ = painter->worldTransform();
  transform_ = painter->transform();

  drawHandles(painter, shape);
}

bool
CQIllustratorModeSizer::
updateActive(const QPointF &p)
{
  QPointF p1 = transform_.map(p);

  uint numControlPointHandles = controlPointHandles_.size();

  for (uint i = 0; i < numControlPointHandles; ++i)
    if (controlPointHandles_[i]->updateActive(p1))
      return true;

  uint numHandles = handles_.size();

  for (uint i = 0; i < numHandles; ++i)
    if (handles_[i]->updateActive(p1))
      return true;

  return false;
}

void
CQIllustratorModeSizer::
updatePoint(CQIllustratorShape *shape, const QPointF &p)
{
  CPoint2D p1 = CQUtil::fromQPoint(p);

  uint numControlPointHandles = controlPointHandles_.size();

  for (uint i = 0; i < numControlPointHandles; ++i) {
    if (controlPointHandles_[i]->getActive()) {
      controlPointHandles_[i]->updatePoint(shape, p1);
      break;
    }
  }

  mode_->getToolbar()->setSelectedShape(shape);
}

bool
CQIllustratorModeSizer::
isActive() const
{
  uint numControlPointHandles = controlPointHandles_.size();

  for (uint i = 0; i < numControlPointHandles; ++i)
    if (controlPointHandles_[i]->getActive())
      return true;

  uint numHandles = handles_.size();

  for (uint i = 0; i < numHandles; ++i)
    if (handles_[i]->getActive())
      return true;

  return false;
}

void
CQIllustratorModeSizer::
drawHandles(QPainter *, const CQIllustratorShape *)
{
}

void
CQIllustratorModeSizer::
drawSelectionHandles(QPainter *painter, const CQIllustratorSelectedShape &sshape)
{
  const CQIllustratorShape *shape = sshape.getShape();

  uint num_points = sshape.numPoints();

  updatePointSelectionHandles(num_points);

  for (uint i = 0; i < num_points; ++i) {
    const CQIllustratorShapeControlPoint *point = sshape.getPoint(i);

    CPoint2D p = point->getPoint(shape);

    pointSelectionHandles_[i]->setPosition(p);

    pointSelectionHandles_[i]->draw(painter);
  }

  uint num_lines = sshape.numLines();

  updateLineSelectionHandles(num_lines);

  for (uint i = 0; i < num_lines; ++i) {
    const CQIllustratorShapeControlLine *line = sshape.getLine(i);

    CLine2D l = line->getLine(shape);

    double dx = fabs(l.start().x - l.end().x);
    double dy = fabs(l.start().y - l.end().y);

    lineSelectionHandles_[i]->setPosition((l.start() + l.end())/2);

    if (dx > dy)
      lineSelectionHandles_[i]->setImage(IMAGE_DATA(selected_hline_data));
    else
      lineSelectionHandles_[i]->setImage(IMAGE_DATA(selected_vline_data));

    lineSelectionHandles_[i]->draw(painter);
  }
}

void
CQIllustratorModeSizer::
updateSelectionHandles(const CQIllustratorSelectedShape &sshape)
{
  const CQIllustratorShape *shape = sshape.getShape();

  uint num_points = sshape.numPoints();

  updatePointSelectionHandles(num_points);

  for (uint i = 0; i < num_points; ++i) {
    const CQIllustratorShapeControlPoint *spoint = sshape.getPoint(i);

    CPoint2D p = spoint->getPoint(shape);

    pointSelectionHandles_[i]->setPosition(p);
  }

  uint num_lines = sshape.numLines();

  updateLineSelectionHandles(num_lines);

  for (uint i = 0; i < num_lines; ++i) {
    const CQIllustratorShapeControlLine *sline = sshape.getLine(i);

    CLine2D l = sline->getLine(shape);

    double dx = fabs(l.start().x - l.end().x);
    double dy = fabs(l.start().y - l.end().y);

    lineSelectionHandles_[i]->setPosition((l.start() + l.end())/2);

    if (dx > dy)
      lineSelectionHandles_[i]->setImage(IMAGE_DATA(selected_hline_data));
    else
      lineSelectionHandles_[i]->setImage(IMAGE_DATA(selected_vline_data));
  }
}

void
CQIllustratorModeSizer::
updatePointSelectionHandles(uint num)
{
  CQIllustrator *illustrator = mode_->getIllustrator();

  while (pointSelectionHandles_.size() < num) {
    CQIllustratorHandle *selectionHandle = new CQIllustratorHandle(illustrator);

    selectionHandle->setImage(IMAGE_DATA(selected_point_data));

    pointSelectionHandles_.push_back(selectionHandle);
  }
}

void
CQIllustratorModeSizer::
updateLineSelectionHandles(uint num)
{
  CQIllustrator *illustrator = mode_->getIllustrator();

  while (lineSelectionHandles_.size() < num) {
    CQIllustratorHandle *selectionHandle = new CQIllustratorHandle(illustrator);

    selectionHandle->setImage(IMAGE_DATA(selected_hline_data));

    lineSelectionHandles_.push_back(selectionHandle);
  }
}

bool
CQIllustratorModeSizer::
handleKeyPress(const KeyEvent &e)
{
  CKeyType key = e.event->getType();

  if (key == CKEY_TYPE_Up   || key == CKEY_TYPE_Down ||
      key == CKEY_TYPE_Left || key == CKEY_TYPE_Right) {
    CQIllustrator *illustrator = mode_->getIllustrator();

    CQIllustratorSelectedShapes *selection = illustrator->getSelection();

    if (selection->size() != 1) return false;

    const CQIllustratorSelectedShape &sshape = selection->front();

    uint num_points = sshape.numPoints();

    if (num_points > 0) {
      bool snap_x = false;
      bool snap_y = false;

      CPoint2D d;

      if      (key == CKEY_TYPE_Up   ) { d = CPoint2D( 0,  1); snap_y = true; }
      else if (key == CKEY_TYPE_Down ) { d = CPoint2D( 0, -1); snap_y = true; }
      else if (key == CKEY_TYPE_Left ) { d = CPoint2D(-1,  0); snap_x = true; }
      else if (key == CKEY_TYPE_Right) { d = CPoint2D( 1,  0); snap_x = true; }

      CQIllustratorSelectedShape &sshape1 =
        selection->checkoutShape(sshape, mode_->getChangeType());

      for (uint i = 0; i < num_points; ++i) {
        CQIllustratorShapeControlPoint *point = sshape1.getPoint(i);

        CPoint2D p = point->getPoint(sshape.getShape());

        p += d;

        if (snap_x) p.x = CMathGen::Round(p.x);
        if (snap_y) p.y = CMathGen::Round(p.y);

        point->setPoint(sshape1.getShape(), p);
      }

      selection->checkinShape(sshape, mode_->getChangeType());
    }

    uint num_lines = sshape.numLines();

    if (num_lines > 0) {
      bool snap_x = false;
      bool snap_y = false;

      CPoint2D d;

      if      (key == CKEY_TYPE_Up   ) { d = CPoint2D( 0,  1); snap_y = true; }
      else if (key == CKEY_TYPE_Down ) { d = CPoint2D( 0, -1); snap_y = true; }
      else if (key == CKEY_TYPE_Left ) { d = CPoint2D(-1,  0); snap_x = true; }
      else if (key == CKEY_TYPE_Right) { d = CPoint2D( 1,  0); snap_x = true; }

      CQIllustratorSelectedShape &sshape1 =
        selection->checkoutShape(sshape, mode_->getChangeType());

      for (uint i = 0; i < num_lines; ++i) {
        CQIllustratorShapeControlLine *line = sshape1.getLine(i);

        CLine2D l = line->getLine(sshape.getShape());

        CPoint2D p1 = l.start();
        CPoint2D p2 = l.end  ();

        p1 += d;
        p2 += d;

        if (snap_x) { p1.x = CMathGen::Round(p1.x); p2.x = CMathGen::Round(p2.x); }
        if (snap_y) { p1.y = CMathGen::Round(p1.y); p2.y = CMathGen::Round(p2.y); }

        line->setLine(sshape1.getShape(), CLine2D(p1, p2));
      }

      selection->checkinShape(sshape, mode_->getChangeType());
    }

    return true;
  }

  return false;
}
##concat##CQIllustratorOffsetPathMode.cpp
#include <CQIllustratorOffsetPathMode.h>
#include <CQIllustrator.h>
#include <CQIllustratorHandle.h>
#include <CQIllustratorShapeDrawer.h>

#include <QPainter>
#include <QHBoxLayout>

#include <CQMenu.h>
#include <CQUtil.h>
#include <CQPointEdit.h>
#include <CQRealEdit.h>
#include <CQSwatch.h>

#include <xpm/offset_path.xpm>

#include <cursors/rect.xbm>
#include <cursors/rectmask.xbm>

CQIllustratorOffsetPathMode::
CQIllustratorOffsetPathMode(CQIllustrator *illustrator) :
 CQIllustratorMode(illustrator, CQIllustrator::MODE_OFFSET_PATH), w_(0.0)
{
  setCursor(rect_bits, rectmask_bits, 2, 2);
}

CQIllustratorOffsetPathToolbar *
CQIllustratorOffsetPathMode::
createToolbar()
{
  toolbar_ = new CQIllustratorOffsetPathToolbar(this);

  return toolbar_;
}

CQIllustratorOffsetPathSizer *
CQIllustratorOffsetPathMode::
createSizer()
{
  sizer_ = new CQIllustratorOffsetPathSizer(this);

  return sizer_;
}

CQMenuItem *
CQIllustratorOffsetPathMode::
createMenuItem(CQMenu *menu)
{
  menuItem_ = new CQMenuItem(menu, "&Offset Path", CQMenuItem::CHECKABLE);

  menuItem_->setStatusTip("Offset Path");
  menuItem_->setXPMIcon(offset_path_data);

  connect(menuItem_->getAction(), SIGNAL(toggled(bool)), this, SLOT(menuItemSlot()));

  return menuItem_;
}

void
CQIllustratorOffsetPathMode::
handleMouseRelease(const MouseEvent &e)
{
  //CPoint2D p2 = CQUtil::fromQPoint(release_wpos_);

  if (dragging_) {
    if (! moving_) {
      selectControlPoint(e);
    }
    // dragging finished so commit
    else {
      illustrator_->getSandbox()->clear();

      CQIllustratorSelectedShapes *selection = illustrator_->getSelection();

      if (selection->size() == 1) {
        CQIllustratorShape *shape = selection->front().getShape();

        CPathShapePartList parts;

        if (! shape->getPath(parts)) return;

        CPathShapePartList parts1;

        parts.offsetPath(w_, shape->getCenter(), parts1);

        CPathShape *pshape = illustrator_->createPathShape();

        pshape->setParts(parts1);

        pshape->setStroke(shape->getStroke());
        pshape->setFill  (shape->getFill ());

        illustrator_->addShape(pshape);

        illustrator_->setSelectShape(pshape);
      }
    }
  }
  // not dragging so do a select
  else {
    CPoint2D p1 = CQUtil::fromQPoint(press_wpos_);

    // point click - select at point
    if (! moving_) {
      (void) illustrator_->selectAt(p1, e.event->isControlKey(), e.event->isShiftKey());
    }
    // drag
    else {
    }
  }

  dragging_ = false;

  illustrator_->redraw();
}

void
CQIllustratorOffsetPathMode::
handleMouseDrag(const MouseEvent &e)
{
  if (dragging_) {
    CQIllustratorShape *shape = illustrator_->getSandbox()->frontShape();

    sizer_->updatePoint(shape, e.window);
  }
  else {
  }

  illustrator_->redrawOverlay();
}

void
CQIllustratorOffsetPathMode::
addSelectionToSandbox()
{
  illustrator_->getSandbox()->addSelectionPath();
}

void
CQIllustratorOffsetPathMode::
drawOverlay(CQIllustratorShapeDrawer *drawer)
{
  QPainter *painter = drawer->getPainter();

  if (! dragging_) {
    // draw rubber band
    if (pressed_) {
      CPoint2D p1 = CQUtil::fromQPoint(press_wpos_);
      CPoint2D p2 = CQUtil::fromQPoint(curr_wpos_);

      CBBox2D bbox(p1, p2);

      QPen pen;

      pen.setColor(QColor(0,0,0));
      pen.setStyle(Qt::DashLine);

      painter->setPen(pen);
      painter->setBrush(Qt::NoBrush);

      painter->drawRect(CQUtil::toQRect(bbox));
    }

    //------

    // draw handles for single selected shape
    CQIllustratorSelectedShapes *selection = illustrator_->getSelection();

    if (selection->size() == 1) {
      const CQIllustratorSelectedShape &sshape = selection->front();

      const CQIllustratorShape *shape = sshape.getShape();

      sizer_->draw(painter, shape);

      sizer_->drawSelectionHandles(painter, sshape);
    }
  }
  else {
    CQIllustratorShape *shape = illustrator_->getSandbox()->frontShape();

    sizer_->draw(painter, shape);
  }
}

void
CQIllustratorOffsetPathMode::
setSelectedShape(CQIllustratorShape *shape)
{
  sizer_->setSelectedShape(shape);

  CQIllustratorMode::setSelectedShape(shape);
}

void
CQIllustratorOffsetPathMode::
setWidth(double w)
{
  w_ = w;

  toolbar_->setWidth(w_);
}

//------------

CQIllustratorOffsetPathToolbar::
CQIllustratorOffsetPathToolbar(CQIllustratorOffsetPathMode *mode) :
 CQIllustratorToolbar(mode), mode_(mode)
{
}

QIcon
CQIllustratorOffsetPathToolbar::
getIcon()
{
  return QIcon(QPixmap(offset_path_data));
}

void
CQIllustratorOffsetPathToolbar::
addWidgets()
{
  QBoxLayout *layout = qobject_cast<QBoxLayout *>(CQIllustratorToolbar::layout());

  //-----

  widthEdit_ = new CQRealEdit(0.0);

  widthEdit_->setFocusPolicy(Qt::ClickFocus);

  connect(widthEdit_, SIGNAL(valueChanged(double)), this, SLOT(updateShape()));

  CQSwatch *widthSwatch = new CQSwatch("Width", widthEdit_ );

  layout->addWidget(widthSwatch);

  widthEdit_->setEnabled(false);
}

void
CQIllustratorOffsetPathToolbar::
setSelectedShape(const CQIllustratorShape *shape)
{
  widthEdit_->setEnabled(shape != 0);

  widthEdit_->setValue(0.0);
}

void
CQIllustratorOffsetPathToolbar::
updateShape()
{
  CQIllustrator *illustrator = mode_->getIllustrator();

  CQIllustratorShape *shape =
    CQIllustratorUtil::getCurrentShape<CQIllustratorShape>(illustrator);

  if (shape) {
    double width = widthEdit_->getValue();

    CPathShapePartList parts;

    if (! shape->getPath(parts)) return;

    CPathShapePartList parts1;

    parts.offsetPath(width, shape->getCenter(), parts1);

    CPathShape *pshape = illustrator->createPathShape();

    pshape->setParts(parts1);

    pshape->setStroke(shape->getStroke());
    pshape->setFill  (shape->getFill ());

    illustrator->addShape(pshape);

    illustrator->setSelectShape(pshape);
  }

  illustrator->redraw();
}

void
CQIllustratorOffsetPathToolbar::
setWidth(double w)
{
  widthEdit_->setValue(w);
}

//------

CQIllustratorOffsetPathSizer::
CQIllustratorOffsetPathSizer(CQIllustratorOffsetPathMode *mode) :
 CQIllustratorModeSizer(mode), shape_(0)
{
  CQIllustrator *illustrator = mode_->getIllustrator();

  width_handle_ = new CQIllustratorHandle(illustrator);

  addHandle(width_handle_);
}

void
CQIllustratorOffsetPathSizer::
setSelectedShape(CQIllustratorShape *shape)
{
  delete shape_;

  if (shape)
    shape_ = shape->dup();
  else
    shape_ = 0;

  if (shape_) {
    const CBBox2D &bbox = shape_->getBBox();

    width_handle_->setPosition(bbox.getUL());
  }
  else
    width_handle_->setPosition(CPoint2D(0, 0));
}

void
CQIllustratorOffsetPathSizer::
updatePoint(CQIllustratorShape *shape, const QPointF &p)
{
  if (! shape_) return;

  CPathShape *path = dynamic_cast<CPathShape *>(shape);

  if (! path) return;

  width_handle_->setPosition(CQUtil::fromQPoint(p));

  CPathShapePartList parts;

  if (! shape_->getPath(parts)) return;

  const CBBox2D &bbox = shape_->getBBox();

  double w = bbox.getXMin() - p.x();

  dynamic_cast<CQIllustratorOffsetPathMode *>(mode_)->setWidth(w);

  CPathShapePartList parts1;

  parts.offsetPath(w, shape_->getCenter(), parts1);

  path->setParts(parts1);
}

void
CQIllustratorOffsetPathSizer::
drawHandles(QPainter *painter, const CQIllustratorShape *)
{
  width_handle_->draw(painter);
}
##concat##CQIllustratorPanMode.cpp
#include <CQIllustratorPanMode.h>
#include <CQIllustrator.h>

#include <CQMenu.h>

#include <xpm/pan.xpm>

CQIllustratorPanMode::
CQIllustratorPanMode(CQIllustrator *illustrator) :
 CQIllustratorMode(illustrator, CQIllustrator::MODE_PAN)
{
}

CQIllustratorPanToolbar *
CQIllustratorPanMode::
createToolbar()
{
  toolbar_ = new CQIllustratorPanToolbar(this);

  return toolbar_;
}

CQMenuItem *
CQIllustratorPanMode::
createMenuItem(CQMenu *menu)
{
  menuItem_ = new CQMenuItem(menu, "&Pan", CQMenuItem::CHECKABLE);

  menuItem_->setStatusTip("Pan Display");
  menuItem_->setXPMIcon(pan_data);

  connect(menuItem_->getAction(), SIGNAL(toggled(bool)), this, SLOT(menuItemSlot()));

  return menuItem_;
}

void
CQIllustratorPanMode::
handleMousePress(const MouseEvent &)
{
}

void
CQIllustratorPanMode::
handleMouseRelease(const MouseEvent &)
{
  illustrator_->redraw();
}

void
CQIllustratorPanMode::
handleMouseDrag(const MouseEvent &)
{
  QPointF p1 = illustrator_->getITransform().map(curr_ppos_);
  QPointF p2 = illustrator_->getITransform().map(prev_ppos_);

  double dx = p1.x() - p2.x();
  double dy = p1.y() - p2.y();

  const CBBox2D &bbox = illustrator_->getBBox();

  double x    = bbox.getLL().x - dx;
  double y    = bbox.getLL().y - dy;
  double size = bbox.getWidth ();

  CBBox2D bbox1(CPoint2D(x, y), CPoint2D(x + size, y + size));

  illustrator_->setBBox(bbox1);
}

void
CQIllustratorPanMode::
handleMouseMove(const MouseEvent &)
{
}

QCursor
CQIllustratorPanMode::
getCursor() const
{
  return Qt::OpenHandCursor;
}

//------------

CQIllustratorPanToolbar::
CQIllustratorPanToolbar(CQIllustratorPanMode *mode) :
 CQIllustratorToolbar(mode), panMode_(mode)
{
}

QIcon
CQIllustratorPanToolbar::
getIcon()
{
  return QIcon(QPixmap(pan_data));
}
##concat##CQIllustratorPointSelectMode.cpp
#include <CQIllustratorPointSelectMode.h>
#include <CQIllustrator.h>
#include <CQIllustratorHandle.h>
#include <CQIllustratorShapeDrawer.h>

#include <QPainter>
#include <QHBoxLayout>
#include <QPushButton>

#include <CQMenu.h>
#include <CQUtil.h>
#include <CQSwatch.h>

#include <xpm/point_select.xpm>

#include <cursors/select.xbm>
#include <cursors/selectmask.xbm>

#include <xpm/selected_point.xpm>

#define IMAGE_DATA(I) I, sizeof(I)/sizeof(char *)

CQIllustratorPointSelectMode::
CQIllustratorPointSelectMode(CQIllustrator *illustrator) :
 CQIllustratorMode(illustrator, CQIllustrator::MODE_POINT_SELECT)
{
  setCursor(select_bits, selectmask_bits, 2, 2);
}

CQIllustratorPointSelectToolbar *
CQIllustratorPointSelectMode::
createToolbar()
{
  toolbar_ = new CQIllustratorPointSelectToolbar(this);

  return toolbar_;
}
CQIllustratorPointSelectSizer *
CQIllustratorPointSelectMode::
createSizer()
{
  sizer_ = new CQIllustratorPointSelectSizer(this);

  return sizer_;
}

CQMenuItem *
CQIllustratorPointSelectMode::
createMenuItem(CQMenu *menu)
{
  menuItem_ = new CQMenuItem(menu, "&Select Point", CQMenuItem::CHECKABLE);

  menuItem_->setStatusTip("Select Shape Point");
  menuItem_->setXPMIcon(point_select_data);

  connect(menuItem_->getAction(), SIGNAL(toggled(bool)), this, SLOT(menuItemSlot()));

  return menuItem_;
}

void
CQIllustratorPointSelectMode::
handleMouseRelease(const MouseEvent &e)
{
  CPoint2D p2 = CQUtil::fromQPoint(e.window);

  if (dragging_) {
    if (! moving_) {
      selectControlPoint(e);
    }
    // dragging finished so commit
    else {
      illustrator_->getSandbox()->commit(CQIllustratorData::CHANGE_GEOMETRY);
    }
  }
  // not dragging so do a select
  else {
    CPoint2D p1 = CQUtil::fromQPoint(press_wpos_);

    // point click - select at point
    if (! moving_) {
      (void) illustrator_->selectPointAt(p2, getControlType(), e.event->isControlKey(),
                                         e.event->isShiftKey());
    }
    // drag - select points in rectangle
    else {
      CBBox2D bbox(p1, p2);

      illustrator_->selectPointsIn(bbox, CQIllustratorShape::CONTROL_GEOMETRY,
                                   e.event->isControlKey(), e.event->isShiftKey());
    }
  }

  dragging_ = false;

  illustrator_->redraw();
}

void
CQIllustratorPointSelectMode::
handleMouseDrag(const MouseEvent &e)
{
  if (dragging_) {
    CQIllustratorShape *shape = illustrator_->getSandbox()->frontShape();

    sizer_->updatePoint(shape, e.window);
  }
  else {
  }

  illustrator_->redrawOverlay();

  prev_wpos_ = e.window;
}

void
CQIllustratorPointSelectMode::
drawOverlay(CQIllustratorShapeDrawer *drawer)
{
  QPainter *painter = drawer->getPainter();

  if (! dragging_) {
    // draw rubber band
    if (pressed_) {
      QPointF current_wpos = illustrator_->getITransform().map(QPointF(curr_ppos_));

      QPen pen;

      pen.setColor(QColor(0,0,0));
      pen.setStyle(Qt::DashLine);

      painter->setPen(pen);
      painter->setBrush(Qt::NoBrush);

      painter->drawRect(QRectF(press_wpos_, current_wpos));
    }

    //------

    // draw handles for selected shapes
    CQIllustratorSelectedShapes *selection = illustrator_->getSelection();

    if (selection->size() == 1) {
      const CQIllustratorSelectedShape &sshape = selection->front();

      const CQIllustratorShape *shape = sshape.getShape();

      sizer_->draw(painter, shape);

      sizer_->drawSelectionHandles(painter, sshape);
    }
  }
  else {
    CQIllustratorShape *shape = illustrator_->getSandbox()->frontShape();

    sizer_->draw(painter, shape);
  }
}

QCursor
CQIllustratorPointSelectMode::
getCursor() const
{
  return Qt::ArrowCursor;
}

//---------------

CQIllustratorPointSelectToolbar::
CQIllustratorPointSelectToolbar(CQIllustratorPointSelectMode *mode) :
 CQIllustratorToolbar(mode), mode_(mode)
{
}

QIcon
CQIllustratorPointSelectToolbar::
getIcon()
{
  return QIcon(QPixmap(point_select_data));
}

void
CQIllustratorPointSelectToolbar::
addWidgets()
{
  QBoxLayout *layout = qobject_cast<QBoxLayout *>(CQIllustratorToolbar::layout());

  //-----

  QPushButton *addButton  = new QPushButton("Add");

  CQSwatch *selectSwatch = new CQSwatch("Select", addButton);

  layout->addWidget(selectSwatch);
}

void
CQIllustratorPointSelectToolbar::
setSelectedShape(const CQIllustratorShape *)
{
}

//------

CQIllustratorPointSelectSizer::
CQIllustratorPointSelectSizer(CQIllustratorPointSelectMode *mode) :
 CQIllustratorModeSizer(mode)
{
}

void
CQIllustratorPointSelectSizer::
drawHandles(QPainter *painter, const CQIllustratorShape *shape)
{
  if (shape) {
    CQIllustratorShape::ControlPointList controlPoints;

    shape->getControlPoints(controlPoints);

    uint numControlPoints = controlPoints.size();

    updateHandles(numControlPoints);

    for (uint i = 0; i < numControlPoints; ++i)
      controlPointHandles_[i]->draw(shape, controlPoints[i], painter);
  }
}

void
CQIllustratorPointSelectSizer::
updateHandles(uint numHandles)
{
  CQIllustrator *illustrator = mode_->getIllustrator();

  while (controlPointHandles_.size() < numHandles) {
    CQIllustratorControlPointHandle *handle = new CQIllustratorControlPointHandle(illustrator);

    addHandle(handle);
  }

  while (controlPointHandles_.size() > numHandles) {
    CQIllustratorControlPointHandle *handle = 0;

    removeHandle(handle);
  }

  for (uint i = 0; i < numHandles; ++i) {
    CQIllustratorControlPointHandle *handle = new CQIllustratorControlPointHandle(illustrator);

    handle->setImage(IMAGE_DATA(selected_point_data));
  }
}
##concat##CQIllustratorPreference.cpp
#include <CQIllustratorPreference.h>
#include <CQIllustrator.h>

#include <QLabel>
#include <QVBoxLayout>
#include <QGridLayout>
#include <CQPointEdit.h>

CQIllustratorPreferenceDock::
CQIllustratorPreferenceDock(CQIllustrator *illustrator) :
 QWidget(0), illustrator_(illustrator)
{
  QVBoxLayout *layout = new QVBoxLayout(this);
  layout->setMargin(0); layout->setSpacing(0);

  fullMin_ = new CQPointEdit;
  fullMax_ = new CQPointEdit;

  connect(fullMin_, SIGNAL(valueChanged()), this, SLOT(updateFillBBox()));
  connect(fullMax_, SIGNAL(valueChanged()), this, SLOT(updateFillBBox()));

  QGridLayout *fullLayout = new QGridLayout;

  fullLayout->addWidget(new QLabel("Min"), 0, 0);
  fullLayout->addWidget(fullMin_         , 0, 1);
  fullLayout->addWidget(new QLabel("Max"), 1, 0);
  fullLayout->addWidget(fullMax_         , 1, 1);

  layout->addLayout(fullLayout);

  layout->addStretch();

  connect(illustrator_, SIGNAL(fullBBoxChanged()), this, SLOT(syncFillBBox()));

  syncFillBBox();
}

void
CQIllustratorPreferenceDock::
syncFillBBox()
{
  fullMin_->setValue(illustrator_->getFullBBox().getMin());
  fullMax_->setValue(illustrator_->getFullBBox().getMax());
}

void
CQIllustratorPreferenceDock::
updateFillBBox()
{
  const CPoint2D &fullMin = fullMin_->getValue();
  const CPoint2D &fullMax = fullMax_->getValue();

  CBBox2D fullBBox;

  fullBBox += fullMin;
  fullBBox += fullMax;

  illustrator_->setFullBBox(fullBBox);
}
##concat##CQIllustratorSandbox.cpp
#include <CQIllustratorSandbox.h>
#include <CQIllustrator.h>

CQIllustratorSandbox::
CQIllustratorSandbox(CQIllustrator *illustrator) :
 illustrator_(illustrator)
{
}

void
CQIllustratorSandbox::
addSelection()
{
  clear();

  CQIllustratorSelectedShapes *selection = illustrator_->getSelection();

  CQIllustratorSelectedShapes::iterator ps1, ps2;

  for (ps1 = selection->begin(), ps2 = selection->end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = (*ps1).getShape();

    if (shape->getFixed()) continue;

    shape->setVisible(false);

    uint id = shape->getId();

    CQIllustratorShape *shape1 = shape->dup();

    shape1->setId(id);

    edit_shapes_.push_back(shape1);
  }
}

void
CQIllustratorSandbox::
addSelectionPath()
{
  clear();

  CQIllustratorSelectedShapes *selection = illustrator_->getSelection();

  CQIllustratorSelectedShapes::iterator ps1, ps2;

  for (ps1 = selection->begin(), ps2 = selection->end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = (*ps1).getShape();

    if (shape->getFixed()) continue;

    CPathShapePartList parts;

    if (! shape->getPath(parts)) continue;

    CPathShape *pshape = illustrator_->createPathShape();

    pshape->setParts(parts);

    pshape->setStroke(shape->getStroke());
    pshape->setFill  (shape->getFill ());

    edit_shapes_.push_back(pshape);
  }
}

void
CQIllustratorSandbox::
clear()
{
  EditShapes::iterator ps1, ps2;

  for (ps1 = edit_shapes_.begin(), ps2 = edit_shapes_.end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = *ps1;

    CQIllustratorShape *shape1 = illustrator_->getShape(shape->getId());

    if (shape1)
      shape1->setVisible(true);

    delete shape;
  }

  edit_shapes_.clear();
}

CBBox2D
CQIllustratorSandbox::
getBBox() const
{
  CBBox2D bbox;

  EditShapes::const_iterator ps1, ps2;

  for (ps1 = edit_shapes_.begin(), ps2 = edit_shapes_.end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = *ps1;

    bbox += shape->getBBox();
  }

  return bbox;
}

void
CQIllustratorSandbox::
moveBy(const CPoint2D &d)
{
  EditShapes::iterator ps1, ps2;

  for (ps1 = edit_shapes_.begin(), ps2 = edit_shapes_.end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = *ps1;

    shape->moveBy(d);
  }
}

void
CQIllustratorSandbox::
commit(CQIllustratorData::ChangeType changeType)
{
  illustrator_->startUndoGroup("Commit");

  EditShapes::iterator ps1, ps2;

  for (ps1 = edit_shapes_.begin(), ps2 = edit_shapes_.end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = *ps1;

    CQIllustratorShape *shape1 = illustrator_->getShape(shape->getId());
    assert(shape1);

    if      (changeType == CQIllustratorData::CHANGE_GEOMETRY) {
      CQIllustratorShapeGeometry *geom = shape->getGeometry();

      shape1->setGeometry(geom);

      delete geom;
    }
    else if (changeType == CQIllustratorData::CHANGE_STROKE) {
      const CQIllustratorShapeStroke &stroke = shape->getStroke();

      shape1->setStroke(stroke);
    }
    else if (changeType == CQIllustratorData::CHANGE_FILL) {
      const CQIllustratorShapeFill &fill = shape->getFill();

      shape1->setFill(fill);
    }
    else
      assert(false);
  }

  illustrator_->endUndoGroup();

  clear();

  illustrator_->redraw();
}

void
CQIllustratorSandbox::
draw(CQIllustratorShapeDrawer *drawer)
{
  EditShapes::iterator ps1, ps2;

  for (ps1 = edit_shapes_.begin(), ps2 = edit_shapes_.end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = *ps1;

    shape->draw(drawer);
  }
}
##concat##CQIllustratorSelection.cpp
#include <CQIllustratorSelection.h>
#include <CQIllustrator.h>
#include <CQIllustratorShape.h>

CQIllustratorSelectedShapes::
CQIllustratorSelectedShapes(CQIllustrator *illustrator) :
 illustrator_(illustrator), locked_(false)
{
}

void
CQIllustratorSelectedShapes::
clear()
{
  shapes_.clear();

  emit selectionChanged();
}

void
CQIllustratorSelectedShapes::
startSelect()
{
  assert(! locked_);

  locked_ = true;
}

void
CQIllustratorSelectedShapes::
endSelect()
{
  assert(locked_);

  locked_ = false;

  emit selectionChanged();
}

void
CQIllustratorSelectedShapes::
add(CQIllustratorShape *shape)
{
  if (exists(shape)) return;

  shapes_.push_back(CQIllustratorSelectedShape(shape));

  if (! locked_)
    emit selectionChanged();
}

void
CQIllustratorSelectedShapes::
remove(iterator i)
{
  shapes_.erase(i);

  if (! locked_)
    emit selectionChanged();
}

bool
CQIllustratorSelectedShapes::
exists(const CQIllustratorShape *shape) const
{
  SelectedShapes::const_iterator p1, p2;

  for (p1 = shapes_.begin(), p2 = shapes_.end(); p1 != p2; ++p1) {
    if ((*p1).getShape()->getId() == shape->getId())
      return true;
  }

  return false;
}

bool
CQIllustratorSelectedShapes::
exists(const CQIllustratorShape *shape, const CQIllustratorShapeControlPoint *point) const
{
  SelectedShapes::const_iterator p1, p2;

  for (p1 = shapes_.begin(), p2 = shapes_.end(); p1 != p2; ++p1) {
    if ((*p1).getShape()->getId() == shape->getId() && (*p1).exists(point))
      return true;
  }

  return false;
}

CQIllustratorSelectedShape &
CQIllustratorSelectedShapes::
get(CQIllustratorShape *shape)
{
  SelectedShapes::iterator p1, p2;

  for (p1 = shapes_.begin(), p2 = shapes_.end(); p1 != p2; ++p1) {
    if ((*p1).getShape()->getId() == shape->getId())
      return *p1;
  }

  assert(false);
}

CQIllustratorSelectedShape &
CQIllustratorSelectedShapes::
checkoutShape(const CQIllustratorSelectedShape &sshape, CQIllustratorData::ChangeType changeType)
{
  CQIllustratorSelectedShape &sshape1 = const_cast<CQIllustratorSelectedShape &>(sshape);

  CQIllustratorShape *shape = sshape1.getShape();

  illustrator_->checkoutShape(shape, changeType);

  return sshape1;
}

void
CQIllustratorSelectedShapes::
checkinShape(const CQIllustratorSelectedShape &sshape, CQIllustratorData::ChangeType changeType)
{
  CQIllustratorShape *shape = const_cast<CQIllustratorShape *>(sshape.getShape());

  illustrator_->checkinShape(shape, changeType);

  if (! locked_)
    emit selectionChanged();
}

//----

void
CQIllustratorSelectedShapes::
clearShapeLines(CQIllustratorSelectedShape &shape)
{
  shape.clearLines();

  if (! locked_)
    emit selectionChanged();
}

void
CQIllustratorSelectedShapes::
addShapeLine(CQIllustratorSelectedShape &shape, CQIllustratorShapeControlLine *line)
{
  shape.addLine(line);

  if (! locked_)
    emit selectionChanged();
}

void
CQIllustratorSelectedShapes::
removeShapeLine(CQIllustratorSelectedShape &shape, CQIllustratorShapeControlLine *line)
{
  shape.removeLine(line);

  if (! locked_)
    emit selectionChanged();
}

void
CQIllustratorSelectedShapes::
setShapeLine(CQIllustratorSelectedShape &shape, uint i, const CLine2D &l)
{
  CQIllustratorShapeControlLine *line = shape.getLine(i);

  line->setLine(shape.getShape(), l);

  if (! locked_)
    emit selectionChanged();
}

//----

void
CQIllustratorSelectedShapes::
clearShapePoints(CQIllustratorSelectedShape &shape)
{
  shape.clearPoints();

  if (! locked_)
    emit selectionChanged();
}

void
CQIllustratorSelectedShapes::
addShapePoint(CQIllustratorSelectedShape &shape, CQIllustratorShapeControlPoint *point)
{
  shape.addPoint(point);

  if (! locked_)
    emit selectionChanged();
}

void
CQIllustratorSelectedShapes::
removeShapePoint(CQIllustratorSelectedShape &shape, CQIllustratorShapeControlPoint *point)
{
  shape.removePoint(point);

  if (! locked_)
    emit selectionChanged();
}

//-------------

CQIllustratorSelectedShape::
CQIllustratorSelectedShape(CQIllustratorShape *shape) :
 shape_(shape), points_()
{
}

CQIllustratorSelectedShape::
~CQIllustratorSelectedShape()
{
  clearPoints();
}

CQIllustratorShape *
CQIllustratorSelectedShape::
getShape()
{
  return shape_;
}

const CQIllustratorShape *
CQIllustratorSelectedShape::
getShape() const
{
  return shape_;
}

//----

void
CQIllustratorSelectedShape::
clearLines()
{
  uint num = lines_.size();

  for (uint i = 0; i < num; ++i)
    delete lines_[i];

  lines_.clear();
}

void
CQIllustratorSelectedShape::
addLine(CQIllustratorShapeControlLine *line)
{
  lines_.push_back(line->dup());
}

void
CQIllustratorSelectedShape::
removeLine(CQIllustratorShapeControlLine *line)
{
  uint num = lines_.size();

  uint i = 0;

  for ( ; i < num; ++i)
    if (line->getId() == lines_[i]->getId())
      break;

  if (i < num) {
    ++i;

    for ( ; i < num; ++i)
      lines_[i - 1] = lines_[i];

    lines_.pop_back();
  }
}

bool
CQIllustratorSelectedShape::
exists(const CQIllustratorShapeControlLine *line) const
{
  uint num = lines_.size();

  for (uint i = 0; i < num; ++i)
    if (line->getId() == lines_[i]->getId())
      return true;;

  return false;
}

uint
CQIllustratorSelectedShape::
numLines() const
{
  return lines_.size();
}

const CQIllustratorShapeControlLine *
CQIllustratorSelectedShape::
getLine(uint i) const
{
  return lines_[i];
}

CQIllustratorShapeControlLine *
CQIllustratorSelectedShape::
getLine(uint i)
{
  return lines_[i];
}

//----

void
CQIllustratorSelectedShape::
clearPoints()
{
  uint num = points_.size();

  for (uint i = 0; i < num; ++i)
    delete points_[i];

  points_.clear();
}

void
CQIllustratorSelectedShape::
addPoint(CQIllustratorShapeControlPoint *point)
{
  points_.push_back(point->dup());
}

void
CQIllustratorSelectedShape::
removePoint(CQIllustratorShapeControlPoint *point)
{
  uint num = points_.size();

  uint i = 0;

  for ( ; i < num; ++i)
    if (point->getId() == points_[i]->getId())
      break;

  if (i < num) {
    ++i;

    for ( ; i < num; ++i)
      points_[i - 1] = points_[i];

    points_.pop_back();
  }
}

bool
CQIllustratorSelectedShape::
exists(const CQIllustratorShapeControlPoint *point) const
{
  uint num = points_.size();

  for (uint i = 0; i < num; ++i)
    if (point->getId() == points_[i]->getId())
      return true;;

  return false;
}

uint
CQIllustratorSelectedShape::
numPoints() const
{
  return points_.size();
}

const CQIllustratorShapeControlPoint *
CQIllustratorSelectedShape::
getPoint(uint i) const
{
  return points_[i];
}

CQIllustratorShapeControlPoint *
CQIllustratorSelectedShape::
getPoint(uint i)
{
  return points_[i];
}
##concat##CQIllustratorSelectMode.cpp
#include <CQIllustratorSelectMode.h>
#include <CQIllustrator.h>
#include <CQIllustratorShapeDrawer.h>

#include <QPainter>
#include <QHBoxLayout>

#include <CQMenu.h>
#include <CQUtil.h>
#include <CQSwatch.h>
#include <CQRadioButtons.h>
#include <CQImageButton.h>

#include <xpm/select.xpm>
#include <xpm/select_all.xpm>
#include <xpm/select_none.xpm>

#include <cursors/select.xbm>
#include <cursors/selectmask.xbm>

enum { ROTATE_SMALL = 1, ROTATE_NORMAL = 15, ROTATE_LARGE = 90 };

CQIllustratorSelectMode::
CQIllustratorSelectMode(CQIllustrator *illustrator) :
 CQIllustratorMode(illustrator, CQIllustrator::MODE_SELECT), sizing_(false), inside_(true)
{
  setCursor(select_bits, selectmask_bits, 2, 2);

  sizer_ = new CQIllustratorSizer(illustrator_);
}

CQIllustratorSelectToolbar *
CQIllustratorSelectMode::
createToolbar()
{
  toolbar_ = new CQIllustratorSelectToolbar(this);

  return toolbar_;
}

CQMenuItem *
CQIllustratorSelectMode::
createMenuItem(CQMenu *menu)
{
  menuItem_ = new CQMenuItem(menu, "&Select Shape", CQMenuItem::CHECKABLE);

  menuItem_->setStatusTip("Select Shape");
  menuItem_->setXPMIcon(select_data);

  connect(menuItem_->getAction(), SIGNAL(toggled(bool)), this, SLOT(menuItemSlot()));

  return menuItem_;
}

void
CQIllustratorSelectMode::
setInside(bool inside)
{
  inside_ = inside;
}

void
CQIllustratorSelectMode::
handleMousePress(const MouseEvent &)
{
  sizing_   = false;
  dragging_ = false;

  // if in sizer handle then sizing
  if (sizer_->mousePress(press_wpos_)) {
    sizing_ = true;
  }
  // if press point inside a shape then dragging
  else {
    CPoint2D p = CQUtil::fromQPoint(press_wpos_);

    CQIllustratorSelectedShapes *selection = illustrator_->getSelection();

    CQIllustratorSelectedShapes::iterator ps1, ps2;

    for (ps1 = selection->begin(), ps2 = selection->end(); ps1 != ps2; ++ps1) {
      CQIllustratorShape *shape = (*ps1).getShape();

      const CBBox2D &bbox = shape->getBBox();

      if (bbox.inside(p)) {
        dragging_ = true;
        break;
      }
    }
  }

  if (dragging_ || sizing_) {
    illustrator_->getSandbox()->addSelection();

    if (illustrator_->getSandbox()->getNumShapes() == 1) {
      CQIllustratorShape *shape = illustrator_->getSandbox()->frontShape();

      drag_bbox_   = shape->getBBox();
      drag_center_ = shape->getRotateCenter();
      drag_matrix_ = shape->getMatrix();
    }
    else {
      drag_bbox_   = illustrator_->getSandbox()->getBBox();
      drag_center_ = drag_bbox_.getCenter();
      drag_matrix_ = CMatrix2D();
    }

    illustrator_->redraw();
  }
}

void
CQIllustratorSelectMode::
handleMouseRelease(const MouseEvent &e)
{
  if ((dragging_ || sizing_) && ! moving_) {
    illustrator_->getSandbox()->clear();

    dragging_ = false;
    sizing_   = false;
  }

  // not sizing (move/resize/rotate) and not dragging so do a select
  if (! sizing_ && ! dragging_) {
    CPoint2D p = CQUtil::fromQPoint(e.window);

    // point click - select at point and toggle sizer mode if same shape selected
    if (! moving_) {
      CQIllustratorSelectedShapes *selection = illustrator_->getSelection();

      bool single_shape = (selection->size() == 1);

      CQIllustratorShape *old_select_shape = 0;

      if (single_shape)
        old_select_shape = selection->front().getShape();

      CQIllustratorShape *select_shape =
        illustrator_->selectAt(p, e.event->isControlKey(), e.event->isShiftKey());

      if (single_shape && select_shape == old_select_shape)
        sizer_->toggleOp();
    }
    // box drag - select inside or touching range
    else {
      CBBox2D bbox(CQUtil::fromQPoint(press_wpos_), p);

      if (inside_)
        illustrator_->selectIn(bbox, e.event->isControlKey(), e.event->isShiftKey());
      else
        illustrator_->selectOverlap(bbox, e.event->isControlKey(), e.event->isShiftKey());
    }

    illustrator_->redraw();
  }
  // sizing or dragging finished so commit
  else {
    if (sizing_)
      sizer_->mouseRelease(e.window);

    illustrator_->getSandbox()->commit(CQIllustratorData::CHANGE_GEOMETRY);
  }

  dragging_ = false;
  sizing_   = false;
}

void
CQIllustratorSelectMode::
handleMouseDrag(const MouseEvent &e)
{
  if      (sizing_) {
    CQIllustratorShape *shape = illustrator_->getSandbox()->frontShape();

    if (shape) {
      shape->setBBox        (drag_bbox_);
      shape->setRotateCenter(drag_center_);
      shape->setMatrix      (drag_matrix_);

      sizer_->updateShape(shape, press_wpos_, e.window, e.event->isShiftKey());
    }
  }
  else if (dragging_) {
    double dx = e.window.x() - press_wpos_.x();
    double dy = e.window.y() - press_wpos_.y();

    if (e.event->isShiftKey()) {
      if (fabs(dx) >= fabs(dy)) dy = 0;
      else                      dx = 0;
    }

    CBBox2D bbox = illustrator_->getSandbox()->getBBox();

    CPoint2D d = drag_bbox_.getLL() - bbox.getLL() + CPoint2D(dx, dy);

    illustrator_->getSandbox()->moveBy(d);
  }

  illustrator_->redrawOverlay();
}

void
CQIllustratorSelectMode::
handleMouseMove(const MouseEvent &e)
{
  if (sizer_->updateActive(e.window))
    illustrator_->redrawOverlay();
}

bool
CQIllustratorSelectMode::
handleKeyPress(const KeyEvent &e)
{
  CKeyType key = e.event->getType();

  if (key == CKEY_TYPE_Less) {
    illustrator_->getSandbox()->addSelection();

    if (illustrator_->getSandbox()->getNumShapes() == 1) {
      CQIllustratorShape *shape = illustrator_->getSandbox()->frontShape();

      if (! e.event->isControlKey())
        shape->rotate( ROTATE_NORMAL*M_PI/180.0);
      else
        shape->rotate( ROTATE_SMALL *M_PI/180.0);

      illustrator_->getSandbox()->commit(CQIllustratorData::CHANGE_GEOMETRY);

      return true;
    }
  }
  else if (key == CKEY_TYPE_Greater) {
    illustrator_->getSandbox()->addSelection();

    if (illustrator_->getSandbox()->getNumShapes() == 1) {
      CQIllustratorShape *shape = illustrator_->getSandbox()->frontShape();

      if (! e.event->isControlKey())
        shape->rotate(-ROTATE_NORMAL*M_PI/180.0);
      else
        shape->rotate(-ROTATE_SMALL *M_PI/180.0);

      illustrator_->getSandbox()->commit(CQIllustratorData::CHANGE_GEOMETRY);

      return true;
    }
  }

  return CQIllustratorMode::handleKeyPress(e);
}

void
CQIllustratorSelectMode::
drawOverlay(CQIllustratorShapeDrawer *drawer)
{
  QPainter *painter = drawer->getPainter();

  // draw sizer if not dragging
  if (! dragging_ && ! sizing_) {
    // draw selection rubber band
    if (pressed_) {
      QPointF current_wpos = illustrator_->getITransform().map(QPointF(curr_ppos_));

      QPen pen;

      pen.setColor(QColor(0,0,0));
      pen.setStyle(Qt::DashLine);

      painter->setPen(pen);
      painter->setBrush(Qt::NoBrush);

      painter->drawRect(QRectF(press_wpos_, current_wpos));
    }

    //------

    // draw sizer for single selected shape
    CQIllustratorSelectedShapes *selection = illustrator_->getSelection();

    if (selection->size() == 1) {
      CQIllustratorShape *shape = selection->front().getShape();

      sizer_->draw(drawer, shape);
    }
  }
  else {
    if (sizing_) {
      CQIllustratorShape *shape = illustrator_->getSandbox()->frontShape();

      if (shape)
        sizer_->draw(drawer, shape);
    }
  }
}

//---------------

CQIllustratorSelectToolbar::
CQIllustratorSelectToolbar(CQIllustratorSelectMode *mode) :
 CQIllustratorToolbar(mode), mode_(mode)
{
}

QIcon
CQIllustratorSelectToolbar::
getIcon()
{
  return QIcon(QPixmap(select_data));
}

void
CQIllustratorSelectToolbar::
addWidgets()
{
  QBoxLayout *layout = qobject_cast<QBoxLayout *>(CQIllustratorToolbar::layout());

  selectAllButton_  = new CQImageButton(QPixmap(select_all_data ));
  selectNoneButton_ = new CQImageButton(QPixmap(select_none_data));

  selectAllButton_ ->setToolTip("Select All");
  selectNoneButton_->setToolTip("Select None");

  connect(selectAllButton_ , SIGNAL(clicked()), this, SLOT(selectAllSlot ()));
  connect(selectNoneButton_, SIGNAL(clicked()), this, SLOT(selectNoneSlot()));

  CQSwatch *selectSwatch = new CQSwatch("Select", selectAllButton_, selectNoneButton_);

  layout->addWidget(selectSwatch);

  //-----

  CQHRadioButtons *buttons = new CQHRadioButtons;

  buttons->addButton("Inside");
  buttons->addButton("Overlap");

  connect(buttons, SIGNAL(valueChanged(int)), this, SLOT(setMode(int)));

  CQSwatch *modeSwatch = new CQSwatch("Mode", buttons);

  layout->addWidget(modeSwatch);
}

void
CQIllustratorSelectToolbar::
selectAllSlot()
{
  mode_->getIllustrator()->selectAll();
}

void
CQIllustratorSelectToolbar::
selectNoneSlot()
{
  mode_->getIllustrator()->selectNone();
}

void
CQIllustratorSelectToolbar::
setMode(int ind)
{
  mode_->setInside(ind == 0);
}
##concat##CQIllustratorSetAnchorObjectMode.cpp
#include <CQIllustratorSetAnchorObjectMode.h>
#include <CQIllustratorAlignMode.h>

#include <CQUtil.h>
#include <CQMenu.h>
#include <CQIllustrator.h>

#include <xpm/select.xpm>

CQIllustratorSetAnchorObjectMode::
CQIllustratorSetAnchorObjectMode(CQIllustrator *illustrator) :
 CQIllustratorMode(illustrator->getMode(CQIllustrator::MODE_ALIGN),
                   CQIllustrator::MODE_ANCHOR_OBJECT)
{
}

CQMenuItem *
CQIllustratorSetAnchorObjectMode::
createMenuItem(CQMenu *menu)
{
  menuItem_ = new CQMenuItem(menu, "&Set Anchor Object", CQMenuItem::CHECKABLE);

  menuItem_->setStatusTip("Set Anchor Object");
  menuItem_->setXPMIcon(select_data);

  connect(menuItem_->getAction(), SIGNAL(toggled(bool)), this, SLOT(menuItemSlot()));

  return menuItem_;
}

void
CQIllustratorSetAnchorObjectMode::
handleMousePress(const MouseEvent &)
{
  CQIllustratorShape *shape = illustrator_->getObjectAt(CQUtil::fromQPoint(press_wpos_));

  illustrator_->getAlignToolbar()->setAnchorObject(shape->getName().c_str());
}

void
CQIllustratorSetAnchorObjectMode::
handleMouseRelease(const MouseEvent &)
{
  illustrator_->cancelAnchorSlot();

  illustrator_->redrawOverlay();
}

void
CQIllustratorSetAnchorObjectMode::
handleMouseDrag(const MouseEvent &)
{
}

void
CQIllustratorSetAnchorObjectMode::
handleMouseMove(const MouseEvent &)
{
}

QCursor
CQIllustratorSetAnchorObjectMode::
getCursor() const
{
  return Qt::ArrowCursor;
}
##concat##CQIllustratorSetAnchorPositionMode.cpp
#include <CQIllustratorSetAnchorPositionMode.h>
#include <CQIllustratorAlignMode.h>

#include <CQMenu.h>
#include <CQIllustrator.h>

#include <xpm/select.xpm>

CQIllustratorSetAnchorPositionMode::
CQIllustratorSetAnchorPositionMode(CQIllustrator *illustrator) :
 CQIllustratorMode(illustrator->getMode(CQIllustrator::MODE_ALIGN),
                   CQIllustrator::MODE_ANCHOR_POSITION)
{
}

CQMenuItem *
CQIllustratorSetAnchorPositionMode::
createMenuItem(CQMenu *menu)
{
  menuItem_ = new CQMenuItem(menu, "&Set Anchor Position", CQMenuItem::CHECKABLE);

  menuItem_->setStatusTip("Set Anchor Position");
  menuItem_->setXPMIcon(select_data);

  connect(menuItem_->getAction(), SIGNAL(toggled(bool)), this, SLOT(menuItemSlot()));

  return menuItem_;
}

void
CQIllustratorSetAnchorPositionMode::
handleMousePress(const MouseEvent &)
{
  illustrator_->getAlignToolbar()->setAnchorPosition(press_wpos_);
}

void
CQIllustratorSetAnchorPositionMode::
handleMouseRelease(const MouseEvent &e)
{
  illustrator_->getAlignToolbar()->setAnchorPosition(e.window);

  illustrator_->cancelAnchorSlot();

  illustrator_->redrawOverlay();
}

void
CQIllustratorSetAnchorPositionMode::
handleMouseDrag(const MouseEvent &e)
{
  illustrator_->getAlignToolbar()->setAnchorPosition(e.window);

  illustrator_->redrawOverlay();
}

void
CQIllustratorSetAnchorPositionMode::
handleMouseMove(const MouseEvent &)
{
}

QCursor
CQIllustratorSetAnchorPositionMode::
getCursor() const
{
  return Qt::CrossCursor;
}
##concat##CQIllustratorSetImageMode.cpp
#include <CQIllustratorSetImageMode.h>
#include <CQIllustrator.h>
#include <CQIllustratorHandle.h>
#include <CQIllustratorShapeDrawer.h>

#include <QPainter>
#include <QComboBox>
#include <QBoxLayout>
#include <QFileDialog>

#include <COSFile.h>
#include <CLinearGradient.h>
#include <CQMenu.h>
#include <CQUtil.h>
#include <CQImageButton.h>
#include <CQSwatch.h>

#include <xpm/image.xpm>
#include <xpm/lalign.xpm>
#include <xpm/hcalign.xpm>
#include <xpm/ralign.xpm>
#include <xpm/balign.xpm>
#include <xpm/vcalign.xpm>
#include <xpm/talign.xpm>

#define IMAGE_DATA(I) I, sizeof(I)/sizeof(char *)

CQIllustratorSetImageMode::
CQIllustratorSetImageMode(CQIllustrator *illustrator) :
 CQIllustratorMode(illustrator, CQIllustrator::MODE_IMAGE)
{
}

CQIllustratorSetImageToolbar *
CQIllustratorSetImageMode::
createToolbar()
{
  toolbar_ = new CQIllustratorSetImageToolbar(this);

  return toolbar_;
}

CQIllustratorImageSizer *
CQIllustratorSetImageMode::
createSizer()
{
  sizer_ = new CQIllustratorImageSizer(this);

  return sizer_;
}

CQMenuItem *
CQIllustratorSetImageMode::
createMenuItem(CQMenu *menu)
{
  menuItem_ = new CQMenuItem(menu, "&Image", CQMenuItem::CHECKABLE);

  menuItem_->setStatusTip("Create/Modify Fill Image");
  menuItem_->setXPMIcon(image_data);

  connect(menuItem_->getAction(), SIGNAL(toggled(bool)), this, SLOT(menuItemSlot()));

  return menuItem_;
}

void
CQIllustratorSetImageMode::
handleMouseRelease(const MouseEvent &)
{
  if (dragging_ && ! moving_) {
    illustrator_->getSandbox()->clear();

    dragging_ = false;
  }

  // not dragging so add image to selected objects
  if (! dragging_) {
  }
  // dragging finished so commit
  else {
    illustrator_->getSandbox()->commit(CQIllustratorData::CHANGE_FILL);
  }

  dragging_ = false;
}

void
CQIllustratorSetImageMode::
handleMouseDrag(const MouseEvent &)
{
  if (dragging_) {
    CQIllustratorShape *shape = illustrator_->getSandbox()->frontShape();

    CQIllustratorShapeFill &fill = shape->getFill();

    if (fill.hasImage()) {
      CImagePtr image = fill.getImage();

      assert(image.isValid());
    }
  }

  illustrator_->redrawOverlay();
}

void
CQIllustratorSetImageMode::
drawOverlay(CQIllustratorShapeDrawer *drawer)
{
  QPainter *painter = drawer->getPainter();

  if (! dragging_) {
    // draw creation rubber band
    if (pressed_) {
      QPointF current_wpos = illustrator_->getITransform().map(QPointF(curr_ppos_));

      QPen pen;

      pen.setColor(QColor(0,0,0));
      pen.setStyle(Qt::DashLine);

      painter->setPen(pen);
      painter->setBrush(Qt::NoBrush);

      painter->drawLine(press_wpos_, current_wpos);
    }

    //------

    // draw handles for single selected shape
    CQIllustratorSelectedShapes *selection = illustrator_->getSelection();

    if (selection->size() == 1) {
      CQIllustratorShape *shape = selection->front().getShape();

      sizer_->draw(painter, shape);
    }
  }
  else {
    CQIllustratorShape *shape = illustrator_->getSandbox()->frontShape();

    sizer_->draw(painter, shape);
  }
}

QCursor
CQIllustratorSetImageMode::
getCursor() const
{
  return Qt::ArrowCursor;
}

//------------

CQIllustratorSetImageToolbar::
CQIllustratorSetImageToolbar(CQIllustratorSetImageMode *mode) :
 CQIllustratorToolbar(mode), mode_(mode), scale_(CQIllustratorShapeFill::IMAGE_SCALE_NONE),
 halign_(CHALIGN_TYPE_CENTER), valign_(CVALIGN_TYPE_CENTER)
{
}

QIcon
CQIllustratorSetImageToolbar::
getIcon()
{
  return QIcon(QPixmap(image_data));
}

void
CQIllustratorSetImageToolbar::
addWidgets()
{
  QBoxLayout *layout = qobject_cast<QBoxLayout *>(CQIllustratorToolbar::layout());

  //-----

  imageButton_ = new CQImageButton(QPixmap(image_data));

  CQSwatch *fileSwatch = new CQSwatch("Image", imageButton_);

  connect(imageButton_, SIGNAL(clicked()), this, SLOT(setImageSlot()));

  layout->addWidget(fileSwatch);

  //-----

  scaleCombo_ = new QComboBox;

  scaleCombo_->addItem("None");
  scaleCombo_->addItem("Fit");
  scaleCombo_->addItem("Equal");

  CQSwatch *scaleSwatch = new CQSwatch("Scale", scaleCombo_);

  connect(scaleCombo_, SIGNAL(currentIndexChanged(int)), this, SLOT(setScaleSlot(int)));

  layout->addWidget(scaleSwatch);

  //-----

  lalignButton_  = new CQImageButton(QPixmap(lalign_data ));
  hcalignButton_ = new CQImageButton(QPixmap(hcalign_data));
  ralignButton_  = new CQImageButton(QPixmap(ralign_data ));

  lalignButton_ ->setCheckable(true);
  hcalignButton_->setCheckable(true);
  ralignButton_ ->setCheckable(true);

  lalignButton_ ->setToolTip("Left Align");
  hcalignButton_->setToolTip("Horizontal Center Align");
  ralignButton_ ->setToolTip("Right Align");

  connect(lalignButton_ , SIGNAL(clicked()), this, SLOT(lalignSlot ()));
  connect(hcalignButton_, SIGNAL(clicked()), this, SLOT(hcalignSlot()));
  connect(ralignButton_ , SIGNAL(clicked()), this, SLOT(ralignSlot ()));

  CQSwatch *halignSwatch =
    new CQSwatch("Horizontal Align<3>", lalignButton_, hcalignButton_, ralignButton_);

  layout->addWidget(halignSwatch);

  //-----

  talignButton_  = new CQImageButton(QPixmap(talign_data ));
  vcalignButton_ = new CQImageButton(QPixmap(vcalign_data));
  balignButton_  = new CQImageButton(QPixmap(balign_data ));

  talignButton_ ->setCheckable(true);
  vcalignButton_->setCheckable(true);
  balignButton_ ->setCheckable(true);

  talignButton_ ->setToolTip("Top Align");
  vcalignButton_->setToolTip("Vertical Center Align");
  balignButton_ ->setToolTip("Bottom Align");

  connect(talignButton_ , SIGNAL(clicked()), this, SLOT(talignSlot ()));
  connect(vcalignButton_, SIGNAL(clicked()), this, SLOT(vcalignSlot()));
  connect(balignButton_ , SIGNAL(clicked()), this, SLOT(balignSlot ()));

  CQSwatch *valignSwatch =
    new CQSwatch("Vertical Align<3>", talignButton_, vcalignButton_, balignButton_);

  layout->addWidget(valignSwatch);

  //-----

  // tile, zoom, center, scale, stretch, span
}

void
CQIllustratorSetImageToolbar::
setSelectedShape(const CQIllustratorShape *shape)
{
  if (shape) {
    const CQIllustratorShapeFill &fill = shape->getFill();

    if (fill.hasImage()) {
      scale_  = fill.getImageScale();
      halign_ = fill.getImageHAlign();
      valign_ = fill.getImageVAlign();

      updateWidgets();
    }
  }
}

void
CQIllustratorSetImageToolbar::
updateShape()
{
  CQIllustrator *illustrator = mode_->getIllustrator();

  CQIllustratorShape *shape =
    CQIllustratorUtil::getCurrentShape<CQIllustratorShape>(illustrator);

  if (shape) {
    illustrator->checkoutShape(shape, CQIllustratorData::CHANGE_GEOMETRY);

    shape = dynamic_cast<CQIllustratorShape *>(shape);

    CQIllustratorShapeFill &fill = shape->getFill();

    if (fill.hasImage()) {
      fill.setImageScale (scale_ );
      fill.setImageHAlign(halign_);
      fill.setImageVAlign(valign_);
    }

    illustrator->checkinShape(shape, CQIllustratorData::CHANGE_GEOMETRY);
  }

  illustrator->redraw();
}

void
CQIllustratorSetImageToolbar::
updateWidgets()
{
  if      (scale_ == CQIllustratorShapeFill::IMAGE_SCALE_NONE) scaleCombo_->setCurrentIndex(0);
  else if (scale_ == CQIllustratorShapeFill::IMAGE_SCALE_FIT ) scaleCombo_->setCurrentIndex(1);
  else                                             scaleCombo_->setCurrentIndex(2);

  lalignButton_ ->setChecked(halign_ == CHALIGN_TYPE_LEFT);
  hcalignButton_->setChecked(halign_ == CHALIGN_TYPE_CENTER);
  ralignButton_ ->setChecked(halign_ == CHALIGN_TYPE_RIGHT);

  talignButton_ ->setChecked(valign_ == CVALIGN_TYPE_TOP);
  vcalignButton_->setChecked(valign_ == CVALIGN_TYPE_CENTER);
  balignButton_ ->setChecked(valign_ == CVALIGN_TYPE_BOTTOM);
}

void
CQIllustratorSetImageToolbar::
setImageSlot()
{
  CQIllustrator *illustrator = mode_->getIllustrator();

  CQIllustratorSelectedShapes *selection = illustrator->getSelection();

  CQIllustratorShape *shape = 0;

  if (selection->size() == 1)
    shape = selection->front().getShape();

  //-------

  QString title  = "Load Image";
  QString cwd    = QString(COSFile::getCurrentDir().c_str());
  QString filter = "Image Files (*)";

  QStringList filenames = QFileDialog::getOpenFileNames(this, title, cwd, filter);

  if (filenames.size() == 0)
    return;

  QStringListIterator fi(filenames);

  while (fi.hasNext()) {
    CImageFileSrc src(fi.next().toStdString());

    CImagePtr image = CImageMgrInst->lookupImage(src);

    if (image.isValid()) {
      setShapeImage(shape, image);
      return;
    }
  }
}

void
CQIllustratorSetImageToolbar::
setShapeImage(CQIllustratorShape *shape, CImagePtr image)
{
  CQIllustrator *illustrator = mode_->getIllustrator();

  if (shape == 0) {
    CPoint2D p1(0, 0);
    CPoint2D p2(image->getWidth(), image->getHeight());

    CQIllustratorRectShape *rect = illustrator->createRectShape(p1, p2);

    illustrator->addShape(rect);

    illustrator->setSelectShape(rect);

    shape = rect;
  }

  CQIllustratorShapeFill fill = shape->getFill();

  fill.setImage(image);

  fill.setImageScale(CQIllustratorShapeFill::IMAGE_SCALE_FIT);

  shape->setFill(fill);

  illustrator->emitFillChanged();

  illustrator->redraw();
}

void
CQIllustratorSetImageToolbar::
setScaleSlot(int ind)
{
  if      (ind == 0) scale_ = CQIllustratorShapeFill::IMAGE_SCALE_NONE;
  else if (ind == 1) scale_ = CQIllustratorShapeFill::IMAGE_SCALE_FIT;
  else               scale_ = CQIllustratorShapeFill::IMAGE_SCALE_EQUAL;

  updateShape();
}

void
CQIllustratorSetImageToolbar::
lalignSlot()
{
  halign_ = CHALIGN_TYPE_LEFT;

  updateShape();
}

void
CQIllustratorSetImageToolbar::
hcalignSlot()
{
  halign_ = CHALIGN_TYPE_CENTER;

  updateShape();
}

void
CQIllustratorSetImageToolbar::
ralignSlot()
{
  halign_ = CHALIGN_TYPE_RIGHT;

  updateShape();
}

void
CQIllustratorSetImageToolbar::
talignSlot()
{
  valign_ = CVALIGN_TYPE_TOP;

  updateShape();
}

void
CQIllustratorSetImageToolbar::
vcalignSlot()
{
  valign_ = CVALIGN_TYPE_CENTER;

  updateShape();
}

void
CQIllustratorSetImageToolbar::
balignSlot()
{
  valign_ = CVALIGN_TYPE_BOTTOM;

  updateShape();
}

//----------

CQIllustratorImageSizer::
CQIllustratorImageSizer(CQIllustratorSetImageMode *mode) :
 CQIllustratorModeSizer(mode)
{
}

void
CQIllustratorImageSizer::
drawHandles(QPainter *, const CQIllustratorShape *)
{
}
##concat##CQIllustratorSetLGradientMode.cpp
#include <CQIllustratorSetLGradientMode.h>
#include <CQIllustrator.h>
#include <CQIllustratorHandle.h>
#include <CQIllustratorShapeDrawer.h>

#include <QPainter>
#include <QBoxLayout>
#include <QRadioButton>

#include <CLinearGradient.h>
#include <CQMenu.h>
#include <CQUtil.h>
#include <CQRealEdit.h>
#include <CQSwatch.h>

#include <xpm/lgradient.xpm>

#include <xpm/stop_point.xpm>
#include <xpm/stop_point_active.xpm>

#define IMAGE_DATA(I) I, sizeof(I)/sizeof(char *)

CQIllustratorSetLGradientMode::
CQIllustratorSetLGradientMode(CQIllustrator *illustrator) :
 CQIllustratorMode(illustrator, CQIllustrator::MODE_LGRADIENT)
{
}

CQIllustratorSetLGradientToolbar *
CQIllustratorSetLGradientMode::
createToolbar()
{
  toolbar_ = new CQIllustratorSetLGradientToolbar(this);

  return toolbar_;
}

CQIllustratorLGradSizer *
CQIllustratorSetLGradientMode::
createSizer()
{
  sizer_ = new CQIllustratorLGradSizer(this);

  return sizer_;
}

CQMenuItem *
CQIllustratorSetLGradientMode::
createMenuItem(CQMenu *menu)
{
  menuItem_ = new CQMenuItem(menu, "&Linear Gradient", CQMenuItem::CHECKABLE);

  menuItem_->setStatusTip("Create/Modify Linear Gradient");
  menuItem_->setXPMIcon(lgradient_data);

  connect(menuItem_->getAction(), SIGNAL(toggled(bool)), this, SLOT(menuItemSlot()));

  return menuItem_;
}

void
CQIllustratorSetLGradientMode::
handleMouseRelease(const MouseEvent &e)
{
  CPoint2D p1 = CQUtil::fromQPoint(press_wpos_);
  CPoint2D p2 = CQUtil::fromQPoint(e.window);

  if (dragging_) {
    if (! moving_) {
      selectControlPoint(e);
    }
    // dragging finished so commit
    else {
      illustrator_->getSandbox()->commit(CQIllustratorData::CHANGE_FILL);
    }
  }
  // not dragging so do a select
  else {
    // point click - select at point
    if (! moving_) {
      (void) illustrator_->selectAt(p2, e.event->isControlKey(), e.event->isShiftKey());
    }
    else {
      if (editMode_ == CREATE_MODE) {
        // drag then create lgradient rectangle using specified bbox
        illustrator_->addLinearGradient(CQUtil::fromQPoint(press_wpos_),
                                        CQUtil::fromQPoint(e.window));
      }
      else {
        // drag - select points in rectangle
        CBBox2D bbox(p1, p2);

        illustrator_->selectPointsIn(bbox, CQIllustratorShape::CONTROL_LGRADIENT,
                                     e.event->isControlKey(), e.event->isShiftKey());
      }
    }
  }

  dragging_ = false;

  illustrator_->redraw();
}

void
CQIllustratorSetLGradientMode::
handleMouseDrag(const MouseEvent &e)
{
  if (dragging_) {
    CQIllustratorShape *shape = illustrator_->getSandbox()->frontShape();

    sizer_->updatePoint(shape, e.window);
  }
  else {
    if (editMode_ == CREATE_MODE) {
      //CPoint2D p1 = CQUtil::fromQPoint(press_wpos_);
      //CPoint2D p2 = CQUtil::fromQPoint(e.window);

      //toolbar_->setSize(CBBox2D(p1, p2));
    }
    else {
    }
  }

  illustrator_->redrawOverlay();

  prev_wpos_ = e.window;
}

void
CQIllustratorSetLGradientMode::
drawOverlay(CQIllustratorShapeDrawer *drawer)
{
  QPainter *painter = drawer->getPainter();

  if (! dragging_) {
    // draw rubber band
    if (pressed_) {
      QPen pen;

      pen.setColor(QColor(0,0,0));
      pen.setStyle(Qt::DashLine);

      painter->setPen(pen);
      painter->setBrush(Qt::NoBrush);

      if (editMode_ == CREATE_MODE)
        painter->drawLine(press_wpos_, curr_wpos_);
      else
        painter->drawRect(QRectF(press_wpos_, curr_wpos_));
    }

    //------

    // draw handles for single selected shape
    CQIllustratorSelectedShapes *selection = illustrator_->getSelection();

    if (selection->size() == 1) {
      const CQIllustratorSelectedShape &sshape = selection->front();

      const CQIllustratorShape *shape = sshape.getShape();

      sizer_->draw(painter, shape);

      sizer_->drawSelectionHandles(painter, sshape);
    }
  }
  else {
    CQIllustratorShape *shape = illustrator_->getSandbox()->frontShape();

    sizer_->draw(painter, shape);
  }
}

QCursor
CQIllustratorSetLGradientMode::
getCursor() const
{
  return Qt::ArrowCursor;
}

//------------

CQIllustratorSetLGradientToolbar::
CQIllustratorSetLGradientToolbar(CQIllustratorSetLGradientMode *mode) :
 CQIllustratorToolbar(mode), mode_(mode)
{
}

QIcon
CQIllustratorSetLGradientToolbar::
getIcon()
{
  return QIcon(QPixmap(lgradient_data));
}

void
CQIllustratorSetLGradientToolbar::
addWidgets()
{
  QBoxLayout *layout = qobject_cast<QBoxLayout *>(CQIllustratorToolbar::layout());

  //-----

  QWidget *modeFrame = new QWidget;

  QVBoxLayout *modeLayout = new QVBoxLayout(modeFrame);

  createRadio_ = new QRadioButton("Create");
  editRadio_   = new QRadioButton("Edit");

  createRadio_->setChecked(true);

  createRadio_->setFocusPolicy(Qt::NoFocus);
  editRadio_  ->setFocusPolicy(Qt::NoFocus);

  modeLayout->addWidget(createRadio_);
  modeLayout->addWidget(editRadio_);

  connect(createRadio_, SIGNAL(toggled(bool)), this, SLOT(modeChangedSlot()));

  CQSwatch *modeSwatch = new CQSwatch(modeFrame);

  layout->addWidget(modeSwatch);

  //-----

  startXEdit_ = new CQRealEdit(0.0);
  startYEdit_ = new CQRealEdit(0.0);
  endXEdit_   = new CQRealEdit(0.0);
  endYEdit_   = new CQRealEdit(0.0);

  startXEdit_->setFocusPolicy(Qt::ClickFocus);
  startYEdit_->setFocusPolicy(Qt::ClickFocus);
  endXEdit_  ->setFocusPolicy(Qt::ClickFocus);
  endYEdit_  ->setFocusPolicy(Qt::ClickFocus);

  connect(startXEdit_, SIGNAL(valueChanged(double)), this, SLOT(updateShape()));
  connect(startYEdit_, SIGNAL(valueChanged(double)), this, SLOT(updateShape()));
  connect(endXEdit_  , SIGNAL(valueChanged(double)), this, SLOT(updateShape()));
  connect(endYEdit_  , SIGNAL(valueChanged(double)), this, SLOT(updateShape()));

  CQSwatch *startSwatch = new CQSwatch("Start", startXEdit_, startYEdit_);
  CQSwatch *endSwatch   = new CQSwatch("End"  , endXEdit_  , endYEdit_  );

  layout->addWidget(startSwatch);
  layout->addWidget(endSwatch);

  startXEdit_->setEnabled(false);
  startYEdit_->setEnabled(false);
  endXEdit_  ->setEnabled(false);
  endYEdit_  ->setEnabled(false);
}

void
CQIllustratorSetLGradientToolbar::
modeChangedSlot()
{
  if (createRadio_->isChecked())
    mode_->setEditMode(CQIllustratorMode::CREATE_MODE);
  else
    mode_->setEditMode(CQIllustratorMode::EDIT_MODE);
}

void
CQIllustratorSetLGradientToolbar::
setSelectedShape(const CQIllustratorShape *shape)
{
  if (! shape) return;

  CQIllustratorShapeFill fill = shape->getFill();

  const CGenGradient *g = fill.getGradient();

  const CLinearGradient *lg = dynamic_cast<const CLinearGradient *>(g);

  startXEdit_->setEnabled(lg != 0);
  startYEdit_->setEnabled(lg != 0);
  endXEdit_  ->setEnabled(lg != 0);
  endYEdit_  ->setEnabled(lg != 0);

  if (lg) {
    startXEdit_->setValue(lg->getX1());
    startYEdit_->setValue(lg->getY1());
    endXEdit_  ->setValue(lg->getX2());
    endYEdit_  ->setValue(lg->getY2());
  }
}

void
CQIllustratorSetLGradientToolbar::
updateShape()
{
  CQIllustrator *illustrator = mode_->getIllustrator();

  CQIllustratorShape *shape = CQIllustratorUtil::getCurrentShape<CQIllustratorShape>(illustrator);

  if (! shape) return;

  CQIllustratorShapeFill fill = shape->getFill();

  CGenGradient *g = fill.getGradient();

  CLinearGradient *lg = dynamic_cast<CLinearGradient *>(g);

  if (! lg) return;

  double x1 = startXEdit_->getValue();
  double y1 = startXEdit_->getValue();
  double x2 = endXEdit_  ->getValue();
  double y2 = endXEdit_  ->getValue();

  lg->setX1(x1); lg->setY1(y1);
  lg->setX2(x2); lg->setY2(y2);

  shape->setFill(fill);

  illustrator->emitFillChanged();

  illustrator->redraw();
}

//----------

CQIllustratorLGradSizer::
CQIllustratorLGradSizer(CQIllustratorSetLGradientMode *mode) :
 CQIllustratorModeSizer(mode)
{
  CQIllustrator *illustrator = mode_->getIllustrator();

  start_handle_ = new CQIllustratorControlPointHandle(illustrator);
  end_handle_   = new CQIllustratorControlPointHandle(illustrator);

  start_handle_->setImage(IMAGE_DATA(stop_point_data), IMAGE_DATA(stop_point_active_data));
  end_handle_  ->setImage(IMAGE_DATA(stop_point_data), IMAGE_DATA(stop_point_active_data));

  addHandle(start_handle_);
  addHandle(end_handle_  );
}

void
CQIllustratorLGradSizer::
drawHandles(QPainter *painter, const CQIllustratorShape *shape)
{
  CQIllustratorShape::ControlPointList controlPoints;

  shape->getControlPoints(controlPoints, CQIllustratorShape::CONTROL_LGRADIENT);

  if (controlPoints.size() == 2) {
    start_handle_->draw(shape, controlPoints[0], painter);
    end_handle_  ->draw(shape, controlPoints[1], painter);

    CPoint2D p1 = controlPoints[0]->getPoint(shape);
    CPoint2D p2 = controlPoints[1]->getPoint(shape);

    QPen pen;

    pen.setColor(QColor(0,0,0));
    pen.setStyle(Qt::DashLine);

    painter->setPen(pen);
    painter->setBrush(Qt::NoBrush);

    painter->drawLine(CQUtil::toQPoint(p1), CQUtil::toQPoint(p2));
  }
}
##concat##CQIllustratorSetRGradientMode.cpp
#include <CQIllustratorSetRGradientMode.h>
#include <CQIllustrator.h>
#include <CQIllustratorHandle.h>
#include <CQIllustratorShapeDrawer.h>

#include <QPainter>
#include <QBoxLayout>

#include <CRadialGradient.h>
#include <CQMenu.h>
#include <CQUtil.h>
#include <CQRealEdit.h>
#include <CQSwatch.h>

#include <xpm/rgradient.xpm>

#include <xpm/stop_point.xpm>
#include <xpm/stop_point_active.xpm>

#define IMAGE_DATA(I) I, sizeof(I)/sizeof(char *)

CQIllustratorSetRGradientMode::
CQIllustratorSetRGradientMode(CQIllustrator *illustrator) :
 CQIllustratorMode(illustrator, CQIllustrator::MODE_RGRADIENT)
{
}

CQIllustratorSetRGradientToolbar *
CQIllustratorSetRGradientMode::
createToolbar()
{
  toolbar_ = new CQIllustratorSetRGradientToolbar(this);

  return toolbar_;
}

CQIllustratorRGradSizer *
CQIllustratorSetRGradientMode::
createSizer()
{
  sizer_ = new CQIllustratorRGradSizer(this);

  return sizer_;
}

CQMenuItem *
CQIllustratorSetRGradientMode::
createMenuItem(CQMenu *menu)
{
  menuItem_ = new CQMenuItem(menu, "&Radial Gradient", CQMenuItem::CHECKABLE);

  menuItem_->setStatusTip("Create/Modify Radial Gradient");
  menuItem_->setXPMIcon(rgradient_data);

  connect(menuItem_->getAction(), SIGNAL(toggled(bool)), this, SLOT(menuItemSlot()));

  return menuItem_;
}

void
CQIllustratorSetRGradientMode::
handleMouseRelease(const MouseEvent &e)
{
  CPoint2D p2 = CQUtil::fromQPoint(e.window);

  if (dragging_) {
    if (! moving_) {
      selectControlPoint(e);
    }
    // dragging finished so commit
    else {
      illustrator_->getSandbox()->commit(CQIllustratorData::CHANGE_FILL);
    }
  }
  // not dragging so do a select
  else {
    //CPoint2D p1 = CQUtil::fromQPoint(press_wpos_);

    // point click - select at point
    if (! moving_) {
      (void) illustrator_->selectAt(p2, e.event->isControlKey(), e.event->isShiftKey());
    }
    // drag then create rgradient ellipse using specified bbox
    else {
      illustrator_->addRadialGradient(CQUtil::fromQPoint(press_wpos_),
                                      CQUtil::fromQPoint(e.window));
    }
  }

  dragging_ = false;

  illustrator_->redraw();
}

void
CQIllustratorSetRGradientMode::
handleMouseDrag(const MouseEvent &e)
{
  if (dragging_) {
    CQIllustratorShape *shape = illustrator_->getSandbox()->frontShape();

    sizer_->updatePoint(shape, e.window);
  }
  else {
    //CPoint2D p1 = CQUtil::fromQPoint(press_wpos_);
    //CPoint2D p2 = CQUtil::fromQPoint(e.window);

    //toolbar_->setSize(CBBox2D(p1, p2));
  }

  illustrator_->redrawOverlay();

  prev_wpos_ = e.window;
}

void
CQIllustratorSetRGradientMode::
drawOverlay(CQIllustratorShapeDrawer *drawer)
{
  QPainter *painter = drawer->getPainter();

  if (! dragging_) {
    // draw creation rubber band
    if (pressed_) {
      QPointF current_wpos = illustrator_->getITransform().map(QPointF(curr_ppos_));

      QPen pen;

      pen.setColor(QColor(0,0,0));
      pen.setStyle(Qt::DashLine);

      painter->setPen(pen);
      painter->setBrush(Qt::NoBrush);

      painter->drawLine(press_wpos_, current_wpos);
    }

    //------

    // draw handles for single selected shape
    CQIllustratorSelectedShapes *selection = illustrator_->getSelection();

    if (selection->size() == 1) {
      const CQIllustratorSelectedShape &sshape = selection->front();

      const CQIllustratorShape *shape = sshape.getShape();

      sizer_->draw(painter, shape);

      sizer_->drawSelectionHandles(painter, sshape);
    }
  }
  else {
    CQIllustratorShape *shape = illustrator_->getSandbox()->frontShape();

    sizer_->draw(painter, shape);
  }
}

QCursor
CQIllustratorSetRGradientMode::
getCursor() const
{
  return Qt::ArrowCursor;
}

//------------

CQIllustratorSetRGradientToolbar::
CQIllustratorSetRGradientToolbar(CQIllustratorSetRGradientMode *mode) :
 CQIllustratorToolbar(mode), mode_(mode)
{
}

QIcon
CQIllustratorSetRGradientToolbar::
getIcon()
{
  return QIcon(QPixmap(rgradient_data));
}

void
CQIllustratorSetRGradientToolbar::
addWidgets()
{
  QBoxLayout *layout = qobject_cast<QBoxLayout *>(CQIllustratorToolbar::layout());

  //-----

  centerXEdit_ = new CQRealEdit(0.0);
  centerYEdit_ = new CQRealEdit(0.0);
  focusXEdit_  = new CQRealEdit(0.0);
  focusYEdit_  = new CQRealEdit(0.0);
  radiusEdit_  = new CQRealEdit(0.0);

  centerXEdit_->setFocusPolicy(Qt::ClickFocus);
  centerYEdit_->setFocusPolicy(Qt::ClickFocus);
  focusXEdit_ ->setFocusPolicy(Qt::ClickFocus);
  focusYEdit_ ->setFocusPolicy(Qt::ClickFocus);
  radiusEdit_ ->setFocusPolicy(Qt::ClickFocus);

  connect(centerXEdit_, SIGNAL(valueChanged(double)), this, SLOT(updateShape()));
  connect(centerYEdit_, SIGNAL(valueChanged(double)), this, SLOT(updateShape()));
  connect(focusXEdit_ , SIGNAL(valueChanged(double)), this, SLOT(updateShape()));
  connect(focusYEdit_ , SIGNAL(valueChanged(double)), this, SLOT(updateShape()));
  connect(radiusEdit_ , SIGNAL(valueChanged(double)), this, SLOT(updateShape()));

  CQSwatch *centerSwatch = new CQSwatch("Center", centerXEdit_, centerYEdit_);
  CQSwatch *focusSwatch  = new CQSwatch("Focus" , focusXEdit_ , focusYEdit_ );
  CQSwatch *radiusSwatch = new CQSwatch("Radius", radiusEdit_);

  layout->addWidget(centerSwatch);
  layout->addWidget(focusSwatch);
  layout->addWidget(radiusSwatch);

  centerXEdit_->setEnabled(false);
  centerYEdit_->setEnabled(false);
  focusXEdit_ ->setEnabled(false);
  focusYEdit_ ->setEnabled(false);
  radiusEdit_ ->setEnabled(false);
}

void
CQIllustratorSetRGradientToolbar::
setSelectedShape(const CQIllustratorShape *shape)
{
  const CRadialGradient *rg = 0;

  if (shape) {
    CQIllustratorShapeFill fill = shape->getFill();

    const CGenGradient *g = fill.getGradient();

    rg = dynamic_cast<const CRadialGradient *>(g);
  }

  centerXEdit_->setEnabled(rg != 0);
  centerYEdit_->setEnabled(rg != 0);
  focusXEdit_ ->setEnabled(rg != 0);
  focusYEdit_ ->setEnabled(rg != 0);
  radiusEdit_ ->setEnabled(rg != 0);

  if (rg) {
    centerXEdit_->setValue(rg->getCenterX());
    centerYEdit_->setValue(rg->getCenterY());
    focusXEdit_ ->setValue(rg->getFocusX());
    focusYEdit_ ->setValue(rg->getFocusY());
    radiusEdit_ ->setValue(rg->getRadius());
  }
}

void
CQIllustratorSetRGradientToolbar::
updateShape()
{
  CQIllustrator *illustrator = mode_->getIllustrator();

  CQIllustratorShape *shape = CQIllustratorUtil::getCurrentShape<CQIllustratorShape>(illustrator);

  if (! shape) return;

  CQIllustratorShapeFill fill = shape->getFill();

  CGenGradient *g = fill.getGradient();

  CRadialGradient *rg = dynamic_cast<CRadialGradient *>(g);

  if (! rg) return;

  double xc = centerXEdit_->getValue();
  double yc = centerYEdit_->getValue();
  double fx = focusXEdit_ ->getValue();
  double fy = focusYEdit_ ->getValue();
  double r  = radiusEdit_ ->getValue();

  rg->setCenter(xc, yc);
  rg->setFocus(fx, fy);
  rg->setRadius(r);

  shape->setFill(fill);

  illustrator->emitFillChanged();

  illustrator->redraw();
}

//----------

CQIllustratorRGradSizer::
CQIllustratorRGradSizer(CQIllustratorSetRGradientMode *mode) :
 CQIllustratorModeSizer(mode)
{
  CQIllustrator *illustrator = mode_->getIllustrator();

  center_handle_ = new CQIllustratorControlPointHandle(illustrator);
  focus_handle_  = new CQIllustratorControlPointHandle(illustrator);
  radius_handle_ = new CQIllustratorControlPointHandle(illustrator);

  center_handle_->setImage(IMAGE_DATA(stop_point_data), IMAGE_DATA(stop_point_active_data));
  focus_handle_ ->setImage(IMAGE_DATA(stop_point_data), IMAGE_DATA(stop_point_active_data));
  radius_handle_->setImage(IMAGE_DATA(stop_point_data), IMAGE_DATA(stop_point_active_data));

  addHandle(center_handle_);
  addHandle(focus_handle_ );
  addHandle(radius_handle_);
}

void
CQIllustratorRGradSizer::
drawHandles(QPainter *painter, const CQIllustratorShape *shape)
{
  CQIllustratorShape::ControlPointList controlPoints;

  shape->getControlPoints(controlPoints, CQIllustratorShape::CONTROL_RGRADIENT);

  if (controlPoints.size() == 3) {
    center_handle_->draw(shape, controlPoints[0], painter);
    focus_handle_ ->draw(shape, controlPoints[1], painter);
    radius_handle_->draw(shape, controlPoints[2], painter);

    CPoint2D p1 = controlPoints[0]->getPoint(shape);
    CPoint2D p2 = controlPoints[1]->getPoint(shape);
    CPoint2D p3 = controlPoints[2]->getPoint(shape);

    QPen pen;

    pen.setColor(QColor(0,0,0));
    pen.setStyle(Qt::DashLine);

    painter->setPen(pen);
    painter->setBrush(Qt::NoBrush);

    painter->drawLine(CQUtil::toQPoint(p1), CQUtil::toQPoint(p2));
    painter->drawLine(CQUtil::toQPoint(p1), CQUtil::toQPoint(p3));
  }
}
##concat##CQIllustratorShape.cpp
#include <CQIllustratorShape.h>
#include <CQIllustratorData.h>
#include <CQIllustratorShapeDrawer.h>

#include <QPainter>
#include <CMathGeom2D.h>
#include <CLinearGradient.h>
#include <CRadialGradient.h>
#include <CQImageGaussianBlur.h>

uint CQIllustratorShape:: last_id_ = 1;

CQIllustratorShape::
CQIllustratorShape(CQIllustratorShape *parent) :
 data_      (0),
 id_        (last_id_++),
 parent_    (parent),
 shapes_    (),
 name_      (""),
 stroke_    (),
 fill_      (),
 filter_id_ (0),
 clip_      (false),
 fixed_     (false),
 visible_   (true),
 rcenter_   (),
 m_         (),
 lock_count_(0),
 bbox_      (),
 bbox_valid_(false)
{
  m_.setIdentity();
}

CQIllustratorShape::
CQIllustratorShape(const CQIllustratorShape &shape) :
 data_      (0),
 id_        (last_id_++),
 parent_    (shape.parent_),
 shapes_    (shape.shapes_),
 name_      (shape.name_),
 stroke_    (shape.stroke_),
 fill_      (shape.fill_),
 filter_id_ (shape.filter_id_),
 clip_      (shape.clip_),
 fixed_     (shape.fixed_),
 visible_   (shape.visible_),
 rcenter_   (shape.rcenter_),
 m_         (shape.m_),
 lock_count_(0),
 bbox_      (),
 bbox_valid_(false)
{
}

CQIllustratorShape::
~CQIllustratorShape()
{
  if (parent_)
    parent_->removeChild(this);
}

void
CQIllustratorShape::
setMatrix(const CMatrix2D &m)
{
  checkoutShape(CQIllustratorData::CHANGE_GEOMETRY);

  m_ = m;

  invalidateBBox();

  checkinShape(CQIllustratorData::CHANGE_GEOMETRY);
}

const CMatrix2D &
CQIllustratorShape::
getFlatMatrix() const
{
  if (parent_) {
    static CMatrix2D m;

    m.setIdentity();

    CQIllustratorShape *parent = parent_;

    while (parent != 0) {
      m = parent->m_*m;

      parent = parent->parent_;
    }

    return m;
  }
  else
    return m_;
}

CBBox2D
CQIllustratorShape::
getFlatBBox() const
{
  CBBox2D bbox = getBBox();

  if (parent_) {
    const CMatrix2D &m = getFlatMatrix();

    CPoint2D p1 = m*bbox.getLL();
    CPoint2D p2 = m*bbox.getLR();
    CPoint2D p3 = m*bbox.getUL();
    CPoint2D p4 = m*bbox.getUR();

    CBBox2D bbox1;

    bbox1 += p1;
    bbox1 += p2;
    bbox1 += p3;
    bbox1 += p4;

    return bbox1;
  }
  else
    return bbox;
}

void
CQIllustratorShape::
getControlLines(ControlLineList &) const
{
}

void
CQIllustratorShape::
setControlLine(const CQIllustratorShapeControlLine *)
{
}

void
CQIllustratorShape::
getControlPoints(ControlPointList &points, ControlType type) const
{
  if      (type == CONTROL_GEOMETRY) {
  }
  else if (type == CONTROL_LGRADIENT) {
    const CQIllustratorShapeFill &fill = getFill();

    const CGenGradient *g = fill.getGradient();

    const CLinearGradient *lg = dynamic_cast<const CLinearGradient *>(g);

    if (! lg) return;

    //CBBox2D bbox = getFlatBBox();

    //double x1 = lg->getX1()*(bbox.getXMax() - bbox.getXMin()) + bbox.getXMin();
    //double y1 = lg->getY1()*(bbox.getYMax() - bbox.getYMin()) + bbox.getYMin();
    //double x2 = lg->getX2()*(bbox.getXMax() - bbox.getXMin()) + bbox.getXMin();
    //double y2 = lg->getY2()*(bbox.getYMax() - bbox.getYMin()) + bbox.getYMin();

    CPoint2D p1(lg->getX1(), lg->getY1());
    CPoint2D p2(lg->getX2(), lg->getY2());

    CQIllustratorShapeLGradientControlPoint *start =
      new CQIllustratorShapeLGradientControlPoint(
            CQIllustratorShapeLGradientControlPoint::START, p1);
    CQIllustratorShapeLGradientControlPoint *end   =
      new CQIllustratorShapeLGradientControlPoint(
            CQIllustratorShapeLGradientControlPoint::END  , p2);

    points.push_back(start);
    points.push_back(end);
  }
  else if (type == CONTROL_RGRADIENT) {
    const CQIllustratorShapeFill &fill = getFill();

    const CGenGradient *g = fill.getGradient();

    const CRadialGradient *rg = dynamic_cast<const CRadialGradient *>(g);

    if (! rg) return;

    //CBBox2D bbox = getFlatBBox();

    //double x1 = rg->getX1()*(bbox.getXMax() - bbox.getXMin()) + bbox.getXMin();
    //double y1 = rg->getY1()*(bbox.getYMax() - bbox.getYMin()) + bbox.getYMin();
    //double x2 = rg->getX2()*(bbox.getXMax() - bbox.getXMin()) + bbox.getXMin();
    //double y2 = rg->getY2()*(bbox.getYMax() - bbox.getYMin()) + bbox.getYMin();

    CPoint2D c(rg->getCenterX(), rg->getCenterY());
    CPoint2D f(rg->getFocusX (), rg->getFocusY ());

    double r1 = rg->getRadius()/sqrt(2);

    CPoint2D rp(c.x + r1, c.y + r1);

    CQIllustratorShapeRGradientControlPoint *center =
      new CQIllustratorShapeRGradientControlPoint(
            CQIllustratorShapeRGradientControlPoint::CENTER, c);
    CQIllustratorShapeRGradientControlPoint *focus  =
      new CQIllustratorShapeRGradientControlPoint(
            CQIllustratorShapeRGradientControlPoint::FOCUS , f);
    CQIllustratorShapeRGradientControlPoint *radius =
      new CQIllustratorShapeRGradientControlPoint(
            CQIllustratorShapeRGradientControlPoint::RADIUS, rp);

    points.push_back(center);
    points.push_back(focus);
    points.push_back(radius);
  }
}

void
CQIllustratorShape::
addChild(CQIllustratorShape *child)
{
  child->parent_ = this;

  shapes_.push_back(child);

  childrenChanged();
}

void
CQIllustratorShape::
removeChild(CQIllustratorShape *child)
{
  child->parent_ = 0;

  shapes_.remove(child);

  childrenChanged();
}

void
CQIllustratorShape::
setParent(CQIllustratorShape *newParent)
{
  if (parent_)
    parent_->removeChild(this);

  if (newParent)
    newParent->addChild(this);
  else
    parent_ = 0;
}

void
CQIllustratorShape::
setName(const std::string &name)
{
  checkoutShape(CQIllustratorData::CHANGE_NAME);

  name_ = name;

  checkinShape(CQIllustratorData::CHANGE_NAME);
}

const CBBox2D &
CQIllustratorShape::
getBBox() const
{
  updateBBox();

  return bbox_;
}

CPoint2D
CQIllustratorShape::
getCenter() const
{
  return getBBox().getCenter();
}

CQIllustratorShapeStroke &
CQIllustratorShape::
getStroke()
{
  return stroke_;
}

const CQIllustratorShapeStroke &
CQIllustratorShape::
getStroke() const
{
  return stroke_;
}

CQIllustratorShapeFill &
CQIllustratorShape::
getFill()
{
  return fill_;
}

const CQIllustratorShapeFill &
CQIllustratorShape::
getFill() const
{
  return fill_;
}

void
CQIllustratorShape::
setStroke(const CQIllustratorShapeStroke &stroke)
{
  checkoutShape(CQIllustratorData::CHANGE_STROKE);

  stroke_ = stroke;

  invalidateBBox();

  checkinShape(CQIllustratorData::CHANGE_STROKE);
}

void
CQIllustratorShape::
setFill(const CQIllustratorShapeFill &fill)
{
  checkoutShape(CQIllustratorData::CHANGE_FILL);

  fill_ = fill;

  checkinShape(CQIllustratorData::CHANGE_FILL);
}

void
CQIllustratorShape::
setStrokeColor(const CRGBA &rgba)
{
  getStroke().setColor(rgba);
}

void
CQIllustratorShape::
setFillColor(const CRGBA &rgba)
{
  fill_.setColor(rgba);
}

void
CQIllustratorShape::
setStrokeOpacity(double opacity)
{
  getStroke().setOpacity(opacity);
}

void
CQIllustratorShape::
setFillOpacity(double opacity)
{
  fill_.setOpacity(opacity);
}

double
CQIllustratorShape::
getStrokeWidth() const
{
  const CMatrix2D &m = getFlatMatrix();

  double w = getStroke().getWidth();

  CVector2D w1 = m*CVector2D(w, w);

  return w1.length();
}

CQIllustratorShapeFilter *
CQIllustratorShape::
getFilter() const
{
  if (filter_id_)
    return CQIllustratorShapeFilterMgrInst->getFilter(filter_id_);
  else
    return 0;
}

void
CQIllustratorShape::
setFilter(uint num)
{
  checkoutShape(CQIllustratorData::CHANGE_GEOMETRY);

  CQIllustratorShapeFilter *filter = CQIllustratorShapeFilterMgrInst->getFilter(num);

  setFilter(filter);

  checkinShape(CQIllustratorData::CHANGE_GEOMETRY);
}

void
CQIllustratorShape::
setFilter(CQIllustratorShapeFilter *filter)
{
  if (filter)
    filter_id_ = filter->getId();
  else
    filter_id_ = 0;
}

void
CQIllustratorShape::
unsetFilter()
{
  checkoutShape(CQIllustratorData::CHANGE_GEOMETRY);

  setFilter((CQIllustratorShapeFilter *) 0);

  checkinShape(CQIllustratorData::CHANGE_GEOMETRY);
}

void
CQIllustratorShape::
setClip(bool clip)
{
  checkoutShape(CQIllustratorData::CHANGE_GEOMETRY);

  clip_ = clip;

  checkinShape(CQIllustratorData::CHANGE_GEOMETRY);
}

bool
CQIllustratorShape::
inside(const CPoint2D &p) const
{
  const CBBox2D &bbox = getBBox();

  return bbox.inside(p);
}

CPoint2D
CQIllustratorShape::
getRotateCenter() const
{
  CMatrix2D save_m = m_;

  CQIllustratorShape *th = const_cast<CQIllustratorShape *>(this);

  th->m_.setIdentity();

  invalidateBBox();

  const CMatrix2D &m = getFlatMatrix();

  CPoint2D rc = m*(getCenter() + rcenter_);

  th->m_ = save_m;

  invalidateBBox();

  return rc;
}

void
CQIllustratorShape::
setRotateCenter(const CPoint2D &rc)
{
  CMatrix2D save_m = m_;

  CQIllustratorShape *th = const_cast<CQIllustratorShape *>(this);

  th->m_.setIdentity();

  invalidateBBox();

  const CMatrix2D &m = getFlatMatrix();

  CMatrix2D im = m.inverse();

  rcenter_ = im*rc - getCenter();

  th->m_ = save_m;

  invalidateBBox();
}

double
CQIllustratorShape::
distance(const CPoint2D &p) const
{
  const CBBox2D &bbox = getBBox();

  const CPoint2D &p1 = bbox.getLL();
  const CPoint2D &p2 = bbox.getUR();

  if      (p.x < p1.x) {
    if      (p.y < p1.y) return pointDist(p, CPoint2D(p1.x, p1.y));
    else if (p.y > p2.y) return pointDist(p, CPoint2D(p1.x, p2.y));
    else                 return (p1.x - p.x);
  }
  else if (p.x > p2.x) {
    if      (p.y < p1.y) return pointDist(p, CPoint2D(p2.x, p1.y));
    else if (p.y > p2.y) return pointDist(p, CPoint2D(p2.x, p2.y));
    else                 return (p.x - p2.x);
  }
  else {
    if      (p.y < p1.y) return (p1.y - p.y);
    else if (p.y > p2.y) return (p.y - p2.y);
    else                 return 0;
  }
}

CQIllustratorShapeNearestPoint2D
CQIllustratorShape::
nearestPoint(const CPoint2D &p, ControlType type) const
{
  CQIllustratorShapeNearestPoint2D nearest;

  ControlPointList points;

  getControlPoints(points, type);

  uint num_points = points.size();

  for (uint i = 0; i < num_points; ++i) {
    double dist = points[i]->distance(this, p);

    nearest.updatePoint(points[i], dist);
  }

  return nearest;
}

void
CQIllustratorShape::
moveTo(const CPoint2D &pos)
{
  const CBBox2D &bbox = getBBox();

  CPoint2D d = pos - bbox.getLL();

  moveBy(d);
}

void
CQIllustratorShape::
moveBy(const CPoint2D &d)
{
  assert(! getFixed());

  checkoutShape(CQIllustratorData::CHANGE_GEOMETRY);

  CMatrix2D m;

  m.setTranslation(d.x, d.y);

  transform(CPoint2D(0, 0), m);

  checkinShape(CQIllustratorData::CHANGE_GEOMETRY);
}

void
CQIllustratorShape::
resizeTo(double w, double h)
{
  const CBBox2D &bbox = getBBox();

  double dw = w - bbox.getWidth ();
  double dh = h - bbox.getHeight();

  resizeBy(dw, dh);
}

void
CQIllustratorShape::
resizeBy(double dw, double dh)
{
  const CBBox2D &bbox = getBBox();

  double w = bbox.getWidth ();
  double h = bbox.getHeight();

  scale(bbox.getLL(), (w + dw)/w, (h + dh)/h);
}

void
CQIllustratorShape::
movePointBy(const CQIllustratorShapeControlPoint *point, const CPoint2D &d)
{
  checkoutShape(CQIllustratorData::CHANGE_GEOMETRY);

  CQIllustratorShapeControlPoint *point1 = point->dup();

  point1->movePointBy(this, d);

  setControlPoint(point1);

  delete point1;

  checkinShape(CQIllustratorData::CHANGE_GEOMETRY);
}

void
CQIllustratorShape::
movePointTo(const CQIllustratorShapeControlPoint *point, const CPoint2D &pos)
{
  CQIllustratorShapeControlPoint *point1 = point->dup();

  point1->movePointTo(this, pos);

  setControlPoint(point1);

  delete point1;
}

bool
CQIllustratorShape::
removePoint(const CQIllustratorShapeControlPoint *point)
{
  checkoutShape(CQIllustratorData::CHANGE_GEOMETRY);

  bool rc = doRemovePoint(point);

  checkinShape(CQIllustratorData::CHANGE_GEOMETRY);

  return rc;
}

bool
CQIllustratorShape::
doRemovePoint(const CQIllustratorShapeControlPoint *)
{
  return false;
}

void
CQIllustratorShape::
scale(const CPoint2D &c, double sx, double sy)
{
  checkoutShape(CQIllustratorData::CHANGE_GEOMETRY);

  CMatrix2D m;

  m.setScale(sx, sy);

  transform(c, m);

  checkinShape(CQIllustratorData::CHANGE_GEOMETRY);
}

void
CQIllustratorShape::
rotate(double da)
{
  checkoutShape(CQIllustratorData::CHANGE_GEOMETRY);

  CMatrix2D m;

  m.setRotation(da);

  CMatrix2D m1, m2;

  CPoint2D rc = getRotateCenter();

  m1.setTranslation(-rc.x, -rc.y);
  m2.setTranslation( rc.x,  rc.y);

  CMatrix2D mm = m2*m*m1;

  setMatrix(mm*m_);

  checkinShape(CQIllustratorData::CHANGE_GEOMETRY);
}

void
CQIllustratorShape::
skew(double dx, double dy)
{
  checkoutShape(CQIllustratorData::CHANGE_GEOMETRY);

  CMatrix2D m;

  m.setSkew(dx, dy);

  CMatrix2D m1, m2;

  CPoint2D rc = getRotateCenter();

  m1.setTranslation(-rc.x, -rc.y);
  m2.setTranslation( rc.x,  rc.y);

  CMatrix2D mm = m2*m*m1;

  setMatrix(mm*m_);

  checkinShape(CQIllustratorData::CHANGE_GEOMETRY);
}

void
CQIllustratorShape::
transform(const CPoint2D &c, const CMatrix2D &m)
{
  CMatrix2D m1, m2;

  m1.setTranslation(-c.x, -c.y);
  m2.setTranslation( c.x,  c.y);

  CMatrix2D mm = m2*m*m1;

  setMatrix(mm*m_);
}

void
CQIllustratorShape::
setBBox(const CBBox2D &bbox)
{
  checkoutShape(CQIllustratorData::CHANGE_GEOMETRY);

  moveTo(bbox.getLL());

  resizeTo(bbox.getWidth(), bbox.getHeight());

  checkinShape(CQIllustratorData::CHANGE_GEOMETRY);
}

void
CQIllustratorShape::
draw(CQIllustratorShapeDrawer *drawer) const
{
  if (getFilter() != 0)
    drawGaussian(drawer);
  else
    drawShape(drawer);

  if (getFixed()) {
    const CBBox2D &bbox = getBBox();

    drawer->pathInit();
    drawer->pathMoveTo(bbox.getLL());
    drawer->pathLineTo(bbox.getUR());
    drawer->pathStroke();

    drawer->pathInit();
    drawer->pathMoveTo(bbox.getLR());
    drawer->pathLineTo(bbox.getUL());
    drawer->pathStroke();
  }
}

void
CQIllustratorShape::
drawGaussian(CQIllustratorShapeDrawer *drawer) const
{
  CQIllustratorFilterShapeDrawer drawer1(drawer, this);

  drawShape(&drawer1);

  const CBBox2D &bbox = getBBox();

  //QTransform transform = drawer->getPainter()->worldTransform();
  QTransform transform = drawer->getPainter()->transform();

  QPointF p1 = transform.map(QPointF(bbox.getXMin(), bbox.getYMin()));
  QPointF p2 = transform.map(QPointF(bbox.getXMax(), bbox.getYMax()));

  int px1 = std::min(p1.x(), p2.x()) - 4;
  int py1 = std::min(p1.y(), p2.y()) - 4;
  int px2 = std::max(p1.x(), p2.x()) + 4;
  int py2 = std::max(p1.y(), p2.y()) + 4;

  //-----

  int w = px2 - px1 + 1;
  int h = py2 - py1 + 1;

  const QImage &qimage = drawer1.getImage().copy(px1, py1, w, h);

  QImage qimage1(w, h, QImage::Format_ARGB32);

  qimage1.fill(qRgba(0,0,0,0));

  //------

  double bx = 2.0;
  double by = 2.0;
  int    nx = 0;
  int    ny = 0;

  //------

  CQImageGaussianBlur blur(qimage);

  blur.blur(qimage1, bx, by, nx, ny);

  //------

  drawer->drawImage(px1, py1, qimage1);
}

void
CQIllustratorShape::
drawSelect(CQIllustratorShapeDrawer *drawer)
{
  CBBox2D bbox = getFlatBBox();

  CPoint2D p1 = bbox.getLL();
  CPoint2D p2 = bbox.getLR();
  CPoint2D p3 = bbox.getUR();
  CPoint2D p4 = bbox.getUL();

  drawer->drawControlLine(p1, p2);
  drawer->drawControlLine(p2, p3);
  drawer->drawControlLine(p3, p4);
  drawer->drawControlLine(p4, p1);
}

bool
CQIllustratorShape::
flip(bool)
{
  return false;
}

void
CQIllustratorShape::
setGeometry(const CQIllustratorShapeGeometry *geom)
{
  checkoutShape(CQIllustratorData::CHANGE_GEOMETRY);

  doSetGeometry(geom);

  checkinShape(CQIllustratorData::CHANGE_GEOMETRY);
}

std::string
CQIllustratorShape::
getSVGStroke() const
{
  std::string str = "style=\"";

  const CQIllustratorShapeStroke &stroke = getStroke();

  const CRGBA     &scolor   = stroke.getColor();
  double           sopacity = stroke.getOpacity();
  double           width    = getStrokeWidth();
  const CLineDash &dash     = stroke.getLineDash();
  CLineCapType     cap      = stroke.getLineCap();
  CLineJoinType    join     = stroke.getLineJoin();

  if (sopacity > 0.0) {
    str += CStrUtil::strprintf("stroke: rgb(%d,%d,%d);", scolor.getRedI(),
                               scolor.getGreenI(), scolor.getBlueI());

    if (sopacity < 1.0)
      str += CStrUtil::strprintf(" stroke-opacity: %g;", sopacity);
  }
  else
    str += "stroke: none;";

  if (width != 1.0)
    str += CStrUtil::strprintf(" stroke-width: %g;", width);

  if (! dash.isSolid())
    str += CStrUtil::strprintf("stroke-dasharray: %s", dash.toString().c_str());

  if      (cap == LINE_CAP_TYPE_ROUND)
    str += CStrUtil::strprintf(" stroke-linecap: round;");
  else if (cap == LINE_CAP_TYPE_SQUARE)
    str += CStrUtil::strprintf(" stroke-linecap: square;");

  if      (join == LINE_JOIN_TYPE_ROUND)
    str += CStrUtil::strprintf(" stroke-linejoin: round;");
  else if (join == LINE_JOIN_TYPE_BEVEL)
    str += CStrUtil::strprintf(" stroke-linejoin: bevel;");

  const CQIllustratorShapeFill &fill = getFill();

  if (fill.hasGradient()) {
    // TODO
  }
  else {
    const CRGBA &fcolor   = fill.getColor();
    double       fopacity = fill.getOpacity();

    if (fopacity > 0.0) {
      str += CStrUtil::strprintf(" fill: rgb(%d,%d,%d);", fcolor.getRedI(),
                                 fcolor.getGreenI(), fcolor.getBlueI());

      if (fopacity < 1.0)
        str += CStrUtil::strprintf(" fill-opacity: %g;", fopacity);
    }
    else
      str += "fill: none;";
  }

  str += "\"";

  return str;
}

std::string
CQIllustratorShape::
getSVGMatrix() const
{
  return getSVGMatrix(m_);
}

std::string
CQIllustratorShape::
getSVGMatrix(const CMatrix2D &m) const
{
  if (m.isIdentity()) return "";

  std::string str = " transform=\"matrix(";

  double values[6];

  m.getValues(values, 6);

  for (uint i = 0; i < 6; ++i) {
    if (i > 0) str += ", ";

    str += CStrUtil::strprintf("%g", values[i]);
  }

  str += ")\"";

  return str;
}

double
CQIllustratorShape::
pointDist(const CPoint2D &p1, const CPoint2D &p2) const
{
  double dx = p1.x - p2.x;
  double dy = p1.y - p2.y;

  return sqrt(dx*dx + dy*dy);
}

void
CQIllustratorShape::
lockShape()
{
  ++lock_count_;
}

void
CQIllustratorShape::
unlockShape()
{
  assert(lock_count_ > 0);

  --lock_count_;
}

void
CQIllustratorShape::
checkoutShape(CQIllustratorData::ChangeType changeType)
{
  if (data_)
    data_->checkoutShape(this, changeType);
}

void
CQIllustratorShape::
checkinShape(CQIllustratorData::ChangeType changeType)
{
  if (data_)
    data_->checkinShape(this, changeType);
}

//----------

CQIllustratorShapeLGradientControlPoint::
CQIllustratorShapeLGradientControlPoint(Position pos, const CPoint2D &p) :
 CQIllustratorShapeControlPoint((uint) pos, p), pos_(pos)
{
}

CQIllustratorShapeLGradientControlPoint *
CQIllustratorShapeLGradientControlPoint::
dup() const
{
  return new CQIllustratorShapeLGradientControlPoint(pos_, point_);
}

CPoint2D
CQIllustratorShapeLGradientControlPoint::
getPoint(const CQIllustratorShape *shape) const
{
  CBBox2D bbox = shape->getFlatBBox();

  const CQIllustratorShapeFill &fill = shape->getFill();

  const CGenGradient *g = fill.getGradient();

  const CLinearGradient *lg = dynamic_cast<const CLinearGradient *>(g);

  assert(lg);

  CPoint2D p;

  if (lg) {
    if (pos_ == START)
      p = CPoint2D(lg->getX1(), lg->getY1());
    else
      p = CPoint2D(lg->getX2(), lg->getY2());
  }
  else {
    if (pos_ == START)
      p = CPoint2D(0, 0);
    else
      p = CPoint2D(1, 1);
  }

  double x1 = p.x*(bbox.getXMax() - bbox.getXMin()) + bbox.getXMin();
  double y1 = p.y*(bbox.getYMax() - bbox.getYMin()) + bbox.getYMin();

  return CPoint2D(x1, y1);
}

void
CQIllustratorShapeLGradientControlPoint::
setPoint(CQIllustratorShape *shape, const CPoint2D &point)
{
  CQIllustratorShapeFill &fill = shape->getFill();

  CGenGradient *g = fill.getGradient();

  CLinearGradient *lg = dynamic_cast<CLinearGradient *>(g);

  if (! lg) return;

  CBBox2D bbox = shape->getFlatBBox();

  CPoint2D p;

  p.x = (point.x - bbox.getXMin())/(bbox.getXMax() - bbox.getXMin());
  p.y = (point.y - bbox.getYMin())/(bbox.getYMax() - bbox.getYMin());

  if (pos_ == START) {
    lg->setX1(p.x);
    lg->setY1(p.y);
  }
  else {
    lg->setX2(p.x);
    lg->setY2(p.y);
  }

  point_ = p;
}

//----------

CQIllustratorShapeRGradientControlPoint::
CQIllustratorShapeRGradientControlPoint(Position pos, const CPoint2D &p) :
 CQIllustratorShapeControlPoint((uint) pos, p), pos_(pos)
{
}

CQIllustratorShapeRGradientControlPoint *
CQIllustratorShapeRGradientControlPoint::
dup() const
{
  return new CQIllustratorShapeRGradientControlPoint(pos_, point_);
}

CPoint2D
CQIllustratorShapeRGradientControlPoint::
getPoint(const CQIllustratorShape *shape) const
{
  CBBox2D bbox = shape->getFlatBBox();

  const CQIllustratorShapeFill &fill = shape->getFill();

  const CGenGradient *g = fill.getGradient();

  const CRadialGradient *rg = dynamic_cast<const CRadialGradient *>(g);

  assert(rg);

  CPoint2D p;

  if (rg) {
    if      (pos_ == CENTER)
      p = CPoint2D(rg->getCenterX(), rg->getCenterY());
    else if (pos_ == FOCUS)
      p = CPoint2D(rg->getFocusX(), rg->getFocusY());
    else {
      double r1 = rg->getRadius()/sqrt(2);

      p = CPoint2D(rg->getCenterX() + r1, rg->getCenterY() + r1);
    }
  }
  else {
    if      (pos_ == CENTER)
      p = CPoint2D(0.5, 0.5);
    else if (pos_ == FOCUS)
      p = CPoint2D(0.5, 0.5);
    else
      p = CPoint2D(1.0, 0.0);
  }

  double x1 = p.x*(bbox.getXMax() - bbox.getXMin()) + bbox.getXMin();
  double y1 = p.y*(bbox.getYMax() - bbox.getYMin()) + bbox.getYMin();

  return CPoint2D(x1, y1);
}

void
CQIllustratorShapeRGradientControlPoint::
setPoint(CQIllustratorShape *shape, const CPoint2D &point)
{
  CQIllustratorShapeFill &fill = shape->getFill();

  CGenGradient *g = fill.getGradient();

  CRadialGradient *rg = dynamic_cast<CRadialGradient *>(g);

  if (! rg) return;

  CBBox2D bbox = shape->getFlatBBox();

  CPoint2D p;

  p.x = (point.x - bbox.getXMin())/(bbox.getXMax() - bbox.getXMin());
  p.y = (point.y - bbox.getYMin())/(bbox.getYMax() - bbox.getYMin());

  if      (pos_ == CENTER)
    rg->setCenter(p);
  else if (pos_ == FOCUS)
    rg->setFocus(p);
  else {
    double d = p.distanceTo(CPoint2D(rg->getCenterX(), rg->getCenterY()));

    rg->setRadius(d);
  }

  rg->init(1, 1);

  point_ = p;
}

//----------

CQIllustratorRectShape::
CQIllustratorRectShape(const CPoint2D &p1, const CPoint2D &p2, double rx, double ry) :
 CQIllustratorShape(), p1_(std::min(p1.x, p2.x), std::min(p1.y, p2.y)),
 p2_(std::max(p1.x, p2.x), std::max(p1.y, p2.y)),
 rx_(rx), ry_(ry)
{
}

CQIllustratorRectShape::
CQIllustratorRectShape(const CQIllustratorRectShape &rect) :
 CQIllustratorShape(rect), p1_(rect.p1_), p2_(rect.p2_), rx_(rect.rx_), ry_(rect.ry_)
{
}

CQIllustratorRectShape *
CQIllustratorRectShape::
dup() const
{
  return new CQIllustratorRectShape(*this);
}

void
CQIllustratorRectShape::
getControlPoints(ControlPointList &points, ControlType type) const
{
  if (type == CONTROL_GEOMETRY) {
    const CMatrix2D &m = getFlatMatrix();

    CPoint2D p1 = m*p1_;
    CPoint2D p2 = m*p2_;

    CPoint2D rx1(rx_, 0);
    CPoint2D ry1(0, ry_);

    CQIllustratorRectShapeControlPoint *ll = new CQIllustratorRectShapeControlPoint(TYPE_LL, p1);
    CQIllustratorRectShapeControlPoint *ur = new CQIllustratorRectShapeControlPoint(TYPE_UR, p2);
    CQIllustratorRectShapeControlPoint *rx = new CQIllustratorRectShapeControlPoint(TYPE_RX, rx1);
    CQIllustratorRectShapeControlPoint *ry = new CQIllustratorRectShapeControlPoint(TYPE_RY, ry1);

    points.push_back(ll);
    points.push_back(ur);
    points.push_back(rx);
    points.push_back(ry);
  }
  else
    CQIllustratorShape::getControlPoints(points, type);
}

void
CQIllustratorRectShape::
setControlPoint(const CQIllustratorShapeControlPoint *point)
{
  const CQIllustratorRectShapeControlPoint *rpoint =
    dynamic_cast<const CQIllustratorRectShapeControlPoint *>(point);

  assert(rpoint);

  const CMatrix2D &m = getFlatMatrix();

  CMatrix2D im = m.inverse();

  CPoint2D p = im*point->getPoint(this);

  CQIllustratorRectShape::ControlPointType type = rpoint->getType();

  if      (type == CQIllustratorRectShape::TYPE_LL)
    p1_ = p;
  else if (type == CQIllustratorRectShape::TYPE_UR)
    p2_ = p;
  else if (type == CQIllustratorRectShape::TYPE_RX)
    rx_ = std::min(std::max(p.x - p1_.x, 0.0), fabs(p2_.x - p1_.x)/2);
  else if (type == CQIllustratorRectShape::TYPE_RY)
    ry_ = std::min(std::max(p2_.y - p.y, 0.0), fabs(p2_.y - p1_.y)/2);

  invalidateBBox();
}

void
CQIllustratorRectShape::
setRadiusX(double rx)
{
  rx_ = rx;
}

void
CQIllustratorRectShape::
setRadiusY(double ry)
{
  ry_ = ry;
}

CPoint2D
CQIllustratorRectShape::
getLL() const
{
  const CMatrix2D &m = getFlatMatrix();

  return m*p1_;
}

CPoint2D
CQIllustratorRectShape::
getUR() const
{
  const CMatrix2D &m = getFlatMatrix();

  return m*p2_;
}

CPoint2D
CQIllustratorRectShape::
getRXPoint() const
{
  const CMatrix2D &m = getFlatMatrix();

  return m*CPoint2D(p1_.x + rx_, p2_.y);
}

CPoint2D
CQIllustratorRectShape::
getRYPoint() const
{
  const CMatrix2D &m = getFlatMatrix();

  return m*CPoint2D(p1_.x, p2_.y - ry_);
}

void
CQIllustratorRectShape::
setLL(const CPoint2D &p)
{
  const CMatrix2D &m = getFlatMatrix();

  CMatrix2D im = m.inverse();

  CPoint2D p1 = im*p;

  p1_ = p1;

  invalidateBBox();
}

void
CQIllustratorRectShape::
setUR(const CPoint2D &p)
{
  const CMatrix2D &m = getFlatMatrix();

  CMatrix2D im = m.inverse();

  CPoint2D p1 = im*p;

  p2_ = p1;

  invalidateBBox();
}

void
CQIllustratorRectShape::
setRXPoint(const CPoint2D &p)
{
  const CMatrix2D &m = getFlatMatrix();

  CMatrix2D im = m.inverse();

  CPoint2D p1 = im*p;

  rx_ = std::min(std::max(p1.x - p1_.x, 0.0), fabs(p2_.x - p1_.x)/2);
}

void
CQIllustratorRectShape::
setRYPoint(const CPoint2D &p)
{
  const CMatrix2D &m = getFlatMatrix();

  CMatrix2D im = m.inverse();

  CPoint2D p1 = im*p;

  ry_ = std::min(std::max(p2_.y - p1.y, 0.0), fabs(p2_.y - p1_.y)/2);
}

void
CQIllustratorRectShape::
updateBBox() const
{
  if (! bbox_valid_) {
    bbox_.reset();

    const CMatrix2D &m = getFlatMatrix();

    CPoint2D p1 = m*CPoint2D(p1_.x, p1_.y);
    CPoint2D p2 = m*CPoint2D(p2_.x, p1_.y);
    CPoint2D p3 = m*CPoint2D(p2_.x, p2_.y);
    CPoint2D p4 = m*CPoint2D(p1_.x, p2_.y);

    bbox_ += p1;
    bbox_ += p2;
    bbox_ += p3;
    bbox_ += p4;

//  double sopacity = getStroke().getOpacity();
//
//  if (sopacity > 0.0) {
//    double lw2 = getStrokeWidth()/2;

//    bbox_.expand(-lw2, -lw2, lw2, lw2);
//  }

    bbox_valid_ = true;
  }
}

bool
CQIllustratorRectShape::
getPolygon(CPolygon2D &polygon) const
{
  const CMatrix2D &m = getFlatMatrix();

  CPoint2D p1 = m*CPoint2D(p1_.x, p1_.y);
  CPoint2D p2 = m*CPoint2D(p2_.x, p1_.y);
  CPoint2D p3 = m*CPoint2D(p2_.x, p2_.y);
  CPoint2D p4 = m*CPoint2D(p1_.x, p2_.y);

  polygon.addPoint(p1);
  polygon.addPoint(p2);
  polygon.addPoint(p3);
  polygon.addPoint(p4);

  return true;
}

bool
CQIllustratorRectShape::
getPath(CPathShapePartList &parts) const
{
  const CMatrix2D &m = getFlatMatrix();

  CPoint2D p1 = m*CPoint2D(p1_.x, p1_.y);
  CPoint2D p2 = m*CPoint2D(p2_.x, p1_.y);
  CPoint2D p3 = m*CPoint2D(p2_.x, p2_.y);
  CPoint2D p4 = m*CPoint2D(p1_.x, p2_.y);

  parts.addPart(new CPathShapeMoveTo(p1));
  parts.addPart(new CPathShapeLineTo(p2));
  parts.addPart(new CPathShapeLineTo(p3));
  parts.addPart(new CPathShapeLineTo(p4));
  parts.addPart(new CPathShapeClose());

  return true;
}

void
CQIllustratorRectShape::
moveBy(const CPoint2D &d)
{
  assert(! getFixed());

  checkoutShape(CQIllustratorData::CHANGE_GEOMETRY);

  const CMatrix2D &m = getFlatMatrix();

  CMatrix2D im = m.inverse();

  p1_ = im*(m*p1_ + d);
  p2_ = im*(m*p2_ + d);

  invalidateBBox();

  checkinShape(CQIllustratorData::CHANGE_GEOMETRY);
}

void
CQIllustratorRectShape::
resizeBy(double dw, double dh)
{
  double x = bbox_.getXMin();
  double y = bbox_.getYMin();

  double w = bbox_.getWidth ();
  double h = bbox_.getHeight();

  double xs = (w + dw)/w;
  double ys = (h + dh)/h;

  const CMatrix2D &m = getFlatMatrix();

  CMatrix2D im = m.inverse();

  CPoint2D p1 = m*p1_;
  CPoint2D p2 = m*p2_;

  p1.x = x + (p1.x - x)*xs;
  p1.y = y + (p1.y - y)*ys;
  p2.x = x + (p2.x - x)*xs;
  p2.y = y + (p2.y - y)*ys;

  p1_ = im*p1;
  p2_ = im*p2;

  invalidateBBox();
}

bool
CQIllustratorRectShape::
flip(bool x_axis)
{
  const CMatrix2D &m = getFlatMatrix();

  CMatrix2D im = m.inverse();

  CPoint2D rc = getRotateCenter();

  CPoint2D p1 = m*p1_;
  CPoint2D p2 = m*p2_;

  p1_ = im*p1.flip(rc, x_axis);
  p2_ = im*p2.flip(rc, x_axis);

  return true;
}

void
CQIllustratorRectShape::
drawShape(CQIllustratorShapeDrawer *drawer) const
{
  const CMatrix2D &m = getFlatMatrix();

  drawer->pushMatrix(m, true);

  CPoint2D p1 = CPoint2D(p1_.x, p1_.y);
  CPoint2D p2 = CPoint2D(p2_.x, p1_.y);
  CPoint2D p3 = CPoint2D(p2_.x, p2_.y);
  CPoint2D p4 = CPoint2D(p1_.x, p2_.y);

  drawer->pathInit();

  if (rx_ > 0 && ry_ > 0) {
    drawer->pathMoveTo(CPoint2D(p1.x + rx_, p1.y      ));
//  drawer->pathMoveTo(CPoint2D(p2.x - rx_, p2.y      ));
    drawer->pathArc   (CPoint2D(p2.x - rx_, p2.y + ry_), rx_, ry_, 3*M_PI/2, 2*M_PI  );
//  drawer->pathLineTo(CPoint2D(p3.x      , p3.y - ry_));
    drawer->pathArc   (CPoint2D(p3.x - rx_, p3.y - ry_), rx_, ry_, 0       , M_PI/2  );
//  drawer->pathLineTo(CPoint2D(p4.x + rx_, p4.y      ));
    drawer->pathArc   (CPoint2D(p4.x + rx_, p4.y - ry_), rx_, ry_, M_PI/2  , M_PI    );
//  drawer->pathLineTo(CPoint2D(p1.x      , p1.y + ry_));
    drawer->pathArc   (CPoint2D(p1.x + rx_, p1.y + ry_), rx_, ry_, M_PI    , 3*M_PI/2);
  }
  else {
    drawer->pathMoveTo(p1);
    drawer->pathLineTo(p2);
    drawer->pathLineTo(p3);
    drawer->pathLineTo(p4);
  }

  drawer->pathClose();

  if (! clip_) {
    fill_  .draw(this, drawer);
    stroke_.draw(this, drawer);
  }
  else
    drawer->pathClip();

  drawer->popMatrix();
}

CQIllustratorShapeGeometry *
CQIllustratorRectShape::
getGeometry()
{
  return new CQIllustratorRectGeometry(fixed_, rcenter_, m_, p1_, p2_, rx_, ry_);
}

void
CQIllustratorRectShape::
doSetGeometry(const CQIllustratorShapeGeometry *geom)
{
  const CQIllustratorRectGeometry *geom1 =
    dynamic_cast<const CQIllustratorRectGeometry *>(geom);

  if (! geom1) return;

  fixed_   = geom1->fixed_;
  rcenter_ = geom1->rcenter_;
  m_       = geom1->m_;
  p1_      = geom1->p1_;
  p2_      = geom1->p2_;
  rx_      = geom1->rx_;
  ry_      = geom1->ry_;

  invalidateBBox();
}

void
CQIllustratorRectShape::
saveSVG(const CQIllustratorSaveData &saveData)
{
  CFile *file = saveData.file;

  double a = getAngle();

  CMatrix2D m1 = CMatrix2D::rotation(-a);

  const CMatrix2D &m = getFlatMatrix();

  CPoint2D p1 = m1*m*p1_;
  CPoint2D p2 = m1*m*p2_;

  double top = saveData.bbox.getYMax();

  double x =       std::min(p1.x, p2.x);
  double y = top - std::min(p1.y, p2.y);
  double w = fabs(p2.x - p1.x);
  double h = fabs(p2.y - p1.y);

  CPoint2D c = (p1 + p2)/2; c.y = top - c.y;

  CMatrix2D m2 = CMatrix2D::translation(-c.x, -c.y)*
                 CMatrix2D::rotation(a)*
                 CMatrix2D::translation( c.x,  c.y);

  file->printf("<rect x=\"%g\" y=\"%g\" width=\"%g\" height=\"%g\" rx=\"%g\" ry=\"%g\"%s %s/>\n",
               x, y, w, h, rx_, ry_, getSVGMatrix(m2).c_str(), getSVGStroke().c_str());
}

void
CQIllustratorRectShape::
saveCmd(const CQIllustratorSaveData &saveData)
{
  CFile *file = saveData.file;

  double a = getAngle();

  const CMatrix2D &m = getFlatMatrix();

  CPoint2D c = (m*p1_ + m*p2_)/2;

  CMatrix2D m1 = CMatrix2D::translation( c.x,  c.y)*
                 CMatrix2D::rotation(-a)*
                 CMatrix2D::translation(-c.x, -c.y);

  CPoint2D p1 = m1*m*p1_;
  CPoint2D p2 = m1*m*p2_;

  double x = std::min(p1.x, p2.x);
  double y = std::min(p1.y, p2.y);
  double w = fabs(p2.x - p1.x);
  double h = fabs(p2.y - p1.y);

  if (name_ != "")
    file->printf("create_rect -name %s -x %g -y %g -w %g -h %g -rx %g -ry %g -a %g\n",
                 name_.c_str(), x, y, w, h, rx_, ry_, 180.0*a/M_PI);
  else
    file->printf("create_rect -x %g -y %g -w %g -h %g -rx %g -ry %g -a %g\n",
                 x, y, w, h, rx_, ry_, 180.0*a/M_PI);
}

double
CQIllustratorRectShape::
getAngle() const
{
  const CMatrix2D &m = getFlatMatrix();

  CPoint2D p1 = m*CPoint2D(p1_.x, p1_.y);
  CPoint2D p2 = m*CPoint2D(p2_.x, p1_.y);

  return atan2(p2.y - p1.y, p2.x - p1.x);
}

//-----

CQIllustratorRectShapeControlPoint::
CQIllustratorRectShapeControlPoint(CQIllustratorRectShape::ControlPointType type,
                                   const CPoint2D &p) :
 CQIllustratorShapeControlPoint((uint) type, p), type_(type)
{
}

CQIllustratorRectShapeControlPoint *
CQIllustratorRectShapeControlPoint::
dup() const
{
  return new CQIllustratorRectShapeControlPoint(type_, point_);
}

CPoint2D
CQIllustratorRectShapeControlPoint::
getPoint(const CQIllustratorShape *shape) const
{
  const CQIllustratorRectShape *rect = dynamic_cast<const CQIllustratorRectShape *>(shape);
  assert(rect);

  if      (type_ == CQIllustratorRectShape::TYPE_LL)
    return rect->getLL();
  else if (type_ == CQIllustratorRectShape::TYPE_UR)
    return rect->getUR();
  else if (type_ == CQIllustratorRectShape::TYPE_RX)
    return rect->getRXPoint();
  else if (type_ == CQIllustratorRectShape::TYPE_RY)
    return rect->getRYPoint();
  else
    assert(false);
}

void
CQIllustratorRectShapeControlPoint::
setPoint(CQIllustratorShape *shape, const CPoint2D &point)
{
  CQIllustratorRectShape *rect = dynamic_cast<CQIllustratorRectShape *>(shape);
  assert(rect);

  if      (type_ == CQIllustratorRectShape::TYPE_LL)
    rect->setLL(point);
  else if (type_ == CQIllustratorRectShape::TYPE_UR)
    rect->setUR(point);
  else if (type_ == CQIllustratorRectShape::TYPE_RX)
    rect->setRXPoint(point);
  else if (type_ == CQIllustratorRectShape::TYPE_RY)
    rect->setRYPoint(point);
  else
    assert(false);
}

//--------------

CQIllustratorEllipseShape::
CQIllustratorEllipseShape(const CPoint2D &p1, const CPoint2D &p2,
                          double angle1, double angle2, CEllipseConnectType connectType) :
 CQIllustratorShape(), p1_(std::min(p1.x, p2.x), std::min(p1.y, p2.y)),
 p2_(std::max(p1.x, p2.x), std::max(p1.y, p2.y)), angle1_(angle1), angle2_(angle2),
 connectType_(connectType)
{
}

CQIllustratorEllipseShape::
CQIllustratorEllipseShape(const CQIllustratorEllipseShape &ellipse) :
 CQIllustratorShape(ellipse), p1_(ellipse.p1_), p2_(ellipse.p2_), angle1_(ellipse.angle1_),
 angle2_(ellipse.angle2_), connectType_(ellipse.connectType_)
{
}

CQIllustratorEllipseShape *
CQIllustratorEllipseShape::
dup() const
{
  return new CQIllustratorEllipseShape(*this);
}

void
CQIllustratorEllipseShape::
getControlPoints(ControlPointList &points, ControlType type) const
{
  if (type == CONTROL_GEOMETRY) {
    double xr = fabs(p2_.x - p1_.x)/2;
    double yr = fabs(p2_.y - p1_.y)/2;

    CPoint2D pxr(xr, 0.0);
    CPoint2D pyr(0.0, yr);

    double a1 = CMathGen::DegToRad(angle1_);
    double a2 = CMathGen::DegToRad(angle2_);

    double c1 = cos(a1), s1 = sin(a1);
    double c2 = cos(a2), s2 = sin(a2);

    CPoint2D pa1(c1, s1);
    CPoint2D pa2(c2, s2);

    CQIllustratorEllipseShapeControlPoint *cxr =
      new CQIllustratorEllipseShapeControlPoint(TYPE_RX, pxr);
    CQIllustratorEllipseShapeControlPoint *cyr =
      new CQIllustratorEllipseShapeControlPoint(TYPE_RY, pyr);
    CQIllustratorEllipseShapeControlPoint *ca1 =
      new CQIllustratorEllipseShapeControlPoint(TYPE_A1, pa1);
    CQIllustratorEllipseShapeControlPoint *ca2 =
      new CQIllustratorEllipseShapeControlPoint(TYPE_A2, pa2);

    points.push_back(cxr);
    points.push_back(cyr);
    points.push_back(ca1);
    points.push_back(ca2);
  }
  else
    CQIllustratorShape::getControlPoints(points, type);
}

void
CQIllustratorEllipseShape::
setControlPoint(const CQIllustratorShapeControlPoint *point)
{
  const CQIllustratorEllipseShapeControlPoint *epoint =
    dynamic_cast<const CQIllustratorEllipseShapeControlPoint *>(point);

  assert(epoint);

  const CMatrix2D &m = getFlatMatrix();

  CMatrix2D im = m.inverse();

  CPoint2D p = im*point->getPoint(this);

  CQIllustratorEllipseShape::ControlPointType type = epoint->getType();

  CPoint2D c = (p1_ + p2_)/2;

  if      (type == CQIllustratorEllipseShape::TYPE_RX) {
    double rx = std::max(0.0, p.x);

    p1_.x = c.x - rx/2.0;
    p2_.x = c.x + rx/2.0;
  }
  else if (type == CQIllustratorEllipseShape::TYPE_RY) {
    double ry = std::max(0.0, p.y);

    p1_.y = c.y - ry/2.0;
    p2_.y = c.y + ry/2.0;
  }
  else if (type == CQIllustratorEllipseShape::TYPE_A1) {
    setAngle1(CMathGen::RadToDeg(atan2(p.y, p.x)));
  }
  else if (type == CQIllustratorEllipseShape::TYPE_A2) {
    setAngle2(CMathGen::RadToDeg(atan2(p.y, p.x)));
  }

  invalidateBBox();
}

double
CQIllustratorEllipseShape::
getAngle1() const
{
  return angle1_;
}

double
CQIllustratorEllipseShape::
getAngle2() const
{
  return angle2_;
}

void
CQIllustratorEllipseShape::
setAngle1(double a1)
{
  angle1_ = a1;

  while (angle1_ <    0.0) angle1_ += 360.0;
  while (angle1_ >= 360.0) angle1_ -= 360.0;
}

void
CQIllustratorEllipseShape::
setAngle2(double a2)
{
  angle2_ = a2;

  while (angle2_ <=   0.0) angle2_ += 360.0;
  while (angle2_ >  360.0) angle2_ -= 360.0;
}

CPoint2D
CQIllustratorEllipseShape::
getRXPoint() const
{
  CPoint2D c = (p1_ + p2_)/2;

  const CMatrix2D &m = getFlatMatrix();

  return m*CPoint2D(p1_.x, c.y);
}

CPoint2D
CQIllustratorEllipseShape::
getRYPoint() const
{
  CPoint2D c = (p1_ + p2_)/2;

  const CMatrix2D &m = getFlatMatrix();

  return m*CPoint2D(c.x, p1_.y);
}

void
CQIllustratorEllipseShape::
setRXPoint(const CPoint2D &p)
{
  const CMatrix2D &m = getFlatMatrix();

  CMatrix2D im = m.inverse();

  CPoint2D p1 = im*p;

  CPoint2D c = (p1_ + p2_)/2;

  double xr = std::max(c.x - p1.x, 0.0);

  p1_.x = c.x - xr;
  p2_.x = c.x + xr;
}

void
CQIllustratorEllipseShape::
setRYPoint(const CPoint2D &p)
{
  const CMatrix2D &m = getFlatMatrix();

  CMatrix2D im = m.inverse();

  CPoint2D p1 = im*p;

  CPoint2D c = (p1_ + p2_)/2;

  double yr = std::max(c.y - p1.y, 0.0);

  p1_.y = c.y - yr;
  p2_.y = c.y + yr;
}

CPoint2D
CQIllustratorEllipseShape::
getAngle1Point() const
{
  CPoint2D c = (p1_ + p2_)/2;

  double xr = fabs(p2_.x - p1_.x)/2;
  double yr = fabs(p2_.y - p1_.y)/2;

  double a1 = CMathGen::DegToRad(angle1_);

  double c1 = cos(a1), s1 = sin(a1);

  const CMatrix2D &m = getFlatMatrix();

  return m*CPoint2D(c.x + c1*xr, c.y + s1*yr);
}

CPoint2D
CQIllustratorEllipseShape::
getAngle2Point() const
{
  CPoint2D c = (p1_ + p2_)/2;

  double xr = fabs(p2_.x - p1_.x)/2;
  double yr = fabs(p2_.y - p1_.y)/2;

  double a2 = CMathGen::DegToRad(angle2_);

  double c2 = cos(a2), s2 = sin(a2);

  const CMatrix2D &m = getFlatMatrix();

  return m*CPoint2D(c.x + c2*xr, c.y + s2*yr);
}

void
CQIllustratorEllipseShape::
setAngle1Point(const CPoint2D &p)
{
  CPoint2D c = (p1_ + p2_)/2;

  //double xr = fabs(p2_.x - p1_.x)/2;
  //double yr = fabs(p2_.y - p1_.y)/2;

  double dx = p.x - c.x;
  double dy = p.y - c.y;

  setAngle1(CMathGen::RadToDeg(atan2(dy, dx)));
}

void
CQIllustratorEllipseShape::
setAngle2Point(const CPoint2D &p)
{
  CPoint2D c = (p1_ + p2_)/2;

  //double xr = fabs(p2_.x - p1_.x)/2;
  //double yr = fabs(p2_.y - p1_.y)/2;

  double dx = p.x - c.x;
  double dy = p.y - c.y;

  setAngle2(CMathGen::RadToDeg(atan2(dy, dx)));
}

void
CQIllustratorEllipseShape::
updateBBox() const
{
  if (! bbox_valid_) {
    bbox_.reset();

    const CMatrix2D &m = getFlatMatrix();

    CPoint2D p1 = m*CPoint2D(p1_.x, p1_.y);
    CPoint2D p2 = m*CPoint2D(p2_.x, p1_.y);
    CPoint2D p3 = m*CPoint2D(p2_.x, p2_.y);
    CPoint2D p4 = m*CPoint2D(p1_.x, p2_.y);

    bbox_ += p1;
    bbox_ += p2;
    bbox_ += p3;
    bbox_ += p4;

    bbox_valid_ = true;
  }
}

bool
CQIllustratorEllipseShape::
getPolygon(CPolygon2D &) const
{
  return false;
}

bool
CQIllustratorEllipseShape::
getPath(CPathShapePartList &parts) const
{
  double xr = fabs(p2_.x - p1_.x)/2;
  double yr = fabs(p2_.y - p1_.y)/2;

  CPoint2D c = (p1_ + p2_)/2;

  double a1 = CMathGen::DegToRad(angle1_);
  double a2 = CMathGen::DegToRad(angle2_);
  double a3 = (a1 + a2)/2.0;

  double c1 = cos(a1), s1 = sin(a1);
  double c2 = cos(a2), s2 = sin(a2);
//double c3 = cos(a3), s3 = sin(a3);

  CPoint2D ps(c.x + xr*c1, c.y + yr*s1);
  CPoint2D pe(c.x + xr*c2, c.y + yr*s2);

//const CMatrix2D &m = getFlatMatrix();

  if (connectType_ == CELLIPSE_CONNECT_LINE) {
    parts.addPart(new CPathShapeMoveTo((ps + pe)/2));

    parts.addPart(new CPathShapeArc(c, xr, yr, a1, a3));
    parts.addPart(new CPathShapeArc(c, xr, yr, a3, a2));
  }
  else {
    parts.addPart(new CPathShapeMoveTo(c));

    parts.addPart(new CPathShapeArc(c, xr, yr, a1, a3));
    parts.addPart(new CPathShapeArc(c, xr, yr, a3, a2));
  }

  parts.addPart(new CPathShapeClose());

  return true;
}

void
CQIllustratorEllipseShape::
moveBy(const CPoint2D &d)
{
  assert(! getFixed());

  checkoutShape(CQIllustratorData::CHANGE_GEOMETRY);

  const CMatrix2D &m = getFlatMatrix();

  CMatrix2D im = m.inverse();

  p1_ = im*(m*p1_ + d);
  p2_ = im*(m*p2_ + d);

  invalidateBBox();

  checkinShape(CQIllustratorData::CHANGE_GEOMETRY);
}

void
CQIllustratorEllipseShape::
resizeBy(double dw, double dh)
{
  double x = bbox_.getXMin();
  double y = bbox_.getYMin();

  double w = bbox_.getWidth ();
  double h = bbox_.getHeight();

  double xs = (w + dw)/w;
  double ys = (h + dh)/h;

  const CMatrix2D &m = getFlatMatrix();

  CMatrix2D im = m.inverse();

  CPoint2D p1 = m*p1_;
  CPoint2D p2 = m*p2_;

  p1.x = x + (p1.x - x)*xs;
  p1.y = y + (p1.y - y)*ys;
  p2.x = x + (p2.x - x)*xs;
  p2.y = y + (p2.y - y)*ys;

  p1_ = im*p1;
  p2_ = im*p2;

  invalidateBBox();
}

bool
CQIllustratorEllipseShape::
flip(bool x_axis)
{
  // angles ?
  const CMatrix2D &m = getFlatMatrix();

  CMatrix2D im = m.inverse();

  CPoint2D rc = getRotateCenter();

  CPoint2D p1 = m*p1_;
  CPoint2D p2 = m*p2_;

  p1_ = im*p1.flip(rc, x_axis);
  p2_ = im*p2.flip(rc, x_axis);

  return true;
}

void
CQIllustratorEllipseShape::
drawShape(CQIllustratorShapeDrawer *drawer) const
{
  double xr = fabs(p2_.x - p1_.x)/2;
  double yr = fabs(p2_.y - p1_.y)/2;

  CPoint2D c = (p1_ + p2_)/2;

  double a1 = CMathGen::DegToRad(angle1_);
  double a2 = CMathGen::DegToRad(angle2_);
  double a3 = (a1 + a2)/2.0;

  double c1 = cos(a1), s1 = sin(a1);
  double c2 = cos(a2), s2 = sin(a2);
//double c3 = cos(a3), s3 = sin(a3);

  CPoint2D ps(c.x + xr*c1, c.y + yr*s1);
  CPoint2D pe(c.x + xr*c2, c.y + yr*s2);

  const CMatrix2D &m = getFlatMatrix();

  drawer->pushMatrix(m, true);

  drawer->pathInit();

  if (connectType_ == CELLIPSE_CONNECT_LINE) {
    drawer->pathMoveTo((ps + pe)/2);

    drawer->pathArc(c, xr, yr, a1, a3);
    drawer->pathArc(c, xr, yr, a3, a2);
  }
  else {
    drawer->pathMoveTo(c);

    drawer->pathArc(c, xr, yr, a1, a3);
    drawer->pathArc(c, xr, yr, a3, a2);
  }

  drawer->pathClose();

  if (! clip_) {
    fill_  .draw(this, drawer);
    stroke_.draw(this, drawer);
  }
  else
    drawer->pathClip();

  drawer->popMatrix();
}

CQIllustratorShapeGeometry *
CQIllustratorEllipseShape::
getGeometry()
{
  return new CQIllustratorEllipseGeometry(fixed_, rcenter_, m_, p1_, p2_,
                                          angle1_, angle2_, connectType_);
}

void
CQIllustratorEllipseShape::
doSetGeometry(const CQIllustratorShapeGeometry *geom)
{
  const CQIllustratorEllipseGeometry *geom1 =
    dynamic_cast<const CQIllustratorEllipseGeometry *>(geom);

  if (! geom1) return;

  fixed_       = geom1->fixed_;
  rcenter_     = geom1->rcenter_;
  m_           = geom1->m_;
  p1_          = geom1->p1_;
  p2_          = geom1->p2_;
  angle1_      = geom1->angle1_;
  angle2_      = geom1->angle2_;
  connectType_ = geom1->connectType_;

  invalidateBBox();
}

void
CQIllustratorEllipseShape::
saveSVG(const CQIllustratorSaveData &saveData)
{
  CFile *file = saveData.file;

  double a = getAngle();

  CMatrix2D m1 = CMatrix2D::rotation(-a);

  const CMatrix2D &m = getFlatMatrix();

  CPoint2D p1 = m1*m*CPoint2D(p1_.x, p1_.y);
  CPoint2D p2 = m1*m*CPoint2D(p2_.x, p2_.y);

  double top = saveData.bbox.getYMax();

  CPoint2D c = (p1 + p2)/2; c.y = top - c.y;

  double xr = fabs(p2.x - p1.x)/2;
  double yr = fabs(p2.y - p1.y)/2;

  CMatrix2D m2 = CMatrix2D::translation(-c.x, -c.y)*
                 CMatrix2D::rotation(a)*
                 CMatrix2D::translation( c.x,  c.y);

  file->printf("<ellipse cx=\"%g\" cy=\"%g\" rx=\"%g\" ry=\"%g\"%s %s/>\n",
               c.x, c.y, xr, yr, getSVGMatrix(m2).c_str(), getSVGStroke().c_str());
}

void
CQIllustratorEllipseShape::
saveCmd(const CQIllustratorSaveData &saveData)
{
  CFile *file = saveData.file;

  double a = getAngle();

  CMatrix2D m1 = CMatrix2D::rotation(-a);

  const CMatrix2D &m = getFlatMatrix();

  CPoint2D c = (m*p1_ + m*p2_)/2;

  CPoint2D p1 = m1*m*p1_;
  CPoint2D p2 = m1*m*p2_;

  double xr = fabs(p2.x - p1.x)/2;
  double yr = fabs(p2.y - p1.y)/2;

  if (name_ != "")
    file->printf("create_ellipse -name %s -x %g -y %g -xr %g -yr %g -a %g\n",
                 name_.c_str(), c.x, c.y, xr, yr, 180.0*a/M_PI);
  else
    file->printf("create_ellipse -x %g -y %g -xr %g -yr %g -a %g\n",
                 c.x, c.y, xr, yr, 180.0*a/M_PI);
}

double
CQIllustratorEllipseShape::
getAngle() const
{
  const CMatrix2D &m = getFlatMatrix();

  CPoint2D p1 = m*CPoint2D(p1_.x, p1_.y);
  CPoint2D p2 = m*CPoint2D(p2_.x, p1_.y);

  return atan2(p2.y - p1.y, p2.x - p1.x);
}

//-----

CQIllustratorEllipseShapeControlPoint::
CQIllustratorEllipseShapeControlPoint(CQIllustratorEllipseShape::ControlPointType type,
                                      const CPoint2D &p) :
 CQIllustratorShapeControlPoint((uint) type, p), type_(type)
{
}

CQIllustratorEllipseShapeControlPoint *
CQIllustratorEllipseShapeControlPoint::
dup() const
{
  return new CQIllustratorEllipseShapeControlPoint(type_, point_);
}

CPoint2D
CQIllustratorEllipseShapeControlPoint::
getPoint(const CQIllustratorShape *shape) const
{
  const CQIllustratorEllipseShape *ellipse =
    dynamic_cast<const CQIllustratorEllipseShape *>(shape);
  assert(ellipse);

  if      (type_ == CQIllustratorEllipseShape::TYPE_RX)
    return ellipse->getRXPoint();
  else if (type_ == CQIllustratorEllipseShape::TYPE_RY)
    return ellipse->getRYPoint();
  else if (type_ == CQIllustratorEllipseShape::TYPE_A1)
    return ellipse->getAngle1Point();
  else if (type_ == CQIllustratorEllipseShape::TYPE_A2)
    return ellipse->getAngle2Point();
  else
    assert(false);
}

void
CQIllustratorEllipseShapeControlPoint::
setPoint(CQIllustratorShape *shape, const CPoint2D &point)
{
  CQIllustratorEllipseShape *ellipse = dynamic_cast<CQIllustratorEllipseShape *>(shape);
  assert(ellipse);

  if      (type_ == CQIllustratorEllipseShape::TYPE_RX)
    ellipse->setRXPoint(point);
  else if (type_ == CQIllustratorEllipseShape::TYPE_RY)
    ellipse->setRYPoint(point);
  else if (type_ == CQIllustratorEllipseShape::TYPE_A1)
    ellipse->setAngle1Point(point);
  else if (type_ == CQIllustratorEllipseShape::TYPE_A2)
    ellipse->setAngle2Point(point);
  else
    assert(false);
}

//--------------

CQIllustratorNPolyShape::
CQIllustratorNPolyShape(const CPoint2D &c, uint n, double r, double a) :
 CQIllustratorShape(), c_(c), n_(n), r_(r), a_(a)
{
}

CQIllustratorNPolyShape::
CQIllustratorNPolyShape(const CQIllustratorNPolyShape &poly) :
 CQIllustratorShape(poly), c_(poly.c_), n_(poly.n_), r_(poly.r_), a_(poly.a_)
{
}

CQIllustratorNPolyShape *
CQIllustratorNPolyShape::
dup() const
{
  return new CQIllustratorNPolyShape(*this);
}

void
CQIllustratorNPolyShape::
getControlPoints(ControlPointList &points, ControlType type) const
{
  if (type == CONTROL_GEOMETRY) {
    CPoint2D pc = getCenterPoint();
    CPoint2D p  = getPoint();

    CQIllustratorNPolyShapeControlPoint *c =
      new CQIllustratorNPolyShapeControlPoint(TYPE_CENTER, pc);
    CQIllustratorNPolyShapeControlPoint *r =
      new CQIllustratorNPolyShapeControlPoint(TYPE_RADIUS, p);

    points.push_back(c);
    points.push_back(r);
  }
  else
    CQIllustratorShape::getControlPoints(points, type);
}

void
CQIllustratorNPolyShape::
setControlPoint(const CQIllustratorShapeControlPoint *point)
{
  const CQIllustratorNPolyShapeControlPoint *spoint =
    dynamic_cast<const CQIllustratorNPolyShapeControlPoint *>(point);
  if (! spoint) assert(false);

  CPoint2D p = point->getPoint(this);

  CQIllustratorNPolyShape::ControlPointType type = spoint->getType();

  if      (type == CQIllustratorNPolyShape::TYPE_CENTER)
    setCenterPoint(p);
  else if (type == CQIllustratorNPolyShape::TYPE_RADIUS)
    setPoint(p);
}

CPoint2D
CQIllustratorNPolyShape::
getRotateCenter() const
{
  return c_ + rcenter_;
}

void
CQIllustratorNPolyShape::
setNum(uint n)
{
  n_ = n;
}

void
CQIllustratorNPolyShape::
setRadius(double r)
{
  r_ = r;
}

void
CQIllustratorNPolyShape::
setAngle(double a)
{
  a_ = a;
}

CPoint2D
CQIllustratorNPolyShape::
getCenterPoint() const
{
  const CMatrix2D &m = getFlatMatrix();

  return m*c_;
}

void
CQIllustratorNPolyShape::
setCenterPoint(const CPoint2D &c)
{
  const CMatrix2D &m = getFlatMatrix();

  CMatrix2D im = m.inverse();

  c_ = im*c;

  invalidateBBox();
}

CPoint2D
CQIllustratorNPolyShape::
getPoint() const
{
  const CMatrix2D &m = getFlatMatrix();

  double c = cos(a_), s = sin(a_);

  return m*CPoint2D(c_.x + r_*c, c_.y + r_*s);
}

void
CQIllustratorNPolyShape::
setPoint(const CPoint2D &p)
{
  const CMatrix2D &m = getFlatMatrix();

  CMatrix2D im = m.inverse();

  CVector2D v(c_, im*p);

  r_ = v.length();
  a_ = v.angle();

  invalidateBBox();
}

void
CQIllustratorNPolyShape::
updateBBox() const
{
  if (! bbox_valid_) {
    bbox_.reset();

    const CMatrix2D &m = getFlatMatrix();

    double da = 2*M_PI/n_;

    for (uint i = 0; i < n_; ++i) {
      double a = a_ + i*da;

      double c = cos(a), s = sin(a);

      bbox_ += m*CPoint2D(c_.x + r_*c, c_.y + r_*s);
    }

    bbox_valid_ = true;
  }
}

bool
CQIllustratorNPolyShape::
getPolygon(CPolygon2D &polygon) const
{
  const CMatrix2D &m = getFlatMatrix();

  double da = 2*M_PI/n_;

  for (uint i = 0; i < n_; ++i) {
    double a = a_ + i*da;

    double c = cos(a), s = sin(a);

    CPoint2D p = m*CPoint2D(c_.x + r_*c, c_.y + r_*s);

    polygon.addPoint(p);
  }

  return true;
}

bool
CQIllustratorNPolyShape::
getPath(CPathShapePartList &parts) const
{
  const CMatrix2D &m = getFlatMatrix();

  double da = 2*M_PI/n_;

  for (uint i = 0; i < n_; ++i) {
    double a = a_ + i*da;

    double c = cos(a), s = sin(a);

    CPoint2D p = m*CPoint2D(c_.x + r_*c, c_.y + r_*s);

    if (i == 0)
      parts.addPart(new CPathShapeMoveTo(p));
    else
      parts.addPart(new CPathShapeLineTo(p));
  }

  parts.addPart(new CPathShapeClose());

  return true;
}

void
CQIllustratorNPolyShape::
moveBy(const CPoint2D &d)
{
  assert(! getFixed());

  checkoutShape(CQIllustratorData::CHANGE_GEOMETRY);

  const CMatrix2D &m = getFlatMatrix();

  CMatrix2D im = m.inverse();

  c_ = im*(m*c_ + d);

  invalidateBBox();

  checkinShape(CQIllustratorData::CHANGE_GEOMETRY);
}

bool
CQIllustratorNPolyShape::
flip(bool)
{
  return false;
}

void
CQIllustratorNPolyShape::
drawShape(CQIllustratorShapeDrawer *drawer) const
{
  const CMatrix2D &m = getFlatMatrix();

  drawer->pushMatrix(m, true);

  double da = 2*M_PI/n_;

  std::vector<CPoint2D> p;

  p.resize(n_);

  for (uint i = 0; i < n_; ++i) {
    double a = a_ + i*da;

    double c = cos(a), s = sin(a);

    p[i] = CPoint2D(c_.x + r_*c, c_.y + r_*s);
  }

  drawer->pathInit();

  drawer->pathMoveTo(p[0]);

  for (uint i = 1; i < n_; ++i)
    drawer->pathLineTo(p[i]);

  drawer->pathClose();

  if (! clip_) {
    fill_  .draw(this, drawer);
    stroke_.draw(this, drawer);
  }
  else
    drawer->pathClip();

  drawer->popMatrix();
}

CQIllustratorShapeGeometry *
CQIllustratorNPolyShape::
getGeometry()
{
  return new CQIllustratorNPolyGeometry(fixed_, rcenter_, m_, c_, n_, r_, a_);
}

void
CQIllustratorNPolyShape::
doSetGeometry(const CQIllustratorShapeGeometry *geom)
{
  const CQIllustratorNPolyGeometry *geom1 =
    dynamic_cast<const CQIllustratorNPolyGeometry *>(geom);

  if (! geom1) return;

  fixed_   = geom1->fixed_;
  rcenter_ = geom1->rcenter_;
  m_       = geom1->m_;
  c_       = geom1->c_;
  n_       = geom1->n_;
  r_       = geom1->r_;
  a_       = geom1->a_;

  invalidateBBox();
}

void
CQIllustratorNPolyShape::
saveSVG(const CQIllustratorSaveData &saveData)
{
  CFile *file = saveData.file;

  std::vector<CPoint2D> p;

  getPoints(p);

  uint n = p.size();

  file->printf("<path d=\"");

  file->printf("M %g,%g ", p[0].x, p[0].y);

  for (uint i = 1; i < n; ++i)
    file->printf("L %g,%g ", p[i].x, p[i].y);

  file->printf("z\"%s %s/>\n", getSVGMatrix().c_str(), getSVGStroke().c_str());
}

void
CQIllustratorNPolyShape::
saveCmd(const CQIllustratorSaveData & /*saveData*/)
{
}

void
CQIllustratorNPolyShape::
getPoints(std::vector<CPoint2D> &p) const
{
  const CMatrix2D &m = getFlatMatrix();

  double da = 2*M_PI/n_;

  p.resize(n_);

  for (uint i = 0; i < n_; ++i) {
    double a = a_ + i*da;

    double c = cos(a), s = sin(a);

    p[i] = m*CPoint2D(c_.x + r_*c, c_.y + r_*s);
  }
}

//-----

CQIllustratorNPolyShapeControlPoint::
CQIllustratorNPolyShapeControlPoint(CQIllustratorNPolyShape::ControlPointType type,
                                    const CPoint2D &p) :
 CQIllustratorShapeControlPoint(uint(type), p), type_(type)
{
}

CQIllustratorNPolyShapeControlPoint *
CQIllustratorNPolyShapeControlPoint::
dup() const
{
  return new CQIllustratorNPolyShapeControlPoint(type_, point_);
}

CPoint2D
CQIllustratorNPolyShapeControlPoint::
getPoint(const CQIllustratorShape *shape) const
{
  const CQIllustratorNPolyShape *star = dynamic_cast<const CQIllustratorNPolyShape *>(shape);
  assert(star);

  if      (type_ == CQIllustratorNPolyShape::TYPE_CENTER)
    return star->getCenterPoint();
  else if (type_ == CQIllustratorNPolyShape::TYPE_RADIUS)
    return star->getPoint();
  else
    assert(false);
}

void
CQIllustratorNPolyShapeControlPoint::
setPoint(CQIllustratorShape *shape, const CPoint2D &point)
{
  CQIllustratorNPolyShape *star = dynamic_cast<CQIllustratorNPolyShape *>(shape);
  assert(star);

  if      (type_ == CQIllustratorNPolyShape::TYPE_CENTER)
    star->setCenterPoint(point);
  else if (type_ == CQIllustratorNPolyShape::TYPE_RADIUS)
    star->setPoint(point);
  else
    assert(false);
}

//--------------

CQIllustratorStarShape::
CQIllustratorStarShape(const CPoint2D &c, uint n, double r1, double r2, double a1, double a2) :
 CQIllustratorShape(), c_(c), n_(n), r1_(r1), r2_(r2), a1_(a1), a2_(a2)
{
}

CQIllustratorStarShape::
CQIllustratorStarShape(const CQIllustratorStarShape &star) :
 CQIllustratorShape(star), c_(star.c_), n_(star.n_), r1_(star.r1_), r2_(star.r2_),
 a1_(star.a1_), a2_(star.a2_)
{
}

CQIllustratorStarShape *
CQIllustratorStarShape::
dup() const
{
  return new CQIllustratorStarShape(*this);
}

void
CQIllustratorStarShape::
getControlPoints(ControlPointList &points, ControlType type) const
{
  if (type == CONTROL_GEOMETRY) {
    CPoint2D pc = getCenterPoint();
    CPoint2D p1 = getInnerPoint();
    CPoint2D p2 = getOuterPoint();

    CQIllustratorStarShapeControlPoint *c  =
      new CQIllustratorStarShapeControlPoint(TYPE_CENTER, pc);
    CQIllustratorStarShapeControlPoint *ri =
      new CQIllustratorStarShapeControlPoint(TYPE_IR    , p1);
    CQIllustratorStarShapeControlPoint *ro =
      new CQIllustratorStarShapeControlPoint(TYPE_OR    , p2);

    points.push_back(c);
    points.push_back(ri);
    points.push_back(ro);
  }
  else
    CQIllustratorShape::getControlPoints(points, type);
}

void
CQIllustratorStarShape::
setControlPoint(const CQIllustratorShapeControlPoint *point)
{
  const CQIllustratorStarShapeControlPoint *spoint =
    dynamic_cast<const CQIllustratorStarShapeControlPoint *>(point);
  if (! spoint) assert(false);

  CPoint2D p = point->getPoint(this);

  CQIllustratorStarShape::ControlPointType type = spoint->getType();

  if      (type == CQIllustratorStarShape::TYPE_CENTER)
    setCenterPoint(p);
  else if (type == CQIllustratorStarShape::TYPE_IR)
    setInnerPoint(p);
  else if (type == CQIllustratorStarShape::TYPE_OR)
    setOuterPoint(p);
}

CPoint2D
CQIllustratorStarShape::
getRotateCenter() const
{
  return c_ + rcenter_;
}

void
CQIllustratorStarShape::
setNum(uint n)
{
  n_ = n;
}

void
CQIllustratorStarShape::
setInnerRadius(double r)
{
  r1_ = r;
}

void
CQIllustratorStarShape::
setOuterRadius(double r)
{
  r2_ = r;
}

void
CQIllustratorStarShape::
setInnerAngle(double a)
{
  a1_ = a;
}

void
CQIllustratorStarShape::
setOuterAngle(double a)
{
  a2_ = a;
}

CPoint2D
CQIllustratorStarShape::
getCenterPoint() const
{
  const CMatrix2D &m = getFlatMatrix();

  return m*c_;
}

void
CQIllustratorStarShape::
setCenterPoint(const CPoint2D &c)
{
  const CMatrix2D &m = getFlatMatrix();

  CMatrix2D im = m.inverse();

  c_ = im*c;

  invalidateBBox();
}

CPoint2D
CQIllustratorStarShape::
getInnerPoint() const
{
  const CMatrix2D &m = getFlatMatrix();

  double c1 = cos(CMathGen::DegToRad(a1_));
  double s1 = sin(CMathGen::DegToRad(a1_));

  return m*CPoint2D(c_.x + r1_*c1, c_.y + r1_*s1);
}

void
CQIllustratorStarShape::
setInnerPoint(const CPoint2D &p)
{
  const CMatrix2D &m = getFlatMatrix();

  CMatrix2D im = m.inverse();

  CVector2D v(c_, im*p);

  r1_ = v.length();
  a1_ = CMathGen::RadToDeg(v.angle());

  invalidateBBox();
}

CPoint2D
CQIllustratorStarShape::
getOuterPoint() const
{
  const CMatrix2D &m = getFlatMatrix();

  double c2 = cos(CMathGen::DegToRad(a2_));
  double s2 = sin(CMathGen::DegToRad(a2_));

  return m*CPoint2D(c_.x + r2_*c2, c_.y + r2_*s2);
}

void
CQIllustratorStarShape::
setOuterPoint(const CPoint2D &p)
{
  const CMatrix2D &m = getFlatMatrix();

  CMatrix2D im = m.inverse();

  CVector2D v(c_, im*p);

  r2_ = v.length();
  a2_ = CMathGen::RadToDeg(v.angle());

  invalidateBBox();
}

void
CQIllustratorStarShape::
updateBBox() const
{
  if (! bbox_valid_) {
    bbox_.reset();

    const CMatrix2D &m = getFlatMatrix();

    double da = 2*M_PI/n_;

    for (uint i = 0; i < n_; ++i) {
      double a1 = CMathGen::DegToRad(a1_) + i*da;
      double a2 = CMathGen::DegToRad(a2_) + i*da;

      double c1 = cos(a1), s1 = sin(a1);
      double c2 = cos(a2), s2 = sin(a2);

      bbox_ += m*CPoint2D(c_.x + r1_*c1, c_.y + r1_*s1);
      bbox_ += m*CPoint2D(c_.x + r2_*c2, c_.y + r2_*s2);
    }

    bbox_valid_ = true;
  }
}

bool
CQIllustratorStarShape::
getPolygon(CPolygon2D &polygon) const
{
  const CMatrix2D &m = getFlatMatrix();

  double da = 2*M_PI/n_;

  for (uint i = 0; i < n_; ++i) {
    double a1 = CMathGen::DegToRad(a1_) + i*da;
    double a2 = CMathGen::DegToRad(a2_) + i*da;

    double c1 = cos(a1), s1 = sin(a1);
    double c2 = cos(a2), s2 = sin(a2);

    CPoint2D p1 = m*CPoint2D(c_.x + r1_*c1, c_.y + r1_*s1);
    CPoint2D p2 = m*CPoint2D(c_.x + r2_*c2, c_.y + r2_*s2);

    polygon.addPoint(p1);
    polygon.addPoint(p2);
  }

  return true;
}

bool
CQIllustratorStarShape::
getPath(CPathShapePartList &parts) const
{
  const CMatrix2D &m = getFlatMatrix();

  double da = 2*M_PI/n_;

  for (uint i = 0; i < n_; ++i) {
    double a1 = CMathGen::DegToRad(a1_) + i*da;
    double a2 = CMathGen::DegToRad(a2_) + i*da;

    double c1 = cos(a1), s1 = sin(a1);
    double c2 = cos(a2), s2 = sin(a2);

    CPoint2D p1 = m*CPoint2D(c_.x + r1_*c1, c_.y + r1_*s1);
    CPoint2D p2 = m*CPoint2D(c_.x + r2_*c2, c_.y + r2_*s2);

    if (i == 0)
      parts.addPart(new CPathShapeMoveTo(p1));
    else
      parts.addPart(new CPathShapeLineTo(p1));

    parts.addPart(new CPathShapeLineTo(p2));
  }

  parts.addPart(new CPathShapeClose());

  return true;
}

void
CQIllustratorStarShape::
moveBy(const CPoint2D &d)
{
  assert(! getFixed());

  checkoutShape(CQIllustratorData::CHANGE_GEOMETRY);

  const CMatrix2D &m = getFlatMatrix();

  CMatrix2D im = m.inverse();

  c_ = im*(m*c_ + d);

  invalidateBBox();

  checkinShape(CQIllustratorData::CHANGE_GEOMETRY);
}

bool
CQIllustratorStarShape::
flip(bool)
{
  return false;
}

void
CQIllustratorStarShape::
drawShape(CQIllustratorShapeDrawer *drawer) const
{
  const CMatrix2D &m = getFlatMatrix();

  drawer->pushMatrix(m, true);

  double da = 2*M_PI/n_;

  std::vector<CPoint2D> pi, po;

  pi.resize(n_);
  po.resize(n_);

  for (uint i = 0; i < n_; ++i) {
    double a1 = CMathGen::DegToRad(a1_) + i*da;
    double a2 = CMathGen::DegToRad(a2_) + i*da;

    double c1 = cos(a1), s1 = sin(a1);
    double c2 = cos(a2), s2 = sin(a2);

    pi[i] = CPoint2D(c_.x + r1_*c1, c_.y + r1_*s1);
    po[i] = CPoint2D(c_.x + r2_*c2, c_.y + r2_*s2);
  }

  drawer->pathInit();

  drawer->pathMoveTo(pi[0]);
  drawer->pathLineTo(po[0]);

  for (uint i = 1; i < n_; ++i) {
    drawer->pathLineTo(pi[i]);
    drawer->pathLineTo(po[i]);
  }

  drawer->pathClose();

  if (! clip_) {
    fill_  .draw(this, drawer);
    stroke_.draw(this, drawer);
  }
  else
    drawer->pathClip();

  drawer->popMatrix();
}

CQIllustratorShapeGeometry *
CQIllustratorStarShape::
getGeometry()
{
  return new CQIllustratorStarGeometry(fixed_, rcenter_, m_, c_, n_, r1_, r2_, a1_, a2_);
}

void
CQIllustratorStarShape::
doSetGeometry(const CQIllustratorShapeGeometry *geom)
{
  const CQIllustratorStarGeometry *geom1 = dynamic_cast<const CQIllustratorStarGeometry *>(geom);

  if (! geom1) return;

  fixed_   = geom1->fixed_;
  rcenter_ = geom1->rcenter_;
  m_       = geom1->m_;
  c_       = geom1->c_;
  n_       = geom1->n_;
  r1_      = geom1->r1_;
  r2_      = geom1->r2_;
  a1_      = geom1->a1_;
  a2_      = geom1->a2_;

  invalidateBBox();
}

void
CQIllustratorStarShape::
saveSVG(const CQIllustratorSaveData &saveData)
{
  CFile *file = saveData.file;

  std::vector<CPoint2D> p1, p2;

  getPoints(p1, p2);

  uint n = p1.size();

  file->printf("<path d=\"");

  file->printf("M %g,%g ", p1[0].x, p1[0].y);
  file->printf("L %g,%g ", p2[0].x, p2[0].y);

  for (uint i = 1; i < n; ++i) {
    file->printf("L %g,%g ", p1[i].x, p1[i].y);
    file->printf("L %g,%g ", p2[i].x, p2[i].y);
  }

  file->printf("z\"%s %s/>\n", getSVGMatrix().c_str(), getSVGStroke().c_str());
}

void
CQIllustratorStarShape::
saveCmd(const CQIllustratorSaveData & /*saveData*/)
{
}

void
CQIllustratorStarShape::
getPoints(std::vector<CPoint2D> &pi, std::vector<CPoint2D> &po) const
{
  const CMatrix2D &m = getFlatMatrix();

  double da = 2*M_PI/n_;

  pi.resize(n_);
  po.resize(n_);

  for (uint i = 0; i < n_; ++i) {
    double a1 = CMathGen::DegToRad(a1_) + i*da;
    double a2 = CMathGen::DegToRad(a2_) + i*da;

    double c1 = cos(a1), s1 = sin(a1);
    double c2 = cos(a2), s2 = sin(a2);

    pi[i] = m*CPoint2D(c_.x + r1_*c1, c_.y + r1_*s1);
    po[i] = m*CPoint2D(c_.x + r2_*c2, c_.y + r2_*s2);
  }
}

//-----

CQIllustratorStarShapeControlPoint::
CQIllustratorStarShapeControlPoint(CQIllustratorStarShape::ControlPointType type,
                                   const CPoint2D &p) :
 CQIllustratorShapeControlPoint(uint(type), p), type_(type)
{
}

CQIllustratorStarShapeControlPoint *
CQIllustratorStarShapeControlPoint::
dup() const
{
  return new CQIllustratorStarShapeControlPoint(type_, point_);
}

CPoint2D
CQIllustratorStarShapeControlPoint::
getPoint(const CQIllustratorShape *shape) const
{
  const CQIllustratorStarShape *star = dynamic_cast<const CQIllustratorStarShape *>(shape);
  assert(star);

  if      (type_ == CQIllustratorStarShape::TYPE_CENTER)
    return star->getCenterPoint();
  else if (type_ == CQIllustratorStarShape::TYPE_IR)
    return star->getInnerPoint();
  else if (type_ == CQIllustratorStarShape::TYPE_OR)
    return star->getOuterPoint();
  else
    assert(false);
}

void
CQIllustratorStarShapeControlPoint::
setPoint(CQIllustratorShape *shape, const CPoint2D &point)
{
  CQIllustratorStarShape *star = dynamic_cast<CQIllustratorStarShape *>(shape);
  assert(star);

  if      (type_ == CQIllustratorStarShape::TYPE_CENTER)
    star->setCenterPoint(point);
  else if (type_ == CQIllustratorStarShape::TYPE_IR)
    star->setInnerPoint(point);
  else if (type_ == CQIllustratorStarShape::TYPE_OR)
    star->setOuterPoint(point);
  else
    assert(false);
}

//--------------

CQIllustratorPolygonShape::
CQIllustratorPolygonShape(const PointList &points) :
 CQIllustratorShape(), points_(points)
{
}

CQIllustratorPolygonShape::
CQIllustratorPolygonShape(const CQIllustratorPolygonShape &polygon) :
 CQIllustratorShape(polygon), points_(polygon.points_)
{
}

CQIllustratorPolygonShape *
CQIllustratorPolygonShape::
dup() const
{
  return new CQIllustratorPolygonShape(*this);
}

CPoint2D
CQIllustratorPolygonShape::
getPoint(uint i) const
{
  assert(i < points_.size());

  const CMatrix2D &m = getFlatMatrix();

  return m*points_[i];
}

void
CQIllustratorPolygonShape::
setPoint(uint i, const CPoint2D &p)
{
  assert(i < points_.size());

  const CMatrix2D &m = getFlatMatrix();

  CMatrix2D im = m.inverse();

  points_[i] = im*p;
}

double
CQIllustratorPolygonShape::
distance(const CPoint2D &p) const
{
  double dist = 1E50;

  const CMatrix2D &m = getFlatMatrix();

  uint num_points = points_.size();

  for (uint i = 0; i < num_points; ++i) {
    CPoint2D p1 = m*points_[i];

    dist = std::min(fabs(p1.x - p.x), fabs(p1.y - p.y));
  }

  return dist;
}

bool
CQIllustratorPolygonShape::
inside(const CPoint2D &p) const
{
  PointList points;

  const CMatrix2D &m = getFlatMatrix();

  uint num_points = points_.size();

  points.resize(num_points);

  for (uint i = 0; i < num_points; ++i)
    points[i] = m*points_[i];

  return CMathGeom2D::PointInsideEvenOdd(p, &points[0], num_points);
}

void
CQIllustratorPolygonShape::
getControlPoints(ControlPointList &points, ControlType type) const
{
  if (type == CONTROL_GEOMETRY) {
    const CMatrix2D &m = getFlatMatrix();

    uint num_points = points_.size();

    for (uint i = 0; i < num_points; ++i) {
      CPoint2D p1 = m*points_[i];

      points.push_back(new CQIllustratorPolygonShapeControlPoint(i, p1));
    }
  }
  else
    CQIllustratorShape::getControlPoints(points, type);
}

void
CQIllustratorPolygonShape::
setControlPoint(const CQIllustratorShapeControlPoint *point)
{
  const CQIllustratorPolygonShapeControlPoint *ppoint =
    dynamic_cast<const CQIllustratorPolygonShapeControlPoint *>(point);
  if (! ppoint) assert(false);

  const CMatrix2D &m = getFlatMatrix();

  CMatrix2D im = m.inverse();

  points_[ppoint->getInd()] = im*point->getPoint(this);

  invalidateBBox();
}

bool
CQIllustratorPolygonShape::
addPoint(const CQIllustratorShapeControlPoint *before_point, const CPoint2D &p)
{
  points_.push_back(p);

  if (before_point != 0) {
    const CQIllustratorPolygonShapeControlPoint *before_point1 =
      dynamic_cast<const CQIllustratorPolygonShapeControlPoint *>(before_point);

    int num_points = points_.size();

    if (before_point1->getInd() < 0 || before_point1->getInd() >= int(num_points)) return false;

    for (int i = num_points - 1; i >= before_point1->getInd(); --i)
      points_[i + 1] = points_[i];

    points_[before_point1->getInd()] = p;
  }

  invalidateBBox();

  return true;
}

bool
CQIllustratorPolygonShape::
doRemovePoint(const CQIllustratorShapeControlPoint *point)
{
  const CQIllustratorPolygonShapeControlPoint *ppoint =
    dynamic_cast<const CQIllustratorPolygonShapeControlPoint *>(point);
  if (! ppoint) assert(false);

  uint num_points = points_.size();

  if (ppoint->getInd() < 0 || ppoint->getInd() >= int(num_points)) return false;

  for (uint i = ppoint->getInd() + 1; i < num_points; ++i)
    points_[i - 1] = points_[i];

  points_.pop_back();

  return true;
}

void
CQIllustratorPolygonShape::
updateBBox() const
{
  if (! bbox_valid_) {
    bbox_.reset();

    const CMatrix2D &m = getFlatMatrix();

    uint num_points = points_.size();

    for (uint i = 0; i < num_points; ++i) {
      CPoint2D p = m*points_[i];

      bbox_ += p;
    }

    bbox_valid_ = true;
  }
}

void
CQIllustratorPolygonShape::
setPoints(const CPolygon2D &polygon)
{
  const CPolygon2D::PointList &points = polygon.getPoints();

  uint num_points = points.size();

  for (uint i = 0; i < num_points; ++i)
    addPoint(points[i]);
}

void
CQIllustratorPolygonShape::
addPoint(const CPoint2D &p)
{
  const CMatrix2D &m = getFlatMatrix();

  CMatrix2D im = m.inverse();

  points_.push_back(im*p);

  invalidateBBox();
}

bool
CQIllustratorPolygonShape::
getPolygon(CPolygon2D &polygon) const
{
  const CMatrix2D &m = getFlatMatrix();

  uint num_points = points_.size();

  for (uint i = 0; i < num_points; ++i)
    polygon.addPoint(m*points_[i]);

  return true;
}

bool
CQIllustratorPolygonShape::
getPath(CPathShapePartList &parts) const
{
  const CMatrix2D &m = getFlatMatrix();

  uint num_points = points_.size();

  for (uint i = 0; i < num_points; ++i) {
    CPoint2D p = m*points_[i];

    if (i == 0)
      parts.addPart(new CPathShapeMoveTo(p));
    else
      parts.addPart(new CPathShapeLineTo(p));
  }

  parts.addPart(new CPathShapeClose());

  return true;
}

void
CQIllustratorPolygonShape::
moveBy(const CPoint2D &d)
{
  assert(! getFixed());

  checkoutShape(CQIllustratorData::CHANGE_GEOMETRY);

  const CMatrix2D &m = getFlatMatrix();

  CMatrix2D im = m.inverse();

  uint num_points = points_.size();

  for (uint i = 0; i < num_points; ++i)
    points_[i] = im*(m*points_[i] + d);

  invalidateBBox();

  checkinShape(CQIllustratorData::CHANGE_GEOMETRY);
}

void
CQIllustratorPolygonShape::
resizeBy(double dw, double dh)
{
  double x = bbox_.getXMin();
  double y = bbox_.getYMin();

  double w = bbox_.getWidth ();
  double h = bbox_.getHeight();

  double xs = (w + dw)/w;
  double ys = (h + dh)/h;

  const CMatrix2D &m = getFlatMatrix();

  CMatrix2D im = m.inverse();

  uint num_points = points_.size();

  for (uint i = 0; i < num_points; ++i) {
    CPoint2D p = m*points_[i];

    p.x = x + (p.x - x)*xs;
    p.y = y + (p.y - y)*ys;

    points_[i] = im*p;
  }

  invalidateBBox();
}

bool
CQIllustratorPolygonShape::
flip(bool x_axis)
{
  const CMatrix2D &m = getFlatMatrix();

  CMatrix2D im = m.inverse();

  CPoint2D rc = getRotateCenter();

  uint num_points = points_.size();

  for (uint i = 0; i < num_points; ++i) {
    CPoint2D p = m*points_[i];

    points_[i] = im*p.flip(rc, x_axis);
  }

  return true;
}

void
CQIllustratorPolygonShape::
drawShape(CQIllustratorShapeDrawer *drawer) const
{
  if (points_.empty()) return;

  const CMatrix2D &m = getFlatMatrix();

  drawer->pushMatrix(m, true);

  uint num_points = points_.size();

  drawer->pathInit();

  drawer->pathMoveTo(points_[num_points - 1]);

  for (uint i = 0; i < num_points; ++i)
    drawer->pathLineTo(points_[i]);

  drawer->pathClose();

  if (! clip_) {
    fill_  .draw(this, drawer);
    stroke_.draw(this, drawer);
  }
  else
    drawer->pathClip();

  drawer->popMatrix();
}

CQIllustratorShapeGeometry *
CQIllustratorPolygonShape::
getGeometry()
{
  return new CQIllustratorPolygonGeometry(fixed_, rcenter_, m_, points_);
}

void
CQIllustratorPolygonShape::
doSetGeometry(const CQIllustratorShapeGeometry *geom)
{
  const CQIllustratorPolygonGeometry *geom1 =
    dynamic_cast<const CQIllustratorPolygonGeometry *>(geom);

  if (! geom1) return;

  fixed_   = geom1->fixed_;
  rcenter_ = geom1->rcenter_;
  m_       = geom1->m_;
  points_  = geom1->points_;

  invalidateBBox();
}

void
CQIllustratorPolygonShape::
saveSVG(const CQIllustratorSaveData &saveData)
{
  CFile *file = saveData.file;

  file->printf("<polygon points=\"");

  uint num_points = points_.size();

  for (uint i = 0; i < num_points; ++i) {
    CPoint2D p = points_[i];

    if (i > 0) file->printf(" ");

    file->printf("%g,%g", p.x, p.y);
  }

  file->printf("\"%s %s/>\n", getSVGMatrix().c_str(), getSVGStroke().c_str());
}

void
CQIllustratorPolygonShape::
saveCmd(const CQIllustratorSaveData & /*saveData*/)
{
}

//-----

CQIllustratorPolygonShapeControlPoint::
CQIllustratorPolygonShapeControlPoint(uint ind, const CPoint2D &p) :
 CQIllustratorShapeControlPoint(ind, p), ind_(ind)
{
}

CQIllustratorPolygonShapeControlPoint *
CQIllustratorPolygonShapeControlPoint::
dup() const
{
  return new CQIllustratorPolygonShapeControlPoint(ind_, point_);
}

CPoint2D
CQIllustratorPolygonShapeControlPoint::
getPoint(const CQIllustratorShape *shape) const
{
  const CQIllustratorPolygonShape *polygon =
    dynamic_cast<const CQIllustratorPolygonShape *>(shape);
  assert(polygon);

  return polygon->getPoint(ind_);
}

void
CQIllustratorPolygonShapeControlPoint::
setPoint(CQIllustratorShape *shape, const CPoint2D &point)
{
  CQIllustratorPolygonShape *polygon = dynamic_cast<CQIllustratorPolygonShape *>(shape);
  assert(polygon);

  polygon->setPoint(ind_, point);
}

//--------------

class CPathShapePolygonProcess : public CPathShapeProcess {
 public:
  CPathShapePolygonProcess(CPolygon2D &polygon, const CPathShape *path) :
   CPathShapeProcess(), polygon_(polygon), path_(path) {
    m_ = path_->getFlatMatrix();
  }

  void init() {
  }

  void moveTo(const CPoint2D &p) {
    polygon_.addPoint(m_*p);
  }

  void lineTo(const CPoint2D &p) {
    polygon_.addPoint(m_*p);
  }

  void curve2To(const CPoint2D &p1, const CPoint2D &p2) {
    polygon_.addPoint(m_*p1);
    polygon_.addPoint(m_*p2);
  }

  void curve3To(const CPoint2D &p1, const CPoint2D &p2, const CPoint2D &p3) {
    polygon_.addPoint(m_*p1);
    polygon_.addPoint(m_*p2);
    polygon_.addPoint(m_*p3);
  }

  void arcTo(const CPoint2D &/*c*/, double /*xr*/, double /*yr*/,
             double /*angle1*/, double /*angle2*/) {
  }

  void close() {
  }

  void term() {
  }

 private:
  CPolygon2D                   &polygon_;
  const CPathShape *path_;
  CMatrix2D                     m_;
};

CPathShape::
CPathShape(const CPathShapePartList &parts) :
 CQIllustratorShape(), parts_(parts), group_(0)
{
}

CPathShape::
CPathShape(const CPathShape &path) :
 CQIllustratorShape(path), parts_(path.parts_)
{
}

CPathShape *
CPathShape::
dup() const
{
  return new CPathShape(*this);
}

bool
CPathShape::
getPolygon(CPolygon2D &polygon) const
{
  CPathShapePolygonProcess process(polygon, this);

  process.init();

  CPathShape *th = const_cast<CPathShape *>(this);

  th->processPath(&process);

  process.term();

  return true;
}

bool
CPathShape::
getPath(CPathShapePartList &parts) const
{
  parts = parts_;

  return true;
}

void
CPathShape::
moveBy(const CPoint2D &d)
{
  const CMatrix2D &m = getFlatMatrix();

  CMatrix2D im = m.inverse();

  uint num_parts = parts_.size();

  for (uint i = 0; i < num_parts; ++i) {
    CPathShapePart *part = parts_[i];

    CPathPartType type = part->getType();

    CPoint2D p1;

    if      (type == CPATH_PART_TYPE_MOVE_TO) {
      CPathShapeMoveTo *moveToPart = dynamic_cast<CPathShapeMoveTo *>(part);

      moveToPart->setPoint(im*(m*moveToPart->getPoint() + d));
    }
    else if (type == CPATH_PART_TYPE_LINE_TO) {
      CPathShapeLineTo *lineToPart = dynamic_cast<CPathShapeLineTo *>(part);

      lineToPart->setPoint(im*(m*lineToPart->getPoint() + d));
    }
    else if (type == CPATH_PART_TYPE_CURVE2_TO) {
      CPathShapeCurve2To *curveToPart = dynamic_cast<CPathShapeCurve2To *>(part);

      curveToPart->setPoint1(im*(m*curveToPart->getPoint1() + d));
      curveToPart->setPoint2(im*(m*curveToPart->getPoint2() + d));
    }
    else if (type == CPATH_PART_TYPE_CURVE3_TO) {
      CPathShapeCurve3To *curveToPart = dynamic_cast<CPathShapeCurve3To *>(part);

      curveToPart->setPoint1(im*(m*curveToPart->getPoint1() + d));
      curveToPart->setPoint2(im*(m*curveToPart->getPoint2() + d));
      curveToPart->setPoint3(im*(m*curveToPart->getPoint3() + d));
    }
    else if (type == CPATH_PART_TYPE_ARC) {
      CPathShapeArc *arcToPart = dynamic_cast<CPathShapeArc *>(part);

      arcToPart->setCenter(im*(m*arcToPart->getCenter() + d));
    }
    else
      continue;
  }
}

void
CPathShape::
startGroup()
{
  ++group_;
}

void
CPathShape::
endGroup()
{
  --group_;

  assert(group_ >= 0);

  if (group_ == 0)
    invalidateBBox();
}

bool
CPathShape::
empty() const
{
  return parts_.empty();
}

double
CPathShape::
distance(const CPoint2D &p) const
{
  const CMatrix2D &m = getFlatMatrix();

  double dist = 1E50;

  uint num_parts = parts_.size();

  for (uint i = 0; i < num_parts; ++i) {
    const CPathShapePart *part = parts_[i];

    CPathPartType type = part->getType();

    CPoint2D p1;

    if      (type == CPATH_PART_TYPE_MOVE_TO) {
      const CPathShapeMoveTo *moveToPart = dynamic_cast<const CPathShapeMoveTo *>(part);

      p1 = m*moveToPart->getPoint();
    }
    else if (type == CPATH_PART_TYPE_LINE_TO) {
      const CPathShapeLineTo *lineToPart = dynamic_cast<const CPathShapeLineTo *>(part);

      p1 = m*lineToPart->getPoint();
    }
    else if (type == CPATH_PART_TYPE_CURVE2_TO) {
      const CPathShapeCurve2To *curveToPart = dynamic_cast<const CPathShapeCurve2To *>(part);

      p1 = m*curveToPart->getPoint2();
    }
    else if (type == CPATH_PART_TYPE_CURVE3_TO) {
      const CPathShapeCurve3To *curveToPart = dynamic_cast<const CPathShapeCurve3To *>(part);

      p1 = m*curveToPart->getPoint3();
    }
    else if (type == CPATH_PART_TYPE_ARC) {
      const CPathShapeArc *arcToPart = dynamic_cast<const CPathShapeArc *>(part);

      p1 = m*arcToPart->getCenter();
    }
    else
      continue;

    dist = std::min(fabs(p1.x - p.x), fabs(p1.y - p.y));
  }

  return dist;
}

bool
CPathShape::
inside(const CPoint2D &p) const
{
  const CMatrix2D &m = getFlatMatrix();

  std::vector<CPoint2D> points;

  uint num_parts = parts_.size();

  for (uint i = 0; i < num_parts; ++i) {
    const CPathShapePart *part = parts_[i];

    CPathPartType type = part->getType();

    CPoint2D p1;

    if      (type == CPATH_PART_TYPE_MOVE_TO) {
      const CPathShapeMoveTo *moveToPart = dynamic_cast<const CPathShapeMoveTo *>(part);

      p1 = m*moveToPart->getPoint();
    }
    else if (type == CPATH_PART_TYPE_LINE_TO) {
      const CPathShapeLineTo *lineToPart = dynamic_cast<const CPathShapeLineTo *>(part);

      p1 = m*lineToPart->getPoint();
    }
    else if (type == CPATH_PART_TYPE_CURVE2_TO) {
      const CPathShapeCurve2To *curveToPart = dynamic_cast<const CPathShapeCurve2To *>(part);

      p1 = m*curveToPart->getPoint2();
    }
    else if (type == CPATH_PART_TYPE_CURVE3_TO) {
      const CPathShapeCurve3To *curveToPart = dynamic_cast<const CPathShapeCurve3To *>(part);

      p1 = m*curveToPart->getPoint3();
    }
    else if (type == CPATH_PART_TYPE_ARC) {
      // TODO: use arc end points
      const CPathShapeArc *arcToPart = dynamic_cast<const CPathShapeArc *>(part);

      p1 = m*arcToPart->getCenter();
    }
    else
      continue;

    points.push_back(p1);
  }

  return CMathGeom2D::PointInsideEvenOdd(p, &points[0], points.size());
}

void
CPathShape::
getControlLines(ControlLineList &clines) const
{
  std::vector<CLine2D> lines;

  getLines(lines);

  uint num_lines = lines.size();

  for (uint i = 0; i < num_lines; ++i)
    clines.push_back(new CPathShapeControlLine(i, lines[i]));
}

void
CPathShape::
getLines(std::vector<CLine2D> &lines) const
{
  CPoint2D p0, p1, p2;

  const CMatrix2D &m = getFlatMatrix();

  uint num_parts = parts_.size();

  for (uint i = 0; i < num_parts; ++i) {
    const CPathShapePart *part = parts_[i];

    CPathPartType type = part->getType();

    if      (type == CPATH_PART_TYPE_MOVE_TO) {
      const CPathShapeMoveTo *moveToPart = dynamic_cast<const CPathShapeMoveTo *>(part);

      p1 = m*moveToPart->getPoint();

      p0 = p1;
    }
    else if (type == CPATH_PART_TYPE_LINE_TO) {
      const CPathShapeLineTo *lineToPart = dynamic_cast<const CPathShapeLineTo *>(part);

      p2 = m*lineToPart->getPoint();

      lines.push_back(CLine2D(p1, p2));

      p1 = p2;
    }
    else if (type == CPATH_PART_TYPE_CURVE2_TO) {
      const CPathShapeCurve2To *curveToPart = dynamic_cast<const CPathShapeCurve2To *>(part);

      p2 = m*curveToPart->getPoint2();

      lines.push_back(CLine2D(p1, p2));

      p1 = p2;
    }
    else if (type == CPATH_PART_TYPE_CURVE3_TO) {
      const CPathShapeCurve3To *curveToPart = dynamic_cast<const CPathShapeCurve3To *>(part);

      p2 = m*curveToPart->getPoint3();

      lines.push_back(CLine2D(p1, p2));
    }
    else if (type == CPATH_PART_TYPE_ARC) {
      const CPathShapeArc *arcToPart = dynamic_cast<const CPathShapeArc *>(part);

      CPoint2D pa1, pa2;

      arcToPart->getEndPoints(pa1, pa2);

      p2 = m*pa2;

      lines.push_back(CLine2D(p1, p2));

      p1 = p2;
    }
    else if (type == CPATH_PART_TYPE_CLOSE) {
      lines.push_back(CLine2D(p1, p0));

      p1 = p0;
    }
    else
      continue;
  }
}

CLine2D
CPathShape::
getLine(uint i) const
{
  std::vector<CLine2D> lines;

  getLines(lines);

  return lines[i];
}

void
CPathShape::
setLine(uint i, const CLine2D &l)
{
  std::vector<CLine2D> lines;

  getLines(lines);

  int sline_num = 0;
  int eline_num = lines.size() - 1;

  const CMatrix2D &m = getFlatMatrix();

  CMatrix2D im = m.inverse();

  uint num_parts = parts_.size();

  for (uint j = 0; j < num_parts; ++j) {
    CPathShapePart *part = parts_[j];

    CPathPartType type = part->getType();

    if      (type == CPATH_PART_TYPE_MOVE_TO) {
      CPathShapeMoveTo *moveToPart =
        dynamic_cast<CPathShapeMoveTo *>(part);

      if      (sline_num == int(i))
        moveToPart->setPoint(im*l.start());
      else if (eline_num == int(i))
        moveToPart->setPoint(im*l.end  ());

      eline_num = sline_num++;
    }
    else if (type == CPATH_PART_TYPE_LINE_TO) {
      CPathShapeLineTo *lineToPart =
        dynamic_cast<CPathShapeLineTo *>(part);

      if      (sline_num == int(i))
        lineToPart->setPoint(im*l.start());
      else if (eline_num == int(i))
        lineToPart->setPoint(im*l.end  ());

      eline_num = sline_num++;
    }
    else if (type == CPATH_PART_TYPE_CURVE2_TO) {
      eline_num = sline_num++;
    }
    else if (type == CPATH_PART_TYPE_CURVE3_TO) {
      eline_num = sline_num++;
    }
    else if (type == CPATH_PART_TYPE_ARC) {
      eline_num = sline_num++;
    }
    else if (type == CPATH_PART_TYPE_CLOSE) {
      eline_num = sline_num++;
    }
    else
      continue;
  }
}

void
CPathShape::
setLineType(uint i, CPathPartType type)
{
  CPathShapePartList parts;

  int line_num = -1;

  uint num_parts = parts_.size();

  CPoint2D p0, p1, p2;

  for (uint j = 0; j < num_parts; ++j) {
    CPathShapePart *part = parts_[j];

    CPathPartType partType2 = part->getType();

    if      (partType2 == CPATH_PART_TYPE_MOVE_TO) {
      CPathShapeMoveTo *moveToPart =
        dynamic_cast<CPathShapeMoveTo *>(part);

      p2 = moveToPart->getPoint();
      p0 = p2;

      line_num = -1;
    }
    else if (partType2 == CPATH_PART_TYPE_LINE_TO) {
      CPathShapeLineTo *lineToPart =
        dynamic_cast<CPathShapeLineTo *>(part);

      p2 = lineToPart->getPoint();

      ++line_num;
    }
    else if (partType2 == CPATH_PART_TYPE_CURVE2_TO) {
      CPathShapeCurve2To *curve2Part =
        dynamic_cast<CPathShapeCurve2To *>(part);

      p2 = curve2Part->getPoint2();

      ++line_num;
    }
    else if (partType2 == CPATH_PART_TYPE_CURVE3_TO) {
      CPathShapeCurve3To *curve3Part =
        dynamic_cast<CPathShapeCurve3To *>(part);

      p2 = curve3Part->getPoint3();

      ++line_num;
    }
    else if (partType2 == CPATH_PART_TYPE_ARC) {
      // TODO

      ++line_num;
    }
    else if (partType2 == CPATH_PART_TYPE_CLOSE) {
      p2 = p0;

      ++line_num;
    }
    else
      continue;

    CPathShapePart *part1 = 0;

    if (line_num == int(i)) {
      CPoint2D pp1, pp2;

      bool pp1_set = false, pp2_set = false;

      if      (partType2 == CPATH_PART_TYPE_LINE_TO) {
      }
      else if (partType2 == CPATH_PART_TYPE_CURVE2_TO) {
        CPathShapeCurve2To *curve2Part =
          dynamic_cast<CPathShapeCurve2To *>(part);

        pp2 = curve2Part->getPoint1(); pp2_set = true;
      }
      else if (partType2 == CPATH_PART_TYPE_CURVE3_TO) {
        CPathShapeCurve3To *curve3Part =
          dynamic_cast<CPathShapeCurve3To *>(part);

        pp1 = curve3Part->getPoint1(); pp1_set = true;
        pp2 = curve3Part->getPoint2(); pp2_set = true;
      }

      if      (type == CPATH_PART_TYPE_LINE_TO) {
        part1 = new CPathShapeLineTo(p2);
      }
      else if (type == CPATH_PART_TYPE_CURVE2_TO) {
        if (! pp2_set) pp2 = (p1 + p2)/2;

        part1 = new CPathShapeCurve2To(pp2, p2);
      }
      else if (type == CPATH_PART_TYPE_CURVE3_TO) {
        if (! pp1_set) pp1 = p1 +   (p2 - p1)/3;
        if (! pp2_set) pp2 = p1 + 2*(p2 + p1)/3;

        part1 = new CPathShapeCurve3To(pp1, pp2, p2);
      }
      else
        part1 = part->dup();

      parts.addPart(part1);

      if (partType2 == CPATH_PART_TYPE_CLOSE) {
        part1 = part->dup();

        parts.addPart(part1);
      }
    }
    else {
      part1 = part->dup();

      parts.addPart(part1);
    }

    p1 = p2;
  }

  parts_ = parts;
}

void
CPathShape::
getControlPoints(ControlPointList &points, ControlType type) const
{
  if (type == CONTROL_GEOMETRY) {
    const CMatrix2D &m = getFlatMatrix();

    uint num_parts = parts_.size();

    for (uint i = 0; i < num_parts; ++i) {
      const CPathShapePart *part = parts_[i];

      CPathPartType type = part->getType();

      if      (type == CPATH_PART_TYPE_MOVE_TO) {
        const CPathShapeMoveTo *moveToPart = dynamic_cast<const CPathShapeMoveTo *>(part);

        CPoint2D p1 = m*moveToPart->getPoint();

        points.push_back(new CPathShapeControlPoint(i, p1));
      }
      else if (type == CPATH_PART_TYPE_LINE_TO) {
        const CPathShapeLineTo *lineToPart = dynamic_cast<const CPathShapeLineTo *>(part);

        CPoint2D p1 = m*lineToPart->getPoint();

        points.push_back(new CPathShapeControlPoint(i, p1));
      }
      else if (type == CPATH_PART_TYPE_CURVE2_TO) {
        const CPathShapeCurve2To *curveToPart = dynamic_cast<const CPathShapeCurve2To *>(part);

        CPoint2D pp1 = m*curveToPart->getPoint1();
        CPoint2D pp2 = m*curveToPart->getPoint2();

        points.push_back(new CPathShapeControlPoint(i, 1, pp1));
        points.push_back(new CPathShapeControlPoint(i, pp2));
      }
      else if (type == CPATH_PART_TYPE_CURVE3_TO) {
        const CPathShapeCurve3To *curveToPart = dynamic_cast<const CPathShapeCurve3To *>(part);

        CPoint2D pp1 = m*curveToPart->getPoint1();
        CPoint2D pp2 = m*curveToPart->getPoint2();
        CPoint2D pp3 = m*curveToPart->getPoint3();

        points.push_back(new CPathShapeControlPoint(i, 1, pp1));
        points.push_back(new CPathShapeControlPoint(i, 2, pp2));
        points.push_back(new CPathShapeControlPoint(i, pp3));
      }
      else if (type == CPATH_PART_TYPE_ARC) {
        const CPathShapeArc *arcToPart = dynamic_cast<const CPathShapeArc *>(part);

        const CPoint2D &c = arcToPart->getCenter();

        CPoint2D p1, p2;

        arcToPart->getEndPoints(p1, p2);

        CPoint2D c1  = m*c;
        CPoint2D pp1 = m*p1;
        CPoint2D pp2 = m*p2;

        points.push_back(new CPathShapeControlPoint(i, c1 ));
        points.push_back(new CPathShapeControlPoint(i, 1, pp1));
        points.push_back(new CPathShapeControlPoint(i, 2, pp2));
      }
      else if (type == CPATH_PART_TYPE_CLOSE) {
      }
    }
  }
  else
    CQIllustratorShape::getControlPoints(points, type);
}

void
CPathShape::
setControlPoint(const CQIllustratorShapeControlPoint *point)
{
  const CPathShapeControlPoint *ppoint =
    dynamic_cast<const CPathShapeControlPoint *>(point);
  assert(ppoint);

  const CMatrix2D &m = getFlatMatrix();

  uint ind  = ppoint->getInd();
  uint ind1 = ppoint->getInd1();

  CMatrix2D im = m.inverse();

  CPoint2D p = im*point->getPoint(this);

  setPoint(ind, ind1, p);
}

CPoint2D
CPathShape::
getPoint(uint ind, uint ind1) const
{
  uint num_parts = parts_.size();

  assert(ind < num_parts);

  const CPathShapePart *part = parts_[ind];

  CPathPartType type = part->getType();

  CPoint2D p;

  if      (type == CPATH_PART_TYPE_MOVE_TO) {
    assert(ind1 == 0);

    const CPathShapeMoveTo *moveToPart = dynamic_cast<const CPathShapeMoveTo *>(part);

    p = moveToPart->getPoint();
  }
  else if (type == CPATH_PART_TYPE_LINE_TO) {
    assert(ind1 == 0);

    const CPathShapeLineTo *lineToPart = dynamic_cast<const CPathShapeLineTo *>(part);

    p = lineToPart->getPoint();
  }
  else if (type == CPATH_PART_TYPE_CURVE2_TO) {
    assert(ind1 < 2);

    const CPathShapeCurve2To *curveToPart = dynamic_cast<const CPathShapeCurve2To *>(part);

    if (ind1 == 0)
      p = curveToPart->getPoint2();
    else
      p = curveToPart->getPoint1();
  }
  else if (type == CPATH_PART_TYPE_CURVE3_TO) {
    assert(ind1 < 3);

    const CPathShapeCurve3To *curveToPart = dynamic_cast<const CPathShapeCurve3To *>(part);

    if      (ind1 == 0)
      p = curveToPart->getPoint3();
    else if (ind1 == 1)
      p = curveToPart->getPoint1();
    else
      p = curveToPart->getPoint2();
  }
  else if (type == CPATH_PART_TYPE_ARC) {
    assert(ind1 < 3);

    const CPathShapeArc *arcToPart = dynamic_cast<const CPathShapeArc *>(part);

    CPoint2D p1, p2;

    arcToPart->getEndPoints(p1, p2);

    if      (ind1 == 0)
      p = arcToPart->getCenter();
    else if (ind1 == 0)
      p = p1;
    else
      p = p2;
  }
  else
    assert(false);

  const CMatrix2D &m = getFlatMatrix();

  return m*p;
}

void
CPathShape::
setPoint(uint ind, uint ind1, const CPoint2D &p)
{
  uint num_parts = parts_.size();

  assert(ind < num_parts);

  CPathShapePart *part = parts_[ind];

  CPathPartType type = part->getType();

  if      (type == CPATH_PART_TYPE_MOVE_TO) {
    assert(ind1 == 0);

    CPathShapeMoveTo *moveToPart = dynamic_cast<CPathShapeMoveTo *>(part);

    moveToPart->setPoint(p);
  }
  else if (type == CPATH_PART_TYPE_LINE_TO) {
    assert(ind1 == 0);

    CPathShapeLineTo *lineToPart = dynamic_cast<CPathShapeLineTo *>(part);

    lineToPart->setPoint(p);
  }
  else if (type == CPATH_PART_TYPE_CURVE2_TO) {
    assert(ind1 < 2);

    CPathShapeCurve2To *curveToPart = dynamic_cast<CPathShapeCurve2To *>(part);

    if (ind1 == 0)
      curveToPart->setPoint2(p);
    else
      curveToPart->setPoint1(p);
  }
  else if (type == CPATH_PART_TYPE_CURVE3_TO) {
    assert(ind1 < 3);

    CPathShapeCurve3To *curveToPart = dynamic_cast<CPathShapeCurve3To *>(part);

    if      (ind1 == 0)
      curveToPart->setPoint3(p);
    else if (ind1 == 1)
      curveToPart->setPoint1(p);
    else
      curveToPart->setPoint2(p);
  }
  else if (type == CPATH_PART_TYPE_ARC) {
    assert(ind1 < 3);

    CPathShapeArc *arcToPart = dynamic_cast<CPathShapeArc *>(part);

    if (ind1 == 0)
      arcToPart->setCenter(p);
  }
  else
    return;

  invalidateBBox();
}

void
CPathShape::
setCornerPoint(uint ind)
{
  uint num_parts = parts_.size();

  assert(ind < num_parts);

  CMatrix2D save_m = m_;

  m_.setIdentity();

  CPoint2D p2 = getPoint(ind, 0);

  delete parts_[ind];

  parts_.setPart(ind, new CPathShapeLineTo(p2));

  m_ = save_m;
}

void
CPathShape::
setCurvePoint(uint ind)
{
  uint num_parts = parts_.size();

  assert(ind < num_parts);

  CMatrix2D save_m = m_;

  m_.setIdentity();

  CPoint2D p1(0,0), p3(0, 0);

  CPoint2D p2 = getPoint(ind, 0);

  if (ind > 0            ) p1 = getPoint(ind - 1, 0);
  if (ind < num_parts - 1) p3 = getPoint(ind + 1, 0);

  delete parts_[ind];

  parts_.setPart(ind, new CPathShapeCurve2To(p2, (p1 + p3)/2));

  m_ = save_m;
}

bool
CPathShape::
doRemovePoint(const CQIllustratorShapeControlPoint *point)
{
  const CPathShapeControlPoint *ppoint =
      dynamic_cast<const CPathShapeControlPoint *>(point);
  assert(ppoint);

  uint ind = ppoint->getInd();

  parts_.removePart(ind);

  return true;
}

void
CPathShape::
updateBBox() const
{
  if (! bbox_valid_) {
    const CMatrix2D &m = getFlatMatrix();

    bbox_.reset();

    uint num_parts = parts_.size();

    for (uint i = 0; i < num_parts; ++i) {
      const CPathShapePart *part = parts_[i];

      CPathPartType type = part->getType();

      if      (type == CPATH_PART_TYPE_MOVE_TO) {
        const CPathShapeMoveTo *moveToPart = dynamic_cast<const CPathShapeMoveTo *>(part);

        CPoint2D p1 = m*moveToPart->getPoint();

        bbox_ += p1;
      }
      else if (type == CPATH_PART_TYPE_LINE_TO) {
        const CPathShapeLineTo *lineToPart = dynamic_cast<const CPathShapeLineTo *>(part);

        CPoint2D p1 = m*lineToPart->getPoint();

        bbox_ += p1;
      }
      else if (type == CPATH_PART_TYPE_CURVE2_TO) {
        const CPathShapeCurve2To *curveToPart = dynamic_cast<const CPathShapeCurve2To *>(part);

        CPoint2D pp1 = m*curveToPart->getPoint1();
        CPoint2D pp2 = m*curveToPart->getPoint2();

        bbox_ += pp1;
        bbox_ += pp2;
      }
      else if (type == CPATH_PART_TYPE_CURVE3_TO) {
        const CPathShapeCurve3To *curveToPart = dynamic_cast<const CPathShapeCurve3To *>(part);

        CPoint2D pp1 = m*curveToPart->getPoint1();
        CPoint2D pp2 = m*curveToPart->getPoint2();
        CPoint2D pp3 = m*curveToPart->getPoint3();

        bbox_ += pp1;
        bbox_ += pp2;
        bbox_ += pp3;
      }
      else if (type == CPATH_PART_TYPE_ARC) {
        const CPathShapeArc *arcToPart = dynamic_cast<const CPathShapeArc *>(part);

        CPoint2D c = m*arcToPart->getCenter();

        double xr = arcToPart->getRadiusX();
        double yr = arcToPart->getRadiusY();

        double a1 = arcToPart->getAngle1();
        double a2 = arcToPart->getAngle2();
        double a3 = (a1 + a2)/2;

        double x1, y1, x2, y2, x3, y3;

        CMathGeom2D::EllipsePointAtAngle(c.x, c.y, xr, yr, a1, &x1, &y1);
        CMathGeom2D::EllipsePointAtAngle(c.x, c.y, xr, yr, a2, &x2, &y2);
        CMathGeom2D::EllipsePointAtAngle(c.x, c.y, xr, yr, a3, &x3, &y3);

        bbox_ += CPoint2D(x1, y1);
        bbox_ += CPoint2D(x2, y2);
        bbox_ += CPoint2D(x3, y3);
      }
      else
        continue;
    }

    double sopacity = getStroke().getOpacity();

    if (sopacity > 0.0) {
      double lw2 = getStrokeWidth()/2;

      bbox_.expand(-lw2, -lw2, lw2, lw2);
    }

    bbox_valid_ = true;
  }
}

void
CPathShape::
setParts(const CPathShapePartList &parts)
{
  parts_ = parts;

  invalidateBBox();
}

void
CPathShape::
addMoveTo(const CPoint2D &p)
{
  parts_.addPart(new CPathShapeMoveTo(p));

  if (group_ == 0) invalidateBBox();
}

void
CPathShape::
addLineTo(const CPoint2D &p)
{
  parts_.addPart(new CPathShapeLineTo(p));

  if (group_ == 0) invalidateBBox();
}

void
CPathShape::
addLineTo(uint ind, const CPoint2D &p)
{
  parts_.addPart(ind, new CPathShapeLineTo(p));

  if (group_ == 0) invalidateBBox();
}

void
CPathShape::
addCurveTo(const CPoint2D &p1, const CPoint2D &p2)
{
  parts_.addPart(new CPathShapeCurve2To(p1, p2));

  if (group_ == 0) invalidateBBox();
}

void
CPathShape::
addCurveTo(const CPoint2D &p1, const CPoint2D &p2, const CPoint2D &p3)
{
  parts_.addPart(new CPathShapeCurve3To(p1, p2, p3));

  if (group_ == 0) invalidateBBox();
}

void
CPathShape::
addArcTo(const CPoint2D &c, double xr, double yr, double angle1, double angle2)
{
  parts_.addPart(new CPathShapeArc(c, xr, yr, angle1, angle2));

  if (group_ == 0) invalidateBBox();
}

void
CPathShape::
addClose()
{
  parts_.addPart(new CPathShapeClose());

  if (group_ == 0) invalidateBBox();
}

bool
CPathShape::
flip(bool x_axis)
{
  uint num_parts = parts_.size();

  if (num_parts == 0) return true;

  const CMatrix2D &m = getFlatMatrix();

  CMatrix2D im = m.inverse();

  CPoint2D rc = getRotateCenter();

  for (uint i = 0; i < num_parts; ++i) {
    CPathShapePart *part = parts_[i];

    CPathPartType type = part->getType();

    if      (type == CPATH_PART_TYPE_MOVE_TO) {
      CPathShapeMoveTo *moveToPart = dynamic_cast<CPathShapeMoveTo *>(part);

      CPoint2D p = m*moveToPart->getPoint();

      moveToPart->setPoint(im*p.flip(rc, x_axis));
    }
    else if (type == CPATH_PART_TYPE_LINE_TO) {
      CPathShapeLineTo *lineToPart = dynamic_cast<CPathShapeLineTo *>(part);

      CPoint2D p = m*lineToPart->getPoint();

      lineToPart->setPoint(im*p.flip(rc, x_axis));
    }
    else if (type == CPATH_PART_TYPE_CURVE2_TO) {
      CPathShapeCurve2To *curveToPart = dynamic_cast<CPathShapeCurve2To *>(part);

      CPoint2D p1 = m*curveToPart->getPoint1();
      CPoint2D p2 = m*curveToPart->getPoint2();

      curveToPart->setPoint1(im*p1.flip(rc, x_axis));
      curveToPart->setPoint2(im*p2.flip(rc, x_axis));
    }
    else if (type == CPATH_PART_TYPE_CURVE3_TO) {
      CPathShapeCurve3To *curveToPart = dynamic_cast<CPathShapeCurve3To *>(part);

      CPoint2D p1 = m*curveToPart->getPoint1();
      CPoint2D p2 = m*curveToPart->getPoint2();
      CPoint2D p3 = m*curveToPart->getPoint3();

      curveToPart->setPoint1(im*p1.flip(rc, x_axis));
      curveToPart->setPoint2(im*p2.flip(rc, x_axis));
      curveToPart->setPoint3(im*p3.flip(rc, x_axis));
    }
    else if (type == CPATH_PART_TYPE_ARC) {
      CPathShapeArc *arcToPart = dynamic_cast<CPathShapeArc *>(part);

      CPoint2D c      = m*arcToPart->getCenter();
    //double   xr     = arcToPart->getRadiusX();
    //double   yr     = arcToPart->getRadiusY();
      double   angle1 = arcToPart->getAngle1();
      double   angle2 = arcToPart->getAngle2();

      arcToPart->setCenter(im*c.flip(rc, x_axis));
      arcToPart->setAngle1(360 - angle1);
      arcToPart->setAngle2(360 - angle2);
    }
    else if (type == CPATH_PART_TYPE_CLOSE) {
    }
  }

  return true;
}

void
CPathShape::
drawShape(CQIllustratorShapeDrawer *drawer) const
{
  uint num_parts = parts_.size();

  if (num_parts == 0) return;

  const CMatrix2D &m = getFlatMatrix();

  drawer->pathInit();

  for (uint i = 0; i < num_parts; ++i) {
    const CPathShapePart *part = parts_[i];

    CPathPartType type = part->getType();

    if      (type == CPATH_PART_TYPE_MOVE_TO) {
      const CPathShapeMoveTo *moveToPart = dynamic_cast<const CPathShapeMoveTo *>(part);

      CPoint2D p1 = m*moveToPart->getPoint();

      drawer->pathMoveTo(p1);
    }
    else if (type == CPATH_PART_TYPE_LINE_TO) {
      const CPathShapeLineTo *lineToPart = dynamic_cast<const CPathShapeLineTo *>(part);

      CPoint2D p1 = m*lineToPart->getPoint();

      drawer->pathLineTo(p1);
    }
    else if (type == CPATH_PART_TYPE_CURVE2_TO) {
      const CPathShapeCurve2To *curveToPart = dynamic_cast<const CPathShapeCurve2To *>(part);

      CPoint2D p11 = m*curveToPart->getPoint1();
      CPoint2D p22 = m*curveToPart->getPoint2();

      drawer->pathBezierTo(p11, p22);
    }
    else if (type == CPATH_PART_TYPE_CURVE3_TO) {
      const CPathShapeCurve3To *curveToPart = dynamic_cast<const CPathShapeCurve3To *>(part);

      const CPoint2D &p1 = curveToPart->getPoint1();
      const CPoint2D &p2 = curveToPart->getPoint2();
      const CPoint2D &p3 = curveToPart->getPoint3();

      CPoint2D p11 = m*p1;
      CPoint2D p22 = m*p2;
      CPoint2D p33 = m*p3;

      drawer->pathBezierTo(p11, p22, p33);
    }
    else if (type == CPATH_PART_TYPE_ARC) {
      const CPathShapeArc *arcToPart = dynamic_cast<const CPathShapeArc *>(part);

      const CPoint2D &c      = arcToPart->getCenter();
      double          xr     = arcToPart->getRadiusX();
      double          yr     = arcToPart->getRadiusY();
      double          angle1 = arcToPart->getAngle1();
      double          angle2 = arcToPart->getAngle2();

      CPoint2D c1 = m*c;

      drawer->pathArc(c1, xr, yr, angle1, angle2);
    }
    else if (type == CPATH_PART_TYPE_CLOSE) {
      drawer->pathClose();
    }
  }

  if (! clip_) {
    fill_  .draw(this, drawer);
    stroke_.draw(this, drawer);
  }
  else
    drawer->pathClip();
}

CQIllustratorShapeGeometry *
CPathShape::
getGeometry()
{
  return new CQIllustratorPathGeometry(fixed_, rcenter_, m_, parts_);
}

void
CPathShape::
doSetGeometry(const CQIllustratorShapeGeometry *geom)
{
  const CQIllustratorPathGeometry *geom1 = dynamic_cast<const CQIllustratorPathGeometry *>(geom);

  if (! geom1) return;

  fixed_   = geom1->fixed_;
  rcenter_ = geom1->rcenter_;
  m_       = geom1->m_;
  parts_   = geom1->parts_;

  invalidateBBox();
}

class CPathShapeSVGProcess : public CPathShapeProcess {
 public:
  CPathShapeSVGProcess(const CQIllustratorSaveData &saveData, CPathShape *path) :
   CPathShapeProcess(), file_(saveData.file), path_(path) {
  }

  void init() {
    file_->printf("<path d=\"");
  }

  void moveTo(const CPoint2D &p) {
    file_->printf("%sM %g,%g", sep_.c_str(), p.x, p.y);

    sep_ = " ";
  }

  void lineTo(const CPoint2D &p) {
    file_->printf("%sL %g,%g", sep_.c_str(), p.x, p.y);

    sep_ = " ";
  }

  void curve2To(const CPoint2D &p1, const CPoint2D &p2) {
    file_->printf("%sQ %g,%g %g,%g", sep_.c_str(), p1.x, p1.y, p2.x, p2.y);

    sep_ = " ";
  }

  void curve3To(const CPoint2D &p1, const CPoint2D &p2, const CPoint2D &p3) {
    file_->printf("%sC %g,%g %g,%g %g,%g", sep_.c_str(), p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);

    sep_ = " ";
  }

  void arcTo(const CPoint2D &c, double xr, double yr, double angle1, double angle2) {
    double a1 = CMathGen::RadToDeg(angle1);
    double a2 = CMathGen::RadToDeg(angle2);

    double phi = 0;

    int    fa, fs;
    double x0, y0, x1, y1;

    CMathGeom2D::ConvertToSVGArc(c.x, c.y, xr, yr, a1, a2 - a1, phi,
                                 &x0, &y0, &x1, &y1, &fa, &fs);

    file_->printf("%sA %g,%g %g %d %d %g %g", sep_.c_str(), xr, yr, phi, fa, fs, x1, y1);

    sep_ = " ";
  }

  void close() {
    file_->printf("%sz", sep_.c_str());

    sep_ = " ";
  }

  void term() {
    file_->printf("\"%s %s/>\n", path_->getSVGMatrix().c_str(), path_->getSVGStroke().c_str());
  }

 private:
  CFile       *file_;
  CPathShape  *path_;
  std::string  sep_;
};

void
CPathShape::
saveSVG(const CQIllustratorSaveData &saveData)
{
  CPathShapeSVGProcess process(saveData, this);

  process.init();

  processPath(&process);

  process.term();
}

void
CPathShape::
saveCmd(const CQIllustratorSaveData & /*saveData*/)
{
}

void
CPathShape::
processPath(CPathShapeProcess *process)
{
  parts_.processPath(process);
}

//-----

CPathShapeControlLine::
CPathShapeControlLine(uint ind, const CLine2D &p) :
 CQIllustratorShapeControlLine(ind, p), ind_(ind)
{
}

CPathShapeControlLine *
CPathShapeControlLine::
dup() const
{
  return new CPathShapeControlLine(ind_, line_);
}

CLine2D
CPathShapeControlLine::
getLine(const CQIllustratorShape *shape) const
{
  const CPathShape *path = dynamic_cast<const CPathShape *>(shape);
  assert(path);

  return path->getLine(ind_);
}

void
CPathShapeControlLine::
setLine(CQIllustratorShape *shape, const CLine2D &line)
{
  CPathShape *path = dynamic_cast<CPathShape *>(shape);
  assert(path);

  path->setLine(ind_, line);
}

void
CPathShapeControlLine::
setType(CQIllustratorShape *shape, CPathPartType type)
{
  CPathShape *path = dynamic_cast<CPathShape *>(shape);
  assert(path);

  path->setLineType(ind_, type);
}

//-----

CPathShapeControlPoint::
CPathShapeControlPoint(uint ind, const CPoint2D &p) :
 CQIllustratorShapeControlPoint((ind << 4), p), ind_(ind), ind1_(0)
{
}

CPathShapeControlPoint::
CPathShapeControlPoint(uint ind, uint ind1, const CPoint2D &p) :
 CQIllustratorShapeControlPoint((ind << 4) | ind1, p), ind_(ind), ind1_(ind1)
{
}

CPathShapeControlPoint *
CPathShapeControlPoint::
dup() const
{
  return new CPathShapeControlPoint(ind_, ind1_, point_);
}

CPoint2D
CPathShapeControlPoint::
getPoint(const CQIllustratorShape *shape) const
{
  const CPathShape *path = dynamic_cast<const CPathShape *>(shape);
  assert(path);

  return path->getPoint(ind_, ind1_);
}

void
CPathShapeControlPoint::
setPoint(CQIllustratorShape *shape, const CPoint2D &point)
{
  CPathShape *path = dynamic_cast<CPathShape *>(shape);
  assert(path);

  path->setPoint(ind_, ind1_, point);
}

void
CPathShapeControlPoint::
setCornerNode(CQIllustratorShape *shape) const
{
  CPathShape *path = dynamic_cast<CPathShape *>(shape);
  assert(path);

  path->setCornerPoint(ind_);
}

void
CPathShapeControlPoint::
setCurveNode(CQIllustratorShape *shape) const
{
  CPathShape *path = dynamic_cast<CPathShape *>(shape);
  assert(path);

  path->setCurvePoint(ind_);
}

//----------

CQIllustratorTextShape::
CQIllustratorTextShape(const CPoint2D &p1, const CPoint2D &p2, const std::string &str,
                       CFontPtr font, CHAlignType halign, CVAlignType valign) :
 CQIllustratorShape(), p1_(p1), p2_(p2), str_(str), font_(font),
 halign_(halign), valign_(valign), cursorPos_(-1)
{
}

CQIllustratorTextShape::
CQIllustratorTextShape(const CQIllustratorTextShape &text) :
 CQIllustratorShape(text), p1_(text.p1_), p2_(text.p2_), str_(text.str_), font_(text.font_),
 halign_(text.halign_), valign_(text.valign_), cursorPos_(text.cursorPos_)
{
}

CQIllustratorTextShape *
CQIllustratorTextShape::
dup() const
{
  return new CQIllustratorTextShape(*this);
}

void
CQIllustratorTextShape::
getControlPoints(ControlPointList &points, ControlType type) const
{
  if (type == CONTROL_GEOMETRY) {
    const CMatrix2D &m = getFlatMatrix();

    CPoint2D p1 = m*p1_;
    CPoint2D p2 = m*p2_;

    CQIllustratorTextShapeControlPoint *ll = new CQIllustratorTextShapeControlPoint(TYPE_LL, p1);
    CQIllustratorTextShapeControlPoint *ur = new CQIllustratorTextShapeControlPoint(TYPE_UR, p2);

    points.push_back(ll);
    points.push_back(ur);
  }
  else
    CQIllustratorShape::getControlPoints(points, type);
}

void
CQIllustratorTextShape::
setControlPoint(const CQIllustratorShapeControlPoint *point)
{
  const CQIllustratorTextShapeControlPoint *tpoint =
    dynamic_cast<const CQIllustratorTextShapeControlPoint *>(point);

  assert(tpoint);

  const CMatrix2D &m = getFlatMatrix();

  CMatrix2D im = m.inverse();

  CPoint2D p = im*point->getPoint(this);

  CQIllustratorTextShape::ControlPointType type = tpoint->getType();

  if      (type == CQIllustratorTextShape::TYPE_LL)
    p1_ = p;
  else if (type == CQIllustratorTextShape::TYPE_UR)
    p2_ = p;

  invalidateBBox();
}

CPoint2D
CQIllustratorTextShape::
getLL() const
{
  const CMatrix2D &m = getFlatMatrix();

  return m*p1_;
}

CPoint2D
CQIllustratorTextShape::
getUR() const
{
  const CMatrix2D &m = getFlatMatrix();

  return m*p2_;
}

void
CQIllustratorTextShape::
setLL(const CPoint2D &p)
{
  const CMatrix2D &m = getFlatMatrix();

  CMatrix2D im = m.inverse();

  CPoint2D p1 = im*p;

  p1_ = p1;

  invalidateBBox();
}

void
CQIllustratorTextShape::
setUR(const CPoint2D &p)
{
  const CMatrix2D &m = getFlatMatrix();

  CMatrix2D im = m.inverse();

  CPoint2D p1 = im*p;

  p2_ = p1;

  invalidateBBox();
}

void
CQIllustratorTextShape::
setText(const std::string &str)
{
  str_ = str;

  invalidateBBox();
}

void
CQIllustratorTextShape::
setFont(CFontPtr font)
{
  font_ = font;
}

void
CQIllustratorTextShape::
setHAlign(CHAlignType halign)
{
  halign_ = halign;
}


void
CQIllustratorTextShape::
setVAlign(CVAlignType valign)
{
  valign_ = valign;
}

void
CQIllustratorTextShape::
updateBBox() const
{
  if (! bbox_valid_) {
    bbox_.reset();

    const CMatrix2D &m = getFlatMatrix();

    CPoint2D p1 = m*CPoint2D(p1_.x, p1_.y);
    CPoint2D p2 = m*CPoint2D(p2_.x, p1_.y);
    CPoint2D p3 = m*CPoint2D(p2_.x, p2_.y);
    CPoint2D p4 = m*CPoint2D(p1_.x, p2_.y);

    bbox_ += p1;
    bbox_ += p2;
    bbox_ += p3;
    bbox_ += p4;

    bbox_valid_ = true;
  }
}

bool
CQIllustratorTextShape::
getPolygon(CPolygon2D &) const
{
  return false;
}

bool
CQIllustratorTextShape::
getPath(CPathShapePartList &) const
{
  return false;
}

void
CQIllustratorTextShape::
moveBy(const CPoint2D &d)
{
  assert(! getFixed());

  checkoutShape(CQIllustratorData::CHANGE_GEOMETRY);

  const CMatrix2D &m = getFlatMatrix();

  CMatrix2D im = m.inverse();

  p1_ = im*(m*p1_ + d);
  p2_ = im*(m*p2_ + d);

  invalidateBBox();

  checkinShape(CQIllustratorData::CHANGE_GEOMETRY);
}

void
CQIllustratorTextShape::
resizeBy(double dw, double dh)
{
  double x = bbox_.getXMin();
  double y = bbox_.getYMin();

  double w = bbox_.getWidth ();
  double h = bbox_.getHeight();

  double xs = (w + dw)/w;
  double ys = (h + dh)/h;

  const CMatrix2D &m = getFlatMatrix();

  CMatrix2D im = m.inverse();

  CPoint2D p1 = m*p1_;
  CPoint2D p2 = m*p2_;

  p1.x = x + (p1.x - x)*xs;
  p1.y = y + (p1.y - y)*ys;
  p2.x = x + (p2.x - x)*xs;
  p2.y = y + (p2.y - y)*ys;

  p1_ = im*p1;
  p2_ = im*p2;

  invalidateBBox();
}

bool
CQIllustratorTextShape::
flip(bool)
{
  return false;
}

void
CQIllustratorTextShape::
drawShape(CQIllustratorShapeDrawer *drawer) const
{
  const CMatrix2D &m = getFlatMatrix();

  //drawer->setStroke(this, getStroke());
  //drawer->setFill  (this, getFill  ());

  drawer->setFont(font_);

  drawer->pushMatrix(m, true);

  drawer->pathInit();

  drawer->pathText(CBBox2D(p1_, p2_), str_, halign_, valign_);
//drawer->drawText(CBBox2D(p1_, p2_), str_, halign_, valign_, cursorPos_);

  if (! clip_) {
    fill_  .draw(this, drawer);
    stroke_.draw(this, drawer);
  }
  else
    drawer->pathClip();

  drawer->popMatrix();
}

CQIllustratorShapeGeometry *
CQIllustratorTextShape::
getGeometry()
{
  return new CQIllustratorTextGeometry(fixed_, rcenter_, m_, p1_, p2_, str_,
                                       font_, halign_, valign_);
}

void
CQIllustratorTextShape::
doSetGeometry(const CQIllustratorShapeGeometry *geom)
{
  const CQIllustratorTextGeometry *geom1 =
    dynamic_cast<const CQIllustratorTextGeometry *>(geom);

  if (! geom1) return;

  fixed_   = geom1->fixed_;
  rcenter_ = geom1->rcenter_;
  m_       = geom1->m_;
  p1_      = geom1->p1_;
  p2_      = geom1->p2_;
  str_     = geom1->str_;
  font_    = geom1->font_;
  halign_  = geom1->halign_;
  valign_  = geom1->valign_;

  invalidateBBox();
}

void
CQIllustratorTextShape::
saveSVG(const CQIllustratorSaveData &saveData)
{
  CFile *file = saveData.file;

  file->printf("<text x=\"%g\" y=\"%g\"%s %s>%s</text>\n",
               p1_.x, p1_.y, getSVGMatrix().c_str(), getSVGStroke().c_str(), str_.c_str());
}

void
CQIllustratorTextShape::
saveCmd(const CQIllustratorSaveData & /*saveData*/)
{
}

void
CQIllustratorTextShape::
drawSelect(CQIllustratorShapeDrawer *drawer)
{
  CBBox2D bbox = getFlatBBox();

  CPoint2D p1 = bbox.getLL();
  CPoint2D p2 = bbox.getLR();
  CPoint2D p3 = bbox.getUR();
  CPoint2D p4 = bbox.getUL();

  drawer->drawControlLine(p1, p2);
  drawer->drawControlLine(p2, p3);
  drawer->drawControlLine(p3, p4);
  drawer->drawControlLine(p4, p1);

//const CMatrix2D &m = getFlatMatrix();

  double a = font_->getCharAscent();
  double d = font_->getCharDescent();

  double f = d/(a + d);

  CPoint2D pb1 = p1 + f*(p4 - p1);
  CPoint2D pb2 = p2 + f*(p3 - p2);

  drawer->drawControlLine(pb1, pb2);
}

//-----

CQIllustratorTextShapeControlPoint::
CQIllustratorTextShapeControlPoint(CQIllustratorTextShape::ControlPointType type,
                                   const CPoint2D &p) :
 CQIllustratorShapeControlPoint((uint) type, p), type_(type)
{
}

CQIllustratorTextShapeControlPoint *
CQIllustratorTextShapeControlPoint::
dup() const
{
  return new CQIllustratorTextShapeControlPoint(type_, point_);
}

CPoint2D
CQIllustratorTextShapeControlPoint::
getPoint(const CQIllustratorShape *shape) const
{
  const CQIllustratorTextShape *text = dynamic_cast<const CQIllustratorTextShape *>(shape);
  assert(text);

  if      (type_ == CQIllustratorTextShape::TYPE_LL)
    return text->getLL();
  else if (type_ == CQIllustratorTextShape::TYPE_UR)
    return text->getUR();
  else
    assert(false);
}

void
CQIllustratorTextShapeControlPoint::
setPoint(CQIllustratorShape *shape, const CPoint2D &point)
{
  CQIllustratorTextShape *text = dynamic_cast<CQIllustratorTextShape *>(shape);
  assert(text);

  if      (type_ == CQIllustratorTextShape::TYPE_LL)
    text->setLL(point);
  else if (type_ == CQIllustratorTextShape::TYPE_UR)
    text->setUR(point);
  else
    assert(false);
}

//--------------

CQIllustratorGroupShape::
CQIllustratorGroupShape() :
 CQIllustratorShape()
{
}

CQIllustratorGroupShape::
CQIllustratorGroupShape(const CQIllustratorGroupShape &group) :
 CQIllustratorShape(group)
{
  // TODO: dup children ?
}

CQIllustratorGroupShape *
CQIllustratorGroupShape::
dup() const
{
  return new CQIllustratorGroupShape(*this);
}

void
CQIllustratorGroupShape::
childrenChanged()
{
  invalidateBBox();
}

void
CQIllustratorGroupShape::
getControlPoints(ControlPointList &points, ControlType type) const
{
  if (type == CONTROL_GEOMETRY) {
    const CBBox2D &bbox = getBBox();

    CPoint2D p1 = bbox.getLL();
    CPoint2D p2 = bbox.getUR();

    points.push_back(new CQIllustratorGroupShapeControlPoint(0, p1));
    points.push_back(new CQIllustratorGroupShapeControlPoint(1, p2));
  }
  else
    CQIllustratorShape::getControlPoints(points, type);
}

void
CQIllustratorGroupShape::
setControlPoint(const CQIllustratorShapeControlPoint *)
{
  // TODO
}

void
CQIllustratorGroupShape::
scale(const CPoint2D &c, double sx, double sy)
{
  CQIllustratorShape::scale(c, sx, sy);

  invalidateBBox();
}

void
CQIllustratorGroupShape::
rotate(double da)
{
  CQIllustratorShape::rotate(da);

  invalidateBBox();
}

void
CQIllustratorGroupShape::
transform(const CPoint2D &c, const CMatrix2D &m)
{
  CQIllustratorShape::transform(c, m);

  invalidateBBox();
}

void
CQIllustratorGroupShape::
updateBBox() const
{
  if (! bbox_valid_) {
    CBBox2D bbox;

    ShapeList::const_iterator ps1, ps2;

    for (ps1 = shapes_.begin(), ps2 = shapes_.end(); ps1 != ps2; ++ps1)
      bbox += (*ps1)->getBBox();

    CPoint2D p1 = bbox.getLL();
    CPoint2D p2 = bbox.getLR();
    CPoint2D p3 = bbox.getUL();
    CPoint2D p4 = bbox.getUR();

    bbox_ = CBBox2D(p1, p3);

    bbox_ += p2;
    bbox_ += p4;

    bbox_valid_ = true;
  }
}

bool
CQIllustratorGroupShape::
getPolygon(CPolygon2D &) const
{
  return false;
}

bool
CQIllustratorGroupShape::
getPath(CPathShapePartList &) const
{
  return false;
}

void
CQIllustratorGroupShape::
getPolygons(std::vector<CPolygon2D> &polygons) const
{
  ShapeList::const_iterator ps1, ps2;

  for (ps1 = shapes_.begin(), ps2 = shapes_.end(); ps1 != ps2; ++ps1) {
    CPolygon2D polygon;

    if (! (*ps1)->getPolygon(polygon))
      continue;

    polygons.push_back(polygon);
  }
}

void
CQIllustratorGroupShape::
moveBy(const CPoint2D &d)
{
  assert(! getFixed());

  checkoutShape(CQIllustratorData::CHANGE_GEOMETRY);

  //CQIllustratorShape::moveBy(d);

  ShapeList::const_iterator ps1, ps2;

  for (ps1 = shapes_.begin(), ps2 = shapes_.end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = *ps1;

    shape->moveBy(d);
  }

  invalidateBBox();

  checkinShape(CQIllustratorData::CHANGE_GEOMETRY);
}

bool
CQIllustratorGroupShape::
flip(bool x_axis)
{
  bool rc = true;

  ShapeList::const_iterator ps1, ps2;

  for (ps1 = shapes_.begin(), ps2 = shapes_.end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = *ps1;

    bool rc1 = shape->flip(x_axis);

    // if fails replace with polygon ?
    if (! rc1)
      rc = false;
  }

  return rc;
}

void
CQIllustratorGroupShape::
drawShape(CQIllustratorShapeDrawer *drawer) const
{
  //const CMatrix2D &m = getFlatMatrix();

  ShapeList::const_iterator ps1, ps2;

  for (ps1 = shapes_.begin(), ps2 = shapes_.end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = *ps1;

    //CMatrix2D m1 = shape->getMatrix();

    //shape->setMatrix(m*m1);

    shape->draw(drawer);

    //shape->setMatrix(m1);
  }
}

CQIllustratorShapeGeometry *
CQIllustratorGroupShape::
getGeometry()
{
  return new CQIllustratorGroupGeometry(fixed_, rcenter_, m_);
}

void
CQIllustratorGroupShape::
doSetGeometry(const CQIllustratorShapeGeometry *geom)
{
  const CQIllustratorGroupGeometry *geom1 = dynamic_cast<const CQIllustratorGroupGeometry *>(geom);

  if (! geom1) return;

  fixed_   = geom1->fixed_;
  rcenter_ = geom1->rcenter_;
  m_       = geom1->m_;

  invalidateBBox();
}

void
CQIllustratorGroupShape::
saveSVG(const CQIllustratorSaveData &saveData)
{
  CFile *file = saveData.file;

  file->printf("<g>\n");

  ShapeList::const_iterator ps1, ps2;

  for (ps1 = shapes_.begin(), ps2 = shapes_.end(); ps1 != ps2; ++ps1)
    (*ps1)->saveSVG(saveData);

  file->printf("</g>\n");
}

void
CQIllustratorGroupShape::
saveCmd(const CQIllustratorSaveData &saveData)
{
  ShapeList::const_iterator ps1, ps2;

  for (ps1 = shapes_.begin(), ps2 = shapes_.end(); ps1 != ps2; ++ps1)
    (*ps1)->saveCmd(saveData);
}

//-----

CQIllustratorGroupShapeControlPoint::
CQIllustratorGroupShapeControlPoint(uint ind, const CPoint2D &p) :
 CQIllustratorShapeControlPoint(ind, p)
{
}

CQIllustratorGroupShapeControlPoint *
CQIllustratorGroupShapeControlPoint::
dup() const
{
  return new CQIllustratorGroupShapeControlPoint(ind_, point_);
}

CPoint2D
CQIllustratorGroupShapeControlPoint::
getPoint(const CQIllustratorShape *) const
{
  return CPoint2D(0,0);
}

void
CQIllustratorGroupShapeControlPoint::
setPoint(CQIllustratorShape *, const CPoint2D &)
{
}

//----------

void
CQIllustratorShapeStroke::
draw(const CQIllustratorShape *shape, CQIllustratorShapeDrawer *drawer) const
{
  drawer->setStroke(shape, *this);

  drawer->pathStroke();
}

void
CQIllustratorShapeFill::
draw(const CQIllustratorShape *shape, CQIllustratorShapeDrawer *drawer) const
{
  drawer->setFill(shape, *this);

  drawer->pathFill(rule_);
}

//----------

CQIllustratorShapeControlLine::
CQIllustratorShapeControlLine(uint id, const CLine2D &line) :
 id_(id), line_(line)
{
}

CLine2D
CQIllustratorShapeControlLine::
getLine(const CQIllustratorShape *) const
{
  return line_;
}

void
CQIllustratorShapeControlLine::
setLine(CQIllustratorShape *, const CLine2D &line)
{
  line_ = line;
}

void
CQIllustratorShapeControlLine::
setLine(const CLine2D &line)
{
  line_ = line;
}

void
CQIllustratorShapeControlLine::
updateLine(CQIllustratorShape *shape, CQIllustratorShapeControlLine *line)
{
  setLine(shape, line->line_);
}

void
CQIllustratorShapeControlLine::
setType(CQIllustratorShape *, CPathPartType)
{
}

bool
operator==(const CQIllustratorShapeControlLine &p1, const CQIllustratorShapeControlLine &p2)
{
  return (p1.id_ == p2.id_);
}

bool
operator!=(const CQIllustratorShapeControlLine &p1, const CQIllustratorShapeControlLine &p2)
{
  return ! (p1 == p2);
}

void
CQIllustratorShapeControlLine::
moveLineTo(CQIllustratorShape *shape, const CLine2D &pos)
{
  setLine(shape, pos);
}

//----------

CQIllustratorShapeControlPoint::
CQIllustratorShapeControlPoint(uint id, const CPoint2D &point, ControlPointType type) :
 id_(id), point_(point), type_(type)
{
}

CPoint2D
CQIllustratorShapeControlPoint::
getPoint(const CQIllustratorShape *) const
{
  return point_;
}

void
CQIllustratorShapeControlPoint::
setPoint(CQIllustratorShape *, const CPoint2D &point)
{
  point_ = point;
}

void
CQIllustratorShapeControlPoint::
setPoint(const CPoint2D &point)
{
  point_ = point;
}

void
CQIllustratorShapeControlPoint::
updatePoint(CQIllustratorShape *shape, CQIllustratorShapeControlPoint *point)
{
  setPoint(shape, point->point_);
}

bool
operator==(const CQIllustratorShapeControlPoint &p1, const CQIllustratorShapeControlPoint &p2)
{
  return (p1.id_ == p2.id_);
}

bool
operator!=(const CQIllustratorShapeControlPoint &p1, const CQIllustratorShapeControlPoint &p2)
{
  return ! (p1 == p2);
}

double
CQIllustratorShapeControlPoint::
distance(const CQIllustratorShape *shape, const CPoint2D &point) const
{
  return pointDist(getPoint(shape), point);
}

void
CQIllustratorShapeControlPoint::
movePointBy(CQIllustratorShape *shape, const CPoint2D &d)
{
  setPoint(shape, getPoint(shape) + d);
}

void
CQIllustratorShapeControlPoint::
movePointTo(CQIllustratorShape *shape, const CPoint2D &pos)
{
  setPoint(shape, pos);
}

double
CQIllustratorShapeControlPoint::
pointDist(const CPoint2D &p1, const CPoint2D &p2)
{
  double dx = p1.x - p2.x;
  double dy = p1.y - p2.y;

  return sqrt(dx*dx + dy*dy);
}

//----------

CQIllustratorShapeFilterMgr *
CQIllustratorShapeFilterMgr::
getInstance()
{
  static CQIllustratorShapeFilterMgr *instance;

  if (! instance)
    instance = new CQIllustratorShapeFilterMgr;

  return instance;
}

CQIllustratorShapeFilterMgr::
CQIllustratorShapeFilterMgr() :
 id_(0)
{
  addFilter(new CQIllustratorShapeGaussianFilter(2.0));
}

CQIllustratorShapeFilterMgr::
~CQIllustratorShapeFilterMgr()
{
}

CQIllustratorShapeFilter *
CQIllustratorShapeFilterMgr::
getFilter(uint id)
{
  FilterMap::const_iterator p = filterMap_.find(id);

  if (p == filterMap_.end())
    return 0;

  return (*p).second;
}

void
CQIllustratorShapeFilterMgr::
addFilter(CQIllustratorShapeFilter *filter)
{
  filter->setId(++id_);

  filterMap_[id_] = filter;
}

//---

CQIllustratorShapeFilter::
CQIllustratorShapeFilter()
{
}

CQIllustratorShapeFilter::
~CQIllustratorShapeFilter()
{
}
##concat##CQIllustratorShapeDrawer.cpp
#include <CQIllustratorShapeDrawer.h>
#include <CQIllustratorCanvas.h>
#include <CQIllustrator.h>

#include <CQImage.h>
#include <CQUtil.h>
#include <QPainter>

#include <xpm/control_point.xpm>
#include <xpm/control_point_active.xpm>
#include <xpm/curve_point.xpm>
#include <xpm/curve_point_active.xpm>

#define IMAGE_DATA(I) I, sizeof(I)/sizeof(char *)

CQIllustratorShapeDrawer::
CQIllustratorShapeDrawer(CQIllustrator *illustrator, QPainter *painter) :
 illustrator_(illustrator),
 painter_    (painter),
 bbox_       (),
 path_       (0),
 qfont_      (),
 m_          (CMATRIX_TYPE_IDENTITY),
 matrices_   ()
{
  path_ = new QPainterPath;

  control_point_image_ =
    CImageMgrInst->createImage(CImageXPMSrc(IMAGE_DATA(control_point_data)));
  control_point_active_image_ =
    CImageMgrInst->createImage(CImageXPMSrc(IMAGE_DATA(control_point_active_data)));

  curve_point_image_ =
    CImageMgrInst->createImage(CImageXPMSrc(IMAGE_DATA(curve_point_data)));
  curve_point_active_image_ =
    CImageMgrInst->createImage(CImageXPMSrc(IMAGE_DATA(curve_point_active_data)));

  qi1_control_ = control_point_image_       .cast<CQImage>()->getQImage();
  qi2_control_ = control_point_active_image_.cast<CQImage>()->getQImage();
  qi1_curve_   = curve_point_image_         .cast<CQImage>()->getQImage();
  qi2_curve_   = curve_point_active_image_  .cast<CQImage>()->getQImage();
}

CQIllustratorShapeDrawer::
~CQIllustratorShapeDrawer()
{
  delete path_;
}

void
CQIllustratorShapeDrawer::
setPainter(QPainter *painter)
{
  painter_ = painter;
}

void
CQIllustratorShapeDrawer::
setBBox(const CBBox2D &bbox)
{
  bbox_ = bbox;
}

void
CQIllustratorShapeDrawer::
setStroke(const CQIllustratorShape *shape, const CQIllustratorShapeStroke &stroke)
{
  illustrator_->setStroke(painter_, shape, stroke);
}

void
CQIllustratorShapeDrawer::
setFill(const CQIllustratorShape *shape, const CQIllustratorShapeFill &fill)
{
  bbox_ = shape->getBBox();

  illustrator_->setFill(painter_, shape, fill, bbox_);
}

void
CQIllustratorShapeDrawer::
setFont(CFontPtr font)
{
  qfont_ = CQUtil::toQFont(font);

  painter_->setFont(qfont_);
}

void
CQIllustratorShapeDrawer::
pushMatrix(const CMatrix2D &m, bool combine)
{
  matrices_.push_back(m_);

  QTransform t1;

  if (combine)
    m_ = m_*m;
  else
    m_ = m;

  QTransform t = CQUtil::toQTransform(m_);

  //painter_->setWorldTransform(t);
  painter_->setTransform(t);
}

void
CQIllustratorShapeDrawer::
popMatrix()
{
  m_ = matrices_.back();

  matrices_.pop_back();

  QTransform t = CQUtil::toQTransform(m_);

  //painter_->setWorldTransform(t);
  painter_->setTransform(t);
}

void
CQIllustratorShapeDrawer::
drawText(const CBBox2D &bbox, const std::string &str, CHAlignType halign, CVAlignType valign)
{
  //QTransform transform = painter_->worldTransform();
  QTransform transform = painter_->transform();

  const CPoint2D &ll = bbox.getLL();
  const CPoint2D &ur = bbox.getUR();

  QPointF p1 = transform.map(QPointF(ll.x, ll.y));
  QPointF p2 = transform.map(QPointF(ur.x, ur.y));

  double fs = qfont_.pointSizeF();

  int pixels_per_inch = painter_->device()->physicalDpiX();
//int pixels_per_inch = painter_->device()->logicalDpiX();

  fs = pixels_per_inch*fs/72.0;

  QPointF pf1 = transform.map(QPointF(0 , 0 ));
  QPointF pf2 = transform.map(QPointF(fs, fs));

  double fs1 = std::max(fabs(pf2.x() - pf1.x()), fabs(pf2.y() - pf1.y()));

  QString qstr(str.c_str());

  QRectF qrect(std::min(p1.x(), p2.x()), std::min(p1.y(), p2.y()),
               fabs(p2.x() - p1.x()), fabs(p2.y() - p1.y()));

  painter_->setWorldMatrixEnabled(false);

  QFont qfont = qfont_;

  int ifs = std::max(1, int(fs1));

  qfont.setPixelSize(ifs);

  int flags = CQUtil::toQAlign(halign) | CQUtil::toQAlign(valign);

  painter_->setFont(qfont);

  painter_->drawText(qrect, flags, qstr);

  painter_->setWorldMatrixEnabled(true);
}

void
CQIllustratorShapeDrawer::
pathInit()
{
  delete path_;

  path_ = new QPainterPath;
}

void
CQIllustratorShapeDrawer::
pathMoveTo(const CPoint2D &p)
{
  path_->moveTo(p.x, p.y);
}

void
CQIllustratorShapeDrawer::
pathLineTo(const CPoint2D &p)
{
  path_->lineTo(p.x, p.y);
}

void
CQIllustratorShapeDrawer::
pathBezierTo(const CPoint2D &p1, const CPoint2D &p2)
{
  path_->quadTo(CQUtil::toQPoint(p1), CQUtil::toQPoint(p2));
}

void
CQIllustratorShapeDrawer::
pathBezierTo(const CPoint2D &p1, const CPoint2D &p2, const CPoint2D &p3)
{
  path_->cubicTo(CQUtil::toQPoint(p1), CQUtil::toQPoint(p2), CQUtil::toQPoint(p3));
}

void
CQIllustratorShapeDrawer::
pathArc(const CPoint2D &c, double xr, double yr, double angle1, double angle2)
{
  QRectF rect(QPointF(c.x - xr, c.y - yr), QPointF(c.x + xr, c.y + yr));

  double a1 = -CMathGen::RadToDeg(angle1);
  double a2 = -CMathGen::RadToDeg(angle2);

  path_->arcTo(rect, a1, a2 - a1);
}

void
CQIllustratorShapeDrawer::
pathText(const CBBox2D &rect, const std::string &str, CHAlignType halign, CVAlignType valign)
{
  double fs = qfont_.pointSizeF();

  int pixels_per_inch = painter_->device()->physicalDpiX();

  fs = pixels_per_inch*fs/24.0;

  //QTransform transform = painter_->worldTransform();
  QTransform transform = painter_->transform();

  QPointF pf1 = transform.map(QPointF(0 , 0 ));
  QPointF pf2 = transform.map(QPointF(fs, fs));

  double fs1 = std::max(fabs(pf2.x() - pf1.x()), fabs(pf2.y() - pf1.y()));

  int ifs = std::max(1, int(fs1));

  QFont qfont = qfont_;

  qfont.setPixelSize(ifs);

  std::vector<std::string> words;

  CStrUtil::addFields(str, words, "\n", false);

  uint num_words = words.size();

  std::vector<double> widths, heights;

  QPainterPath path1;

  path1.addText(QPoint(0, 0), qfont, "qQ");

  QRectF qrect = path1.boundingRect();

  double hq = qrect.height();

  double w = 0;
  double h = 0;

  w  = std::max(w, qrect.width());
  h += qrect.height();

  for (uint i = 0; i < num_words; ++i) {
    QString qstr(words[num_words - i - 1].c_str());

    QPainterPath path1;

    path1.addText(QPoint(0, 0), qfont, qstr);

    QRectF qrect = path1.boundingRect();

    w = std::max(w, qrect.width());

    if (i == 0 || i == num_words - 1)
      h += qrect.height();
    else
      h += hq;

    widths .push_back(qrect.width ());
    heights.push_back(qrect.height());
  }

  double x = rect.getXMin();
  double y = rect.getYMin();

  double dx = rect.getWidth () - w;
  double dy = rect.getHeight() - h;

  if      (halign == CHALIGN_TYPE_LEFT  ) { }
  else if (halign == CHALIGN_TYPE_CENTER) x += dx/2;
  else if (halign == CHALIGN_TYPE_RIGHT ) x += dx;

  if      (valign == CVALIGN_TYPE_BOTTOM) { }
  else if (valign == CVALIGN_TYPE_CENTER) y += dy/2;
  else if (valign == CVALIGN_TYPE_TOP   ) y += dy;

  QTransform transform1;

  transform1.scale(1, -1);

  //painter_->setWorldTransform(transform1, true);
  painter_->setTransform(transform1, true);

  for (uint i = 0; i < num_words; ++i) {
    QString qstr(words[num_words - i - 1].c_str());

    double dw1 = w  - widths [i];
    //double dh1 = hq - heights[i];

    double dx1 = 0;

    if      (halign == CHALIGN_TYPE_LEFT  ) { }
    else if (halign == CHALIGN_TYPE_CENTER) dx1 = dw1/2;
    else if (halign == CHALIGN_TYPE_RIGHT ) dx1 = dw1;

    path_->addText(QPoint(x + dx1, -y), qfont, qstr);

    y += hq;
  }
}

void
CQIllustratorShapeDrawer::
pathClose()
{
  path_->closeSubpath();
}

void
CQIllustratorShapeDrawer::
pathStroke()
{
  painter_->strokePath(*path_, painter_->pen());
}

void
CQIllustratorShapeDrawer::
pathFill(CFillType type)
{
  if (type == FILL_TYPE_EVEN_ODD)
    path_->setFillRule(Qt::OddEvenFill);
  else
    path_->setFillRule(Qt::WindingFill);

  painter_->fillPath(*path_, painter_->brush());
}

void
CQIllustratorShapeDrawer::
pathClip()
{
  painter_->setClipPath(*path_);
}

void
CQIllustratorShapeDrawer::
drawControlLine(const CPoint2D &p1, const CPoint2D &p2)
{
  QPen pen;

  pen.setColor(QColor(255,0,0));
  pen.setStyle(Qt::DashLine);

  painter_->setPen(pen);
  painter_->setBrush(Qt::NoBrush);

  painter_->drawLine(CQUtil::toQPoint(p1), CQUtil::toQPoint(p2));
}

void
CQIllustratorShapeDrawer::
drawGridLine(const CPoint2D &p1, const CPoint2D &p2)
{
  QPen pen;

  pen.setColor(QColor(100,100,255));
  pen.setStyle(Qt::DashLine);

  painter_->setPen(pen);
  painter_->setBrush(Qt::NoBrush);

  painter_->drawLine(CQUtil::toQPoint(p1), CQUtil::toQPoint(p2));
}

void
CQIllustratorShapeDrawer::
drawGridSubLine(const CPoint2D &p1, const CPoint2D &p2)
{
  QPen pen;

  pen.setColor(QColor(200,200,255));
  pen.setStyle(Qt::DashLine);

  painter_->setPen(pen);
  painter_->setBrush(Qt::NoBrush);

  painter_->drawLine(CQUtil::toQPoint(p1), CQUtil::toQPoint(p2));
}

#if 0
void
CQIllustratorShapeDrawer::
drawControlPointNormal(const CPoint2D &point, bool selected)
{
  int ys = (illustrator_->getFlipY() ? -1 : 1);

  //QTransform transform = painter_->worldTransform();
  QTransform transform = painter_->transform();

  QPointF p = transform.map(CQUtil::toQPoint(point)) - QPointF(3, -3*ys);

  painter_->setWorldMatrixEnabled(false);

  if (selected)
    painter_->drawImage(p, qi2_control_);
  else
    painter_->drawImage(p, qi1_control_);

  painter_->setWorldMatrixEnabled(true);
}

void
CQIllustratorShapeDrawer::
drawControlPointControl(const CPoint2D &point, bool selected)
{
  int ys = (illustrator_->getFlipY() ? -1 : 1);

  //QTransform transform = painter_->worldTransform();
  QTransform transform = painter_->transform();

  QPointF p = transform.map(CQUtil::toQPoint(point)) - QPointF(2, -2*ys);

  painter_->setWorldMatrixEnabled(false);

  if (selected)
    painter_->drawImage(p, qi2_curve_);
  else
    painter_->drawImage(p, qi1_curve_);

  painter_->setWorldMatrixEnabled(true);
}
#endif

void
CQIllustratorShapeDrawer::
drawImage(int x, int y, QImage image)
{
  painter_->setWorldMatrixEnabled(false);

  painter_->drawImage(x, y, image);

  painter_->setWorldMatrixEnabled(true);
}

//----------------

CQIllustratorFilterShapeDrawer::
CQIllustratorFilterShapeDrawer(CQIllustratorShapeDrawer *drawer, const CQIllustratorShape *shape) :
 CQIllustratorShapeDrawer(drawer->getIllustrator()), shape_(shape)
{
  QPainter *painter = drawer->getPainter();

  qimage_ = QImage(painter->device()->width(), painter->device()->height(), QImage::Format_ARGB32);

  qimage_.fill(qRgba(0,0,0,0));

  painter_ = new QPainter(&qimage_);

  //painter_->setWorldTransform(painter->worldTransform());
  painter_->setTransform(painter->transform());

  bbox_ = shape_->getBBox();
}

CQIllustratorFilterShapeDrawer::
~CQIllustratorFilterShapeDrawer()
{
  delete painter_;
}

QImage &
CQIllustratorFilterShapeDrawer::
getImage()
{
  return qimage_;
}
##concat##CQIllustratorSizer.cpp
#include <CQIllustratorSizer.h>
#include <CQIllustrator.h>
#include <CQIllustratorHandle.h>
#include <CQIllustratorShapeDrawer.h>

#include <QPainter>

#include <xpm/corner_bl.xpm>
#include <xpm/corner_bl_active.xpm>
#include <xpm/corner_tl.xpm>
#include <xpm/corner_tl_active.xpm>

#include <xpm/rotate_bl.xpm>
#include <xpm/rotate_bl_active.xpm>
#include <xpm/rotate_br.xpm>
#include <xpm/rotate_br_active.xpm>
#include <xpm/rotate_tl.xpm>
#include <xpm/rotate_tl_active.xpm>
#include <xpm/rotate_tr.xpm>
#include <xpm/rotate_tr_active.xpm>

#include <xpm/side_lr.xpm>
#include <xpm/side_lr_active.xpm>
#include <xpm/side_tb.xpm>
#include <xpm/side_tb_active.xpm>

#include <xpm/rcenter.xpm>
#include <xpm/rcenter_active.xpm>

#define IMAGE_DATA(I) I##_data, sizeof(I##_data)/sizeof(char *)

#define ACTIVE_IMAGE_DATA(I) IMAGE_DATA(I), IMAGE_DATA(I##_active)

CQIllustratorSizer::
CQIllustratorSizer(CQIllustrator *illustrator) :
 illustrator_(illustrator), handle_(HANDLE_NONE), press_handle_(HANDLE_NONE), op_(OP_RESIZE)
{
  bl_corner_handle_ = new CQIllustratorHandle(illustrator);
  tr_corner_handle_ = new CQIllustratorHandle(illustrator);
  tl_corner_handle_ = new CQIllustratorHandle(illustrator);
  br_corner_handle_ = new CQIllustratorHandle(illustrator);

  bl_corner_handle_->setImage(ACTIVE_IMAGE_DATA(corner_bl));
  tr_corner_handle_->setImage(ACTIVE_IMAGE_DATA(corner_bl));
  tl_corner_handle_->setImage(ACTIVE_IMAGE_DATA(corner_tl));
  br_corner_handle_->setImage(ACTIVE_IMAGE_DATA(corner_tl));

  //----

  bl_rotate_handle_ = new CQIllustratorHandle(illustrator);
  br_rotate_handle_ = new CQIllustratorHandle(illustrator);
  tl_rotate_handle_ = new CQIllustratorHandle(illustrator);
  tr_rotate_handle_ = new CQIllustratorHandle(illustrator);

  bl_rotate_handle_->setImage(ACTIVE_IMAGE_DATA(rotate_bl));
  br_rotate_handle_->setImage(ACTIVE_IMAGE_DATA(rotate_br));
  tl_rotate_handle_->setImage(ACTIVE_IMAGE_DATA(rotate_tl));
  tr_rotate_handle_->setImage(ACTIVE_IMAGE_DATA(rotate_tr));

  //----

  l_side_handle_ = new CQIllustratorHandle(illustrator);
  b_side_handle_ = new CQIllustratorHandle(illustrator);
  r_side_handle_ = new CQIllustratorHandle(illustrator);
  t_side_handle_ = new CQIllustratorHandle(illustrator);

  l_side_handle_->setImage(ACTIVE_IMAGE_DATA(side_lr));
  b_side_handle_->setImage(ACTIVE_IMAGE_DATA(side_tb));
  r_side_handle_->setImage(ACTIVE_IMAGE_DATA(side_lr));
  t_side_handle_->setImage(ACTIVE_IMAGE_DATA(side_tb));

  //----

  rcenter_handle_ = new CQIllustratorHandle(illustrator);

  rcenter_handle_->setImage(ACTIVE_IMAGE_DATA(rcenter));
}

bool
CQIllustratorSizer::
mousePress(const QPointF &p)
{
  updateActive(p);

  setPressHandleType();

  return (getPressHandleType() != CQIllustratorSizer::HANDLE_NONE);
}

void
CQIllustratorSizer::
mouseRelease(const QPointF &)
{
  resetPressHandleType();
}

void
CQIllustratorSizer::
updateShape(CQIllustratorShape *shape, const QPointF &oldPoint,
            const QPointF &newPoint, bool equal_scale)
{
  double dx = newPoint.x() - oldPoint.x();
  double dy = newPoint.y() - oldPoint.y();

  const CBBox2D &oldBBox = shape->getBBox();

  if (getOpType() == CQIllustratorSizer::OP_RESIZE) {
    CBBox2D newBBox = oldBBox;

    CQIllustratorSizer::HandleType press_handle = getPressHandleType();

    bool is_l = (press_handle & CQIllustratorSizer::HANDLE_L);
    bool is_r = (press_handle & CQIllustratorSizer::HANDLE_R);
    bool is_b = (press_handle & CQIllustratorSizer::HANDLE_B);
    bool is_t = (press_handle & CQIllustratorSizer::HANDLE_T);

    if (illustrator_->getFlipY())
      std::swap(is_b, is_t);

    if (equal_scale) {
      if ((is_l || is_r) && (! is_b && ! is_t)) is_t = true;
      if ((is_b || is_t) && (! is_l && ! is_r)) is_r = true;

      if (fabs(dx) > fabs(dy)) {
        if ((is_r && is_t) || (is_l && is_b))
          dy = dx;
        else
          dy = -dx;
      }
      else {
        if ((is_r && is_t) || (is_l && is_b))
          dx = dy;
        else
          dx = -dy;
      }
    }

    if      (is_l) newBBox.moveBy(CPoint2D(dx,  0), CPoint2D( 0,  0));
    else if (is_r) newBBox.moveBy(CPoint2D( 0,  0), CPoint2D(dx,  0));

    if      (is_b) newBBox.moveBy(CPoint2D( 0, dy), CPoint2D( 0,  0));
    else if (is_t) newBBox.moveBy(CPoint2D( 0,  0), CPoint2D( 0, dy));

    shape->setBBox(newBBox);
  }
  else {
    if (press_handle_ != HANDLE_RC) {
      CPoint2D rc = shape->getRotateCenter();

      double a1 = atan2(oldPoint.y() - rc.y, oldPoint.x() - rc.x);
      double a2 = atan2(newPoint.y() - rc.y, newPoint.x() - rc.x);

      double da = a1 - a2;

      shape->rotate(da);
    }
    else {
      CPoint2D rc = shape->getRotateCenter();

      shape->setRotateCenter(rc + CPoint2D(dx, dy));
    }
  }
}

bool
CQIllustratorSizer::
updateActive(const QPointF &p)
{
  QPointF p1 = transform_.map(p);

  HandleType old_handle = handle_;

  handle_ = HANDLE_NONE;

  if (op_ == OP_RESIZE) {
    bl_corner_handle_->updateActive(p1);
    br_corner_handle_->updateActive(p1);
    tl_corner_handle_->updateActive(p1);
    tr_corner_handle_->updateActive(p1);

    if (bl_corner_handle_->getActive()) handle_ = HANDLE_BL;
    if (br_corner_handle_->getActive()) handle_ = HANDLE_BR;
    if (tl_corner_handle_->getActive()) handle_ = HANDLE_TL;
    if (tr_corner_handle_->getActive()) handle_ = HANDLE_TR;

    l_side_handle_->updateActive(p1);
    b_side_handle_->updateActive(p1);
    r_side_handle_->updateActive(p1);
    t_side_handle_->updateActive(p1);

    if (l_side_handle_->getActive()) handle_ = HANDLE_L;
    if (b_side_handle_->getActive()) handle_ = HANDLE_B;
    if (r_side_handle_->getActive()) handle_ = HANDLE_R;
    if (t_side_handle_->getActive()) handle_ = HANDLE_T;
  }
  else {
    bl_rotate_handle_->updateActive(p1);
    br_rotate_handle_->updateActive(p1);
    tl_rotate_handle_->updateActive(p1);
    tr_rotate_handle_->updateActive(p1);

    if (bl_rotate_handle_->getActive()) handle_ = HANDLE_BL;
    if (br_rotate_handle_->getActive()) handle_ = HANDLE_BR;
    if (tl_rotate_handle_->getActive()) handle_ = HANDLE_TL;
    if (tr_rotate_handle_->getActive()) handle_ = HANDLE_TR;

    l_side_handle_->updateActive(p1);
    b_side_handle_->updateActive(p1);
    r_side_handle_->updateActive(p1);
    t_side_handle_->updateActive(p1);

    if (l_side_handle_->getActive()) handle_ = HANDLE_L;
    if (b_side_handle_->getActive()) handle_ = HANDLE_B;
    if (r_side_handle_->getActive()) handle_ = HANDLE_R;
    if (t_side_handle_->getActive()) handle_ = HANDLE_T;

    rcenter_handle_->updateActive(p1);

    if (rcenter_handle_->getActive()) handle_ = HANDLE_RC;
  }

  return (handle_ != old_handle);
}

void
CQIllustratorSizer::
toggleOp()
{
  op_ = (op_ == OP_RESIZE ? OP_ROTATE : OP_RESIZE);
}

void
CQIllustratorSizer::
draw(CQIllustratorShapeDrawer *drawer, const CQIllustratorShape *shape)
{
  if (! shape) return;

  CBBox2D bbox = shape->getFlatBBox();

  const CPoint2D &rcenter = shape->getRotateCenter();

  QPainter *painter = drawer->getPainter();

  //transform_ = painter->worldTransform();
  transform_ = painter->transform();

  double x1 = bbox.getXMin();
  double y1 = bbox.getYMin();
  double x2 = bbox.getXMax();
  double y2 = bbox.getYMax();

  if (illustrator_->getFlipY())
    std::swap(y1, y2);

  if (op_ == OP_RESIZE) {
    bl_corner_handle_->draw(painter, CPoint2D(x1, y1), CIPoint2D(13, -2));
    br_corner_handle_->draw(painter, CPoint2D(x2, y1), CIPoint2D(-2, -2));
    tl_corner_handle_->draw(painter, CPoint2D(x1, y2), CIPoint2D(13, 13));
    tr_corner_handle_->draw(painter, CPoint2D(x2, y2), CIPoint2D(-2, 13));

    l_side_handle_->draw(painter, CPoint2D(x1, (y1 + y2)/2), CIPoint2D(15,  4));
    r_side_handle_->draw(painter, CPoint2D(x2, (y1 + y2)/2), CIPoint2D(-2,  4));
    b_side_handle_->draw(painter, CPoint2D((x1 + x2)/2, y1), CIPoint2D( 4, -2));
    t_side_handle_->draw(painter, CPoint2D((x1 + x2)/2, y2), CIPoint2D( 4, 15));
  }
  else {
    bl_rotate_handle_->draw(painter, CPoint2D(x1, y1), CIPoint2D(13, -2));
    br_rotate_handle_->draw(painter, CPoint2D(x2, y1), CIPoint2D(-2, -2));
    tl_rotate_handle_->draw(painter, CPoint2D(x1, y2), CIPoint2D(13, 13));
    tr_rotate_handle_->draw(painter, CPoint2D(x2, y2), CIPoint2D(-2, 13));

    l_side_handle_->draw(painter, CPoint2D((x1 + x2)/2, y1), CIPoint2D( 4, -2));
    r_side_handle_->draw(painter, CPoint2D((x1 + x2)/2, y2), CIPoint2D( 4, 15));
    b_side_handle_->draw(painter, CPoint2D(x1, (y1 + y2)/2), CIPoint2D(15,  4));
    t_side_handle_->draw(painter, CPoint2D(x2, (y1 + y2)/2), CIPoint2D(-2,  4));

    rcenter_handle_->draw(painter, rcenter);
  }
}
##concat##CQIllustratorSliceMode.cpp
#include <CQIllustratorSliceMode.h>
#include <CQIllustrator.h>
#include <CQIllustratorShapeDrawer.h>

#include <QPainter>
#include <QBoxLayout>

#include <CQUtil.h>
#include <CQMenu.h>
#include <CQSwatch.h>
#include <CQImageButton.h>

#include <xpm/slice.xpm>

#include <cursors/slice.xbm>
#include <cursors/slicemask.xbm>

CQIllustratorSliceMode::
CQIllustratorSliceMode(CQIllustrator *illustrator) :
 CQIllustratorMode(illustrator, CQIllustrator::MODE_SLICE)
{
  setCursor(slice_bits, slicemask_bits, 2, 2);
}

CQIllustratorSliceToolbar *
CQIllustratorSliceMode::
createToolbar()
{
  toolbar_ = new CQIllustratorSliceToolbar(this);

  return toolbar_;
}

CQMenuItem *
CQIllustratorSliceMode::
createMenuItem(CQMenu *menu)
{
  menuItem_ = new CQMenuItem(menu, "&Slice", CQMenuItem::CHECKABLE);

  menuItem_->setStatusTip("Slice Shape");
  menuItem_->setXPMIcon(slice_data);

  connect(menuItem_->getAction(), SIGNAL(toggled(bool)), this, SLOT(menuItemSlot()));

  return menuItem_;
}

void
CQIllustratorSliceMode::
handleMousePress(const MouseEvent &)
{
}

void
CQIllustratorSliceMode::
handleMouseRelease(const MouseEvent &e)
{
  //QPoint current_ppos = e.pixel;

  if (! moving_) {
  }
  else {
    illustrator_->startUndoGroup("Slice");

    std::vector<CQIllustratorShape *> nshapes;
    std::vector<CQIllustratorShape *> oshapes;

    CPoint2D p1 = CQUtil::fromQPoint(press_wpos_);
    CPoint2D p2 = CQUtil::fromQPoint(e.window);

    CQIllustratorSelectedShapes::iterator ps1, ps2;

    CQIllustratorSelectedShapes *selection = illustrator_->getSelection();

    for (ps1 = selection->begin(), ps2 = selection->end(); ps1 != ps2; ++ps1) {
      CQIllustratorShape *shape = (*ps1).getShape();

      CPolygon2D polygon;

      if (! shape->getPolygon(polygon))
        continue;

      //CBBox2D bbox = polygon.getBBox();

      std::vector< std::vector<CPoint2D> > opolys;

      if (! CMathGeom2D::SlicePolygonByLines(polygon.getPoints(), CLine2D(p1, p2), opolys))
        continue;

      uint num_opolys = opolys.size();

      for (uint i = 0; i < num_opolys; ++i) {
        CQIllustratorPolygonShape *pshape = illustrator_->createPolygonShape();

        pshape->setPoints(opolys[i]);

        pshape->setStroke(shape->getStroke());
        pshape->setFill  (shape->getFill ());

        illustrator_->addShape(pshape);

        nshapes.push_back(pshape);
      }

      oshapes.push_back(shape);
    }

    uint num_oshapes = oshapes.size();

    for (uint i = 0; i < num_oshapes; ++i)
      illustrator_->removeShape(oshapes[i]);

    uint num_nshapes = nshapes.size();

    if (num_nshapes > 0) {
      illustrator_->setSelectShape(0);

      for (uint i = 0; i < num_nshapes; ++i)
        illustrator_->addSelectShape(nshapes[i]);
    }

    illustrator_->endUndoGroup();
  }

  illustrator_->redraw();
}

void
CQIllustratorSliceMode::
handleMouseDrag(const MouseEvent &)
{
  illustrator_->redrawOverlay();
}

void
CQIllustratorSliceMode::
handleMouseMove(const MouseEvent &)
{
}

void
CQIllustratorSliceMode::
drawOverlay(CQIllustratorShapeDrawer *drawer)
{
  if (pressed_) {
    QPainter *painter = drawer->getPainter();

    QPointF current_wpos = illustrator_->getITransform().map(QPointF(curr_ppos_));

    QPen pen;

    pen.setColor(QColor(0,0,0));
    pen.setStyle(Qt::DashLine);

    painter->setPen(pen);
    painter->setBrush(Qt::NoBrush);

    painter->drawLine(press_wpos_, current_wpos);
  }
}

//------------

CQIllustratorSliceToolbar::
CQIllustratorSliceToolbar(CQIllustratorSliceMode *mode) :
 CQIllustratorToolbar(mode), mode_(mode)
{
}

QIcon
CQIllustratorSliceToolbar::
getIcon()
{
  return QIcon(QPixmap(slice_data));
}

void
CQIllustratorSliceToolbar::
addWidgets()
{
}
##concat##CQIllustratorSnap.cpp
#include <CQIllustratorSnap.h>
#include <CQIllustrator.h>

#include <QVBoxLayout>
#include <QLabel>
#include <QCheckBox>
#include <QDoubleSpinBox>

CQIllustratorSnapDock::
CQIllustratorSnapDock(CQIllustrator *illustrator) :
 QWidget(0), illustrator_(illustrator)
{
  QVBoxLayout *layout = new QVBoxLayout(this);
  layout->setMargin(2); layout->setSpacing(2);

  enabledCheck_ = new QCheckBox("Enabled");

  connect(enabledCheck_, SIGNAL(clicked(bool)), this, SLOT(enabledSlot()));

  layout->addWidget(enabledCheck_);

  QGridLayout *gridLayout = new QGridLayout;

  xPitch_ = new QDoubleSpinBox;

  xPitch_->setRange(0.01, 1000);
  xPitch_->setSingleStep(1.0);
  xPitch_->setDecimals(3);

  connect(xPitch_, SIGNAL(valueChanged(double)), this, SLOT(xPitchSlot(double)));

  yPitch_ = new QDoubleSpinBox;

  yPitch_->setRange(0.01, 1000);
  yPitch_->setSingleStep(1.0);
  yPitch_->setDecimals(3);

  connect(yPitch_, SIGNAL(valueChanged(double)), this, SLOT(yPitchSlot(double)));

  gridLayout->addWidget(new QLabel("X Pitch"), 0, 0);
  gridLayout->addWidget(xPitch_              , 0, 1);
  gridLayout->addWidget(new QLabel("Y Pitch"), 1, 0);
  gridLayout->addWidget(yPitch_              , 1, 1);

  gridLayout->setColumnStretch(2, 1);
  gridLayout->setRowStretch   (2, 1);

  layout->addLayout(gridLayout);

  enabledCheck_->setChecked(illustrator_->getSnapEnabled());

  xPitch_->setValue(illustrator_->getSnapXPitch());
  yPitch_->setValue(illustrator_->getSnapYPitch());
}

void
CQIllustratorSnapDock::
enabledSlot()
{
  illustrator_->setSnapEnabled(enabledCheck_->isChecked());
}

void
CQIllustratorSnapDock::
xPitchSlot(double xpitch)
{
  illustrator_->setSnapXPitch(xpitch);
}

void
CQIllustratorSnapDock::
yPitchSlot(double ypitch)
{
  illustrator_->setSnapYPitch(ypitch);
}
##concat##CQIllustratorToolbar.cpp
#include <CQIllustratorToolbar.h>
#include <CQIllustrator.h>
#include <CQIllustratorMode.h>

#include <QPushButton>
#include <QLabel>
#include <QToolButton>
#include <QFrame>
#include <QHBoxLayout>

#include <xpm/CREATE_edit.xpm>
#include <xpm/create_EDIT.xpm>

CQIllustratorToolbar::
CQIllustratorToolbar(CQIllustratorMode *mode) :
 QWidget(0), mode_(mode)
{
}

void
CQIllustratorToolbar::
init()
{
  QHBoxLayout *layout = new QHBoxLayout(this);
  layout->setMargin(0); layout->setSpacing(2);

  QVBoxLayout *buttonLayout = new QVBoxLayout;
  buttonLayout->setMargin(0); buttonLayout->setSpacing(0);

  QPushButton *modeButton = new QPushButton;

  connect(modeButton, SIGNAL(clicked()), this, SLOT(modeSlot()));

  modeButton->setFocusPolicy(Qt::NoFocus);

  modeButton->setIcon(getIcon());

  buttonLayout->addWidget(modeButton);

  if (mode_->isCreateMode()) {
    createEditButton_ = new QToolButton;

    createEditButton_->setIcon(QIcon(QPixmap(CREATE_edit_data)));

    createEditButton_->setAutoRaise(true);
    createEditButton_->setFixedSize(QSize(20,12));

    createEditButton_->setToolTip("Switch between create or edit modes");

    connect(createEditButton_, SIGNAL(clicked()), this, SLOT(createEditSlot()));

    buttonLayout->addWidget(createEditButton_);
  }

  layout->addLayout(buttonLayout);

  QFrame *frame = new QFrame;

  frame->setFixedWidth(4);

  frame->setFrameShape(QFrame::VLine);
  frame->setFrameShadow(QFrame::Raised);

  layout->addWidget(frame);

  addWidgets();

  layout->addStretch(1);
}

void
CQIllustratorToolbar::
addWidgets()
{
}

void
CQIllustratorToolbar::
setSelectedShape(const CQIllustratorShape *)
{
}

void
CQIllustratorToolbar::
setSelectedShapePoint(const CQIllustratorShape *, const CQIllustratorShapeControlPoint *)
{
}

void
CQIllustratorToolbar::
modeSlot()
{
  mode_->getIllustrator()->setCanvasFocus();
}

void
CQIllustratorToolbar::
createEditSlot()
{
  if (mode_->getEditMode() == CQIllustratorMode::CREATE_MODE) {
    mode_->setEditMode(CQIllustratorMode::EDIT_MODE);

    createEditButton_->setIcon(QIcon(QPixmap(create_EDIT_data)));
  }
  else {
    mode_->setEditMode(CQIllustratorMode::CREATE_MODE);

    createEditButton_->setIcon(QIcon(QPixmap(CREATE_edit_data)));
  }
}
##concat##CQIllustratorTransformMode.cpp
#include <CQIllustratorTransformMode.h>
#include <CQIllustrator.h>
#include <CQIllustratorShapeDrawer.h>

#include <QGridLayout>
#include <QLabel>
#include <QTabWidget>
#include <QPushButton>
#include <QToolButton>
#include <QComboBox>
#include <QCheckBox>
#include <QPainter>
#include <QMenu>
#include <QAction>
#include <QIcon>
#include <QPixmap>
#include <QEvent>

#include <CQRealEdit.h>
#include <CQAngleSpinBox.h>
#include <CQUtil.h>
#include <CQMenu.h>
#include <CQDockWidget.h>

#include <xpm/transform.xpm>

CQIllustratorTransformMode::
CQIllustratorTransformMode(CQIllustrator *illustrator) :
 CQIllustratorMode(illustrator, CQIllustrator::MODE_TRANSFORM)
{
}

CQIllustratorTransformToolbar *
CQIllustratorTransformMode::
createToolbar()
{
  toolbar_ = new CQIllustratorTransformToolbar(this);

  return toolbar_;
}

CQMenuItem *
CQIllustratorTransformMode::
createMenuItem(CQMenu *menu)
{
  menuItem_ = new CQMenuItem(menu, "&Transform", CQMenuItem::CHECKABLE);

  menuItem_->setStatusTip("Transform Object");
  menuItem_->setXPMIcon(transform_data);

  connect(menuItem_->getAction(), SIGNAL(toggled(bool)), this, SLOT(menuItemSlot()));

  return menuItem_;
}

void
CQIllustratorTransformMode::
handleMouseRelease(const MouseEvent &e)
{
  if (dragging_) {
    // not moving so select control point
    if (! moving_) {
      selectControlPoint(e);
    }
    // dragging finished so commit
    else {
    }
  }
  // not dragging so do a select
  else {
    CPoint2D p1 = CQUtil::fromQPoint(press_wpos_);
    CPoint2D p2 = CQUtil::fromQPoint(release_wpos_);

    // point click - select at point
    if (! moving_) {
      (void) illustrator_->selectAt(p2, e.event->isControlKey(), e.event->isShiftKey());
    }
    // drag then create rectangle using specified bbox
    else {
      (void) illustrator_->selectIn(CBBox2D(p1, p2), e.event->isControlKey(),
                                    e.event->isShiftKey());
    }
  }

  CQIllustratorMode::handleMouseRelease(e);
}

void
CQIllustratorTransformMode::
handleMouseDrag(const MouseEvent &)
{
  illustrator_->redrawOverlay();
}

void
CQIllustratorTransformMode::
drawOverlay(CQIllustratorShapeDrawer *)
{
}

QCursor
CQIllustratorTransformMode::
getCursor() const
{
  return Qt::OpenHandCursor;
}

//-------------------

CQIllustratorTransformToolbar::
CQIllustratorTransformToolbar(CQIllustratorTransformMode *mode) :
 CQIllustratorToolbar(mode), mode_(mode)
{
}

CQIllustrator *
CQIllustratorTransformToolbar::
getIllustrator() const
{
  return mode_->getIllustrator();
}

QIcon
CQIllustratorTransformToolbar::
getIcon()
{
  return QIcon(QPixmap(transform_data));
}

void
CQIllustratorTransformToolbar::
addWidgets()
{
  QBoxLayout *layout = qobject_cast<QBoxLayout *>(CQIllustratorToolbar::layout());

  QGridLayout *grid = new QGridLayout;
  grid->setMargin(0); grid->setSpacing(2);

  layout->addLayout(grid);

  //-----

  tab_ = new QTabWidget;

  QFont font = tab_->font();

  font.setPointSizeF(font.pointSizeF()*0.7);

  tab_->setFont(font);

  //------

  moveTool_ = new CQTransformMoveTool(this);

  tab_->addTab(moveTool_, "Move");

  //------

  scaleTool_ = new CQTransformScaleTool(this);

  tab_->addTab(scaleTool_, "Scale");

  //------

  rotateTool_ = new CQTransformRotateTool(this);

  tab_->addTab(rotateTool_, "Rotate");

  //------

  skewTool_ = new CQTransformSkewTool(this);

  tab_->addTab(skewTool_, "Skew");

  //------

  grid->addWidget(tab_, 0, 0, 2, 1);

  //------

  QPushButton *resetButton = new QPushButton("Reset");

  connect(resetButton, SIGNAL(clicked()), this, SLOT(resetSlot()));

  grid->addWidget(resetButton, 0, 1, 2, 1);

  //------

  QPushButton *applyButton = new QPushButton("Apply");

  connect(applyButton, SIGNAL(clicked()), this, SLOT(applySlot()));

  grid->addWidget(applyButton, 0, 2, 2, 1);

  //------

  grid->setColumnStretch(3, 1);
}

void
CQIllustratorTransformToolbar::
resetSlot()
{
}

void
CQIllustratorTransformToolbar::
applySlot()
{
  int ind = tab_->currentIndex();

  if      (ind == 0) moveTool_  ->apply();
  else if (ind == 1) scaleTool_ ->apply();
  else if (ind == 2) rotateTool_->apply();
  else if (ind == 3) skewTool_  ->apply();
}

//-------

CQTransformMoveTool::
CQTransformMoveTool(CQIllustratorTransformToolbar *toolbar) :
 QWidget(0), toolbar_(toolbar)
{
  QGridLayout *grid = new QGridLayout(this);
  grid->setMargin(0); grid->setSpacing(8);

  QLabel *hlabel = new QLabel("H");
  QLabel *vlabel = new QLabel("V");

  hedit_ = new CQRealEdit(0.0);
  vedit_ = new CQRealEdit(0.0);

  relativeCheck_ = new QCheckBox("Relative");
  groupCheck_    = new QCheckBox("As Group");

  relativeCheck_->setChecked(true);
  groupCheck_   ->setChecked(true);

  grid->addWidget(hlabel, 0, 0);
  grid->addWidget(hedit_, 0, 1);
  grid->addWidget(vlabel, 0, 2);
  grid->addWidget(vedit_, 0, 3);

  grid->addWidget(relativeCheck_, 0, 4);
  grid->addWidget(groupCheck_   , 0, 5);

  grid->setColumnStretch(6, 1);
}

void
CQTransformMoveTool::
apply()
{
  bool relative = relativeCheck_->isChecked();

  CQIllustrator *illustrator = toolbar_->getIllustrator();

  CPoint2D d(hedit_->getValue(), vedit_->getValue());

  bool snap_x = (relative ? fabs(d.x) > 0 : true);
  bool snap_y = (relative ? fabs(d.y) > 0 : true);

  illustrator->startUndoGroup("Move Current");

  CQIllustratorSelectedShapes *selection = illustrator->getSelection();

  CQIllustratorSelectedShapes::iterator ps1, ps2;

  for (ps1 = selection->begin(), ps2 = selection->end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = (*ps1).getShape();

    if (shape->getFixed()) continue;

    const CBBox2D &bbox = shape->getBBox();

    CPoint2D ll;

    if (relative)
      ll = bbox.getLL() + d;
    else
      ll = d;

    if (snap_x) ll.x = CMathGen::Round(ll.x);
    if (snap_y) ll.y = CMathGen::Round(ll.y);

    shape->moveTo(ll);
  }

  illustrator->endUndoGroup();

  illustrator->redraw();
}

//-------

CQTransformScaleTool::
CQTransformScaleTool(CQIllustratorTransformToolbar *toolbar) :
 QWidget(0), toolbar_(toolbar)
{
  QGridLayout *grid = new QGridLayout(this);
  grid->setMargin(0); grid->setSpacing(8);

  QLabel *wlabel = new QLabel("W");
  QLabel *hlabel = new QLabel("H");

  wedit_ = new CQRealEdit(1.0);
  hedit_ = new CQRealEdit(1.0);

  equalCheck_ = new QCheckBox("Equal Scale");
  groupCheck_ = new QCheckBox("As Group");

  grid->addWidget(wlabel, 0, 0);
  grid->addWidget(wedit_, 0, 1);
  grid->addWidget(hlabel, 0, 2);
  grid->addWidget(hedit_, 0, 3);

  grid->addWidget(equalCheck_, 0, 4);
  grid->addWidget(groupCheck_, 0, 5);

  grid->setColumnStretch(5, 1);
}

void
CQTransformScaleTool::
apply()
{
  //bool equal = equalCheck_->isChecked();

  CQIllustrator *illustrator = toolbar_->getIllustrator();

  double dw = wedit_->getValue();
  double dh = hedit_->getValue();

  illustrator->startUndoGroup("Resize Current");

  CQIllustratorSelectedShapes *selection = illustrator->getSelection();

  CQIllustratorSelectedShapes::iterator ps1, ps2;

  for (ps1 = selection->begin(), ps2 = selection->end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = (*ps1).getShape();

    if (shape->getFixed()) continue;

    CBBox2D bbox = shape->getBBox();

    bbox.setWidth (bbox.getWidth ()*dw);
    bbox.setHeight(bbox.getHeight()*dh);

    shape->setBBox(bbox);
  }

  illustrator->endUndoGroup();

  illustrator->redraw();
}

//-------

CQTransformRotateTool::
CQTransformRotateTool(CQIllustratorTransformToolbar *toolbar) :
 QWidget(0), toolbar_(toolbar)
{
  QGridLayout *grid = new QGridLayout(this);
  grid->setMargin(0); grid->setSpacing(8);

  angleEdit_ = new CQAngleSpinBox(0.0);

  groupCheck_ = new QCheckBox("As Group");

  grid->addWidget(angleEdit_, 0, 0);

  grid->addWidget(groupCheck_, 0, 1);

  grid->setColumnStretch(2, 1);
}

void
CQTransformRotateTool::
apply()
{
  CQIllustrator *illustrator = toolbar_->getIllustrator();

  double a = M_PI*angleEdit_->getValue()/180.0;

  illustrator->startUndoGroup("Rotate Current");

  CQIllustratorSelectedShapes *selection = illustrator->getSelection();

  CQIllustratorSelectedShapes::iterator ps1, ps2;

  for (ps1 = selection->begin(), ps2 = selection->end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = (*ps1).getShape();

    if (shape->getFixed()) continue;

    shape->rotate(a);
  }

  illustrator->endUndoGroup();

  illustrator->redraw();
}

//-------

CQTransformSkewTool::
CQTransformSkewTool(CQIllustratorTransformToolbar *toolbar) :
 QWidget(0), toolbar_(toolbar)
{
  QGridLayout *grid = new QGridLayout(this);
  grid->setMargin(0); grid->setSpacing(8);

  QLabel *hlabel = new QLabel("H");
  QLabel *vlabel = new QLabel("V");

  hedit_ = new CQRealEdit(0.0);
  vedit_ = new CQRealEdit(0.0);

  groupCheck_ = new QCheckBox("As Group");

  grid->addWidget(hlabel, 0, 0);
  grid->addWidget(hedit_, 0, 1);
  grid->addWidget(vlabel, 0, 2);
  grid->addWidget(vedit_, 0, 3);

  grid->addWidget(groupCheck_, 0, 4);

  grid->setColumnStretch(5, 1);
}

void
CQTransformSkewTool::
apply()
{
  CQIllustrator *illustrator = toolbar_->getIllustrator();

  double dx = hedit_->getValue();
  double dy = vedit_->getValue();

  illustrator->startUndoGroup("Rotate Current");

  CQIllustratorSelectedShapes *selection = illustrator->getSelection();

  CQIllustratorSelectedShapes::iterator ps1, ps2;

  for (ps1 = selection->begin(), ps2 = selection->end(); ps1 != ps2; ++ps1) {
    CQIllustratorShape *shape = (*ps1).getShape();

    if (shape->getFixed()) continue;

    shape->skew(dx, dy);
  }

  illustrator->endUndoGroup();

  illustrator->redraw();
}
##concat##CQIllustratorUndo.cpp
#include <CQIllustratorUndo.h>
#include <CQIllustrator.h>

CQIllustratorUndo::
CQIllustratorUndo(CQIllustrator *illustrator) :
 illustrator_(illustrator)
{
  connect(illustrator_->getData(), SIGNAL(objectCreated(CQIllustratorShape *)),
          this, SLOT(objectCreated(CQIllustratorShape *)));
  connect(illustrator_->getData(), SIGNAL(objectDeleted(CQIllustratorShape *)),
          this, SLOT(objectDeleted(CQIllustratorShape *)));
  connect(illustrator_->getData(), SIGNAL(objectPreModify (CQIllustratorShape *, ChangeType)),
          this, SLOT(objectPreModify (CQIllustratorShape *, ChangeType)));
  connect(illustrator_->getData(), SIGNAL(objectPostModify(CQIllustratorShape *, ChangeType)),
          this, SLOT(objectPostModify(CQIllustratorShape *, ChangeType)));
}

bool
CQIllustratorUndo::
addUndo(CUndoData *data)
{
  bool rc = CUndo::addUndo(data);

  emitUndoChanged();

  return rc;
}

bool
CQIllustratorUndo::
undo(uint n)
{
  bool rc = CUndo::undo(n);

  emitUndoChanged();

  return rc;
}

bool
CQIllustratorUndo::
redo(uint n)
{
  bool rc = CUndo::redo(n);

  emitUndoChanged();

  return rc;
}

void
CQIllustratorUndo::
objectCreated(CQIllustratorShape *shape)
{
  if (locked()) return;

  addUndo(new CQIllustratorUndoCreateShape(this, shape, true));
}

void
CQIllustratorUndo::
objectDeleted(CQIllustratorShape *shape)
{
  if (locked()) return;

  addUndo(new CQIllustratorUndoCreateShape(this, shape, false));
}

void
CQIllustratorUndo::
objectPreModify(CQIllustratorShape *shape, CQIllustratorData::ChangeType type)
{
  if (locked()) return;

  if      (type == CQIllustratorData::CHANGE_GEOMETRY)
    addUndo(new CQIllustratorUndoSetShapeGeometry(this, shape));
  else if (type == CQIllustratorData::CHANGE_STROKE)
    addUndo(new CQIllustratorUndoSetShapeStroke(this, shape));
  else if (type == CQIllustratorData::CHANGE_FILL)
    addUndo(new CQIllustratorUndoSetShapeFill(this, shape));
  else
    std::cerr << "object pre-modify (unknown)" << std::endl;
}

void
CQIllustratorUndo::
objectPostModify(CQIllustratorShape *, CQIllustratorData::ChangeType type)
{
  if      (type == CQIllustratorData::CHANGE_GEOMETRY) {
  }
  else if (type == CQIllustratorData::CHANGE_STROKE) {
  }
  else if (type == CQIllustratorData::CHANGE_FILL) {
  }
  else
    std::cerr << "object post-modify (unknown)" << std::endl;
}

void
CQIllustratorUndo::
emitUndoChanged()
{
  emit undoChanged();
}

//----------------

CQIllustratorUndoSetShapeGeometry::
CQIllustratorUndoSetShapeGeometry(CQIllustratorUndo *undo, CQIllustratorShape *shape) :
 undo_(undo), id_(shape->getId())
{
  geom_ = shape->getGeometry()->dup();
}

bool
CQIllustratorUndoSetShapeGeometry::
exec()
{
  CQIllustrator *illustrator = undo_->getIllustrator();

  CQIllustratorShape *shape = illustrator->getShape(id_);
  assert(shape);

  CQIllustratorShapeGeometry *geom = shape->getGeometry()->dup();

  shape->setGeometry(geom_);

  delete geom_;

  geom_ = geom;

  return true;
}

std::string
CQIllustratorUndoSetShapeGeometry::
getDesc() const
{
  CQIllustrator *illustrator = undo_->getIllustrator();

  CQIllustratorShape *shape = illustrator->getShape(id_);

  if (shape)
    return std::string("Set ") + shape->getClassName() + " geometry";
  else
    return "Set ?? geometry";
}

//----------------

CQIllustratorUndoSetShapeStroke::
CQIllustratorUndoSetShapeStroke(CQIllustratorUndo *undo, CQIllustratorShape *shape) :
 undo_(undo), id_(shape->getId())
{
  stroke_ = shape->getStroke();
}

bool
CQIllustratorUndoSetShapeStroke::
exec()
{
  CQIllustrator *illustrator = undo_->getIllustrator();

  CQIllustratorShape *shape = illustrator->getShape(id_);
  assert(shape);

  CQIllustratorShapeStroke stroke = shape->getStroke();

  shape->setStroke(stroke_);

  stroke_ = stroke;

  return true;
}

std::string
CQIllustratorUndoSetShapeStroke::
getDesc() const
{
  CQIllustrator *illustrator = undo_->getIllustrator();

  CQIllustratorShape *shape = illustrator->getShape(id_);

  if (shape)
    return std::string("Set ") + shape->getClassName() + " stroke";
  else
    return "Set ?? stroke";
}

//----------------

CQIllustratorUndoSetShapeFill::
CQIllustratorUndoSetShapeFill(CQIllustratorUndo *undo, CQIllustratorShape *shape) :
 undo_(undo), id_(shape->getId())
{
  fill_ = shape->getFill();
}

bool
CQIllustratorUndoSetShapeFill::
exec()
{
  CQIllustrator *illustrator = undo_->getIllustrator();

  CQIllustratorShape *shape = illustrator->getShape(id_);
  assert(shape);

  CQIllustratorShapeFill fill = shape->getFill();

  shape->setFill(fill_);

  fill_ = fill;

  return true;
}

std::string
CQIllustratorUndoSetShapeFill::
getDesc() const
{
  CQIllustrator *illustrator = undo_->getIllustrator();

  CQIllustratorShape *shape = illustrator->getShape(id_);

  if (shape)
    return std::string("Set ") + shape->getClassName() + " fill";
  else
    return "Set ?? fill";
}

//----------------

CQIllustratorUndoCreateShape::
CQIllustratorUndoCreateShape(CQIllustratorUndo *undo, CQIllustratorShape *shape, bool create) :
 undo_(undo), create_(create), shape_(0), id_(0)
{
  if (create)
    id_ = shape->getId();
  else {
    shape_ = shape->dup();

    shape_->setId(shape->getId());
  }
}

bool
CQIllustratorUndoCreateShape::
exec()
{
  CQIllustrator *illustrator = undo_->getIllustrator();

  // if was deleted then add back
  if (! create_) {
    illustrator->addShape(shape_);

    illustrator->setSelectShape(shape_);

    id_    = shape_->getId();
    shape_ = 0;
  }
  // if was created then delete
  else {
    CQIllustratorShape *shape = illustrator->getShape(id_);

    shape_ = const_cast<CQIllustratorShape *>(shape);
    id_    = 0;

    illustrator->removeShapeFromSelection(shape);

    illustrator->removeShape(shape);
  }

  create_ = ! create_;

  return true;
}

std::string
CQIllustratorUndoCreateShape::
getDesc() const
{
  if (! create_)
    return std::string("Create ") + shape_->getClassName();
  else {
    CQIllustrator *illustrator = undo_->getIllustrator();

    CQIllustratorShape *shape = illustrator->getShape(id_);

    if (shape)
      return std::string("Delete ") + shape->getClassName();
    else
      return "Delete ??";
  }
}
##concat##CQIllustratorUndoDock.cpp
#include <CQIllustratorUndoDock.h>
#include <CQIllustrator.h>
#include <CQIllustratorUndo.h>

#include <QHBoxLayout>
#include <QLabel>
#include <QListWidget>
#include <QListWidgetItem>

#include <xpm/undo_redo_png.h>

class CQIllustratorUndoListGroupItem : public QListWidgetItem {
 public:
  CQIllustratorUndoListGroupItem(const CUndoGroup *group, int ind) :
   ind_(ind) {
    if (group)
      QListWidgetItem::setText(group->getDesc().c_str());
    else
      QListWidgetItem::setText("<Current>");
  }

  int getInd() const { return ind_; }

 private:
  int ind_;
};

class CQIllustratorUndoListDataItem : public QListWidgetItem {
 public:
  CQIllustratorUndoListDataItem(const CUndoData *data, int ind) :
   ind_(ind) {
    if (data)
      QListWidgetItem::setText(data->getDesc().c_str());
    else
      QListWidgetItem::setText("<Current>");
  }

  int getInd() const { return ind_; }

 private:
  int ind_;
};

CQIllustratorUndoDock::
CQIllustratorUndoDock(CQIllustrator *illustrator) :
 QWidget(0), illustrator_(illustrator)
{
  QHBoxLayout *layout = new QHBoxLayout(this);
  layout->setMargin(0); layout->setSpacing(0);

  QLabel *label = new QLabel;

  QPixmap pixmap;

  pixmap.loadFromData(undo_redo_data, UNDO_REDO_DATA_LEN);

  label->setPixmap(pixmap);

  list_ = new QListWidget;

  connect(list_, SIGNAL(itemClicked(QListWidgetItem *)),
          this, SLOT(itemSelectedSlot(QListWidgetItem *)));

  layout->addWidget(label);
  layout->addWidget(list_);

  CQIllustratorUndo *undo = illustrator_->getUndo();

  connect(undo, SIGNAL(undoChanged()), this, SLOT(undoChangedSlot()));
}

void
CQIllustratorUndoDock::
undoChangedSlot()
{
  reload();
}

void
CQIllustratorUndoDock::
itemSelectedSlot(QListWidgetItem *item)
{
  CQIllustratorUndoListGroupItem *item1 = dynamic_cast<CQIllustratorUndoListGroupItem *>(item);

  int ind = item1->getInd();

  CQIllustratorUndo *undo = illustrator_->getUndo();

  if      (ind < 0)
    undo->undo(-ind);
  else if (ind > 0)
    undo->redo( ind);
}

void
CQIllustratorUndoDock::
reload()
{
  CQIllustratorUndo *undo = illustrator_->getUndo();

  list_->clear();

  const CUndo::GroupList &undoList = undo->getUndoList();

  int ind = -undoList.size();

  CUndo::GroupList::const_iterator p1, p2;

  for (p1 = undoList.begin(), p2 = undoList.end(); p1 != p2; ++p1) {
    const CUndoGroup *group = *p1;

    const CUndoGroup::DataList &dataList = group->getDataList();

    if (dataList.empty()) continue;

    CQIllustratorUndoListGroupItem *item = new CQIllustratorUndoListGroupItem(group, ind);

   list_->addItem(item);

#if 0
    CUndoGroup::DataList::const_iterator pg1, pg2;

    for (pg1 = dataList.begin(), pg2 = dataList.end(); pg1 != pg2; ++pg1) {
      const CUndoData *data = *pg1;

      CQIllustratorUndoListDataItem *item = new CQIllustratorUndoListDataItem(data, ind);

      list_->addItem(item);

      ++ind;
    }
#endif

    ++ind;
  }

  CQIllustratorUndoListGroupItem *item = new CQIllustratorUndoListGroupItem(0, 0);

  list_->addItem(item);

  list_->setCurrentItem(item);

  ind = 1;

  const CUndo::GroupList &redoList = undo->getRedoList();

  for (p1 = redoList.begin(), p2 = redoList.end(); p1 != p2; ++p1) {
    const CUndoGroup *group = *p1;

    const CUndoGroup::DataList &dataList = group->getDataList();

    if (dataList.empty()) continue;

   CQIllustratorUndoListGroupItem *item = new CQIllustratorUndoListGroupItem(group, ind);

   list_->addItem(item);

#if 0
    CUndoGroup::DataList::const_iterator pg1, pg2;

    for (pg1 = dataList.begin(), pg2 = dataList.end(); pg1 != pg2; ++pg1) {
      const CUndoData *data = *pg1;

      CQIllustratorUndoListDataItem *item = new CQIllustratorUndoListDataItem(data, ind);

      list_->addItem(item);

      ++ind;
    }
#endif

   ++ind;
  }
}
##concat##CQIllustratorZoomMode.cpp
#include <CQIllustratorZoomMode.h>
#include <CQIllustrator.h>
#include <CQIllustratorShapeDrawer.h>

#include <QPainter>
#include <QBoxLayout>

#include <CQUtil.h>
#include <CQMenu.h>
#include <CQSwatch.h>
#include <CQImageButton.h>

#include <xpm/zoom.xpm>
#include <xpm/zoom_fit.xpm>
#include <xpm/zoom_selected.xpm>
#include <xpm/zoom_in.xpm>
#include <xpm/zoom_out.xpm>

#include <cursors/zoom.xbm>
#include <cursors/zoommask.xbm>

CQIllustratorZoomMode::
CQIllustratorZoomMode(CQIllustrator *illustrator) :
 CQIllustratorMode(illustrator, CQIllustrator::MODE_ZOOM)
{
  setCursor(zoom_bits, zoommask_bits, 2, 2);
}

CQIllustratorZoomToolbar *
CQIllustratorZoomMode::
createToolbar()
{
  toolbar_ = new CQIllustratorZoomToolbar(this);

  return toolbar_;
}

CQMenuItem *
CQIllustratorZoomMode::
createMenuItem(CQMenu *menu)
{
  menuItem_ = new CQMenuItem(menu, "&Zoom In/Out", CQMenuItem::CHECKABLE);

  menuItem_->setStatusTip("Zoom In or Out");
  menuItem_->setXPMIcon(zoom_data);

  connect(menuItem_->getAction(), SIGNAL(toggled(bool)), this, SLOT(menuItemSlot()));

  return menuItem_;
}

void
CQIllustratorZoomMode::
handleMousePress(const MouseEvent &)
{
}

void
CQIllustratorZoomMode::
handleMouseRelease(const MouseEvent &e)
{
  //QPoint current_ppos = e.pixel;

  if (! moving_) {
    CPoint2D c = CQUtil::fromQPoint(e.window);

    double scale = sqrt(2);

    double size = illustrator_->getBBox().getWidth();

    if      (e.event->getButton() == CBUTTON_LEFT) {
      size /= scale;

      CBBox2D bbox(CPoint2D(c.x - size/2, c.y - size/2), CPoint2D(c.x + size/2, c.y + size/2));

      illustrator_->setBBox(bbox);
    }
    else if (e.event->getButton() == CBUTTON_RIGHT) {
      size *= scale;

      CBBox2D bbox(CPoint2D(c.x - size/2, c.y - size/2), CPoint2D(c.x + size/2, c.y + size/2));

      illustrator_->setBBox(bbox);
    }
  }
  else {
    CBBox2D bbox(CQUtil::fromQPoint(press_wpos_), CQUtil::fromQPoint(e.window));

    if      (e.event->getButton() == CBUTTON_LEFT) {
      illustrator_->setBBox(bbox);
    }
    else if (e.event->getButton() == CBUTTON_RIGHT) {
      double sx = illustrator_->getBBox().getWidth () / bbox.getWidth ();
      double sy = illustrator_->getBBox().getHeight() / bbox.getHeight();

      double s = std::min(sx, sy);

      CPoint2D d(s*illustrator_->getBBox().getWidth ()/2.0,
                 s*illustrator_->getBBox().getHeight()/2.0);

      CBBox2D bbox1(bbox.getCenter() - d, bbox.getCenter() + d);

      illustrator_->setBBox(bbox1);
    }
  }

  illustrator_->redraw();
}

void
CQIllustratorZoomMode::
handleMouseDrag(const MouseEvent &)
{
  illustrator_->redrawOverlay();
}

void
CQIllustratorZoomMode::
handleMouseMove(const MouseEvent &)
{
}

void
CQIllustratorZoomMode::
drawOverlay(CQIllustratorShapeDrawer *drawer)
{
  if (pressed_) {
    QPainter *painter = drawer->getPainter();

    QPointF current_wpos = illustrator_->getITransform().map(QPointF(curr_ppos_));

    QPen pen;

    pen.setColor(QColor(0,0,0));
    pen.setStyle(Qt::DashLine);

    painter->setPen(pen);
    painter->setBrush(Qt::NoBrush);

    painter->drawRect(QRectF(press_wpos_, current_wpos));
  }
}

//------------

CQIllustratorZoomToolbar::
CQIllustratorZoomToolbar(CQIllustratorZoomMode *mode) :
 CQIllustratorToolbar(mode), mode_(mode)
{
}

QIcon
CQIllustratorZoomToolbar::
getIcon()
{
  return QIcon(QPixmap(zoom_data));
}

void
CQIllustratorZoomToolbar::
addWidgets()
{
  QBoxLayout *layout = qobject_cast<QBoxLayout *>(CQIllustratorToolbar::layout());

  zoomFitButton_ = new CQImageButton(QPixmap(zoom_fit_data     ));
  zoomSelButton_ = new CQImageButton(QPixmap(zoom_selected_data));
  zoomInButton_  = new CQImageButton(QPixmap(zoom_in_data      ));
  zoomOutButton_ = new CQImageButton(QPixmap(zoom_out_data     ));

  zoomFitButton_->setToolTip("Zoom Fit");
  zoomSelButton_->setToolTip("Zoom Selected");
  zoomInButton_ ->setToolTip("Zoom In");
  zoomOutButton_->setToolTip("Zoom Out");

  connect(zoomFitButton_, SIGNAL(clicked()), this, SLOT(zoomFitSlot()));
  connect(zoomSelButton_, SIGNAL(clicked()), this, SLOT(zoomSelSlot()));
  connect(zoomInButton_ , SIGNAL(clicked()), this, SLOT(zoomInSlot()));
  connect(zoomOutButton_, SIGNAL(clicked()), this, SLOT(zoomOutSlot()));

  CQSwatch *swatch =
    new CQSwatch("Zoom<4>", zoomFitButton_, zoomSelButton_, zoomInButton_, zoomOutButton_);

  layout->addWidget(swatch);
}

void
CQIllustratorZoomToolbar::
zoomFitSlot()
{
  CQIllustrator *illustrator = mode_->getIllustrator();

  illustrator->zoomFit();
}

void
CQIllustratorZoomToolbar::
zoomSelSlot()
{
  CQIllustrator *illustrator = mode_->getIllustrator();

  illustrator->zoomSelected();
}

void
CQIllustratorZoomToolbar::
zoomInSlot()
{
  CQIllustrator *illustrator = mode_->getIllustrator();

  illustrator->zoomIn();
}

void
CQIllustratorZoomToolbar::
zoomOutSlot()
{
  CQIllustrator *illustrator = mode_->getIllustrator();

  illustrator->zoomOut();
}
##concat##CQImageButton.cpp
#include <CQImageButton.h>
#include <CImageMgr.h>
#include <CQImage.h>

CQImageButton::
CQImageButton(const QString &fileName)
{
  CImageFileSrc src(fileName.toStdString());

  CImagePtr image = CImageMgrInst->lookupImage(src);

  init(image);
}

CQImageButton::
CQImageButton(CImagePtr image)
{
  init(image);
}

CQImageButton::
CQImageButton(const char *data[])
{
  QPixmap pixmap(data);

  init(pixmap);
}

CQImageButton::
CQImageButton(uchar *data, uint len)
{
}

CQImageButton::
CQImageButton(const QPixmap &pixmap)
{
  init(pixmap);
}

void
CQImageButton::
init(CImagePtr image)
{
  CQImage *qimage = image.cast<CQImage>();

  if (qimage) {
    QPixmap pixmap = QPixmap::fromImage(qimage->getQImage());

    init(pixmap);
  }
}

void
CQImageButton::
init(const QPixmap &pixmap)
{
  size_ = pixmap.size();

  QIcon icon(pixmap);

  setIcon(icon);

#ifndef OS_OSX
  setFixedSize(size_ + QSize(8, 8));

  setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);
#endif
}

QSize
CQImageButton::
sizeHint() const
{
  return size_ + QSize(8, 8);
}

QSize
CQImageButton::
minimumSizeHint () const
{
  return size_ + QSize(8, 8);
}
##concat##CQImagePreview.cpp
#include <CQImagePreview.h>
#include <CQUtil.h>
#include <CQScrollArea.h>

#include <control.xpm>

#include <QPainter>
#include <QHBoxLayout>
#include <QToolButton>

CQImagePreview::
CQImagePreview(QWidget *parent) :
 QWidget(parent)
{
  QHBoxLayout *layout = new QHBoxLayout(this);
  layout->setMargin(0); layout->setSpacing(0);

  canvas_ = new CQImagePreviewCanvas(this);

  sarea_ = new CQScrollArea(canvas_);

  connect(sarea_, SIGNAL(updateArea()), this, SLOT(canvasUpdateSlot()));

  QToolButton *button = new QToolButton;

  button->setAutoRaise(true);

  button->setIcon(QIcon(QPixmap(control_data)));

  sarea_->setCornerWidget(button);

  layout->addWidget(sarea_);
}

CQImagePreview::
~CQImagePreview()
{
}

void
CQImagePreview::
canvasUpdateSlot()
{
  canvas_->update();
}

void
CQImagePreview::
sendCancelSignal()
{
  emit cancelSignal();
}

CImagePtr
CQImagePreview::
getImage() const
{
  return canvas_->getImage();
}

void
CQImagePreview::
setImage(CImagePtr image)
{
  canvas_->setImage(image);
}

void
CQImagePreview::
setBackground(const CRGBA &bg)
{
  canvas_->setBackground(bg);
}

void
CQImagePreview::
scrollUp(bool page)
{
  sarea_->scrollUp(page);
}

void
CQImagePreview::
scrollDown(bool page)
{
  sarea_->scrollDown(page);
}

void
CQImagePreview::
scrollLeft(bool page)
{
  sarea_->scrollLeft(page);
}

void
CQImagePreview::
scrollRight(bool page)
{
  sarea_->scrollRight(page);
}

//----------

CQImagePreviewCanvas::
CQImagePreviewCanvas(CQImagePreview *view) :
 QWidget     (0),
 view_       (view),
 zoom_factor_(1.0),
 fill_screen_(false),
 keep_aspect_(true)
{
  setFocusPolicy(Qt::StrongFocus);
}

CQImagePreviewCanvas::
~CQImagePreviewCanvas()
{
}

void
CQImagePreviewCanvas::
setImage(CImagePtr image)
{
  image_ = image;

  update();
}

void
CQImagePreviewCanvas::
setBackground(const CRGBA &bg)
{
  bg_ = bg;

  update();
}

void
CQImagePreviewCanvas::
setZoomFactor(double factor)
{
  zoom_factor_ = factor;

  update();
}

void
CQImagePreviewCanvas::
zoomIncrease()
{
  setZoomFactor(2.0*getZoomFactor());
}

void
CQImagePreviewCanvas::
zoomDecrease()
{
  setZoomFactor(0.5*getZoomFactor());
}

void
CQImagePreviewCanvas::
resizeEvent(QResizeEvent *)
{
  view_->getScrollArea()->updateScrollbars();
}

void
CQImagePreviewCanvas::
paintEvent(QPaintEvent *)
{
  QPainter painter(this);

  painter.fillRect(rect(), CQUtil::rgbaToColor(bg_));

  if (! image_.isValid()) return;

  int dx = 0, dy = 0;

  int iw = image_->getWidth ();
  int ih = image_->getHeight();

  if (iw > width())
    dx = view_->getScrollArea()->getXOffset();
  else
    dx = (width() - iw)/2;

  if (ih > height())
    dy = view_->getScrollArea()->getYOffset();
  else
    dy = (height() - ih)/2;

  painter.drawImage(QPoint(dx, dy), CQUtil::toQImage(image_));

  view_->getScrollArea()->setXSize(iw);
  view_->getScrollArea()->setYSize(ih);
}

void
CQImagePreviewCanvas::
keyPressEvent(QKeyEvent *e)
{
  CKeyEvent *ke = CQUtil::convertEvent(e);

  if      (ke->getType() == CKEY_TYPE_Escape)
    view_->sendCancelSignal();
  else if (ke->getType() == CKEY_TYPE_Up)
    view_->scrollUp(ke->isShiftKey());
  else if (ke->getType() == CKEY_TYPE_Down)
    view_->scrollDown(ke->isShiftKey());
  else if (ke->getType() == CKEY_TYPE_Left)
    view_->scrollLeft(ke->isShiftKey());
  else if (ke->getType() == CKEY_TYPE_Right)
    view_->scrollRight(ke->isShiftKey());
}
##concat##CQIntegerEdit.cpp
#include <CQIntegerEdit.h>
#include <CStrUtil.h>

#include <QIntValidator>

CQIntegerEdit::
CQIntegerEdit(QWidget *parent, int value) :
 QLineEdit(parent)
{
  init("edit", value);
}

CQIntegerEdit::
CQIntegerEdit(int value) :
 QLineEdit(0)
{
  init("edit", value);
}

void
CQIntegerEdit::
init(const QString &name, int value)
{
  if (name.length()) setObjectName(name);

  QValidator *validator = new QIntValidator(this);

  //setMinimumSize(QSize(60,0));
  //setMaximumSize(QSize(60,22));

  //setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);

  setValidator(validator);

  connect(this, SIGNAL(editingFinished()), this, SLOT(editingFinishedI()));

  setValue(value);
}

void
CQIntegerEdit::
setValue(int value)
{
  value_ = value;

  valueToWidget();
}

int
CQIntegerEdit::
getValue() const
{
  CQIntegerEdit *th = const_cast<CQIntegerEdit *>(this);

  th->widgetToValue();

  return value_;
}

void
CQIntegerEdit::
editingFinishedI()
{
  if (widgetToValue())
    emit valueChanged(value_);
}

void
CQIntegerEdit::
valueToWidget()
{
  setText(CStrUtil::toString(value_).c_str());
}

bool
CQIntegerEdit::
widgetToValue()
{
  int value = CStrUtil::toInteger(text().toStdString());

  bool changed = (value != value_);

  value_ = value;

  return changed;
}
##concat##CQLayerOption.cpp
#include <CQLayerOption.h>
#include <CQIllustrator.h>
#include <CQImageButton.h>

#include <QHBoxLayout>
#include <QVBoxLayout>
#include <QLabel>
#include <QListWidget>

#include <xpm/layer_up.xpm>
#include <xpm/layer_down.xpm>
#include <xpm/layer_add.xpm>
#include <xpm/layer_remove.xpm>

CQLayerOptionTool::
CQLayerOptionTool(CQIllustrator *illustrator) :
 CQOptionTool(), illustrator_(illustrator), dialog_(0)
{
  dialog_ = new CQLayerOptionDialog(this);

  QVBoxLayout *layout = new QVBoxLayout(this);
  layout->setMargin(0); layout->setSpacing(0);

  QLabel *label = new QLabel("<small><b>Layer</b></small>");

  layout->addWidget(label);

  label_ = new QLabel;

  QFontMetrics fm(font());

  int width = fm.width("ABCDEFGHIJKLM");

  label_->setMinimumWidth(width);

  layout->addWidget(label_);

  connect(dialog_, SIGNAL(valueChanged(const QString &)),
          this, SIGNAL(valueChanged(const QString &)));

  connect(this, SIGNAL(poppingUp()), this, SLOT(populateSlot()));

  //------

  updateLayer();
}

CQOptionToolDialog *
CQLayerOptionTool::
getDialog()
{
  return dialog_;
}

void
CQLayerOptionTool::
updateLayer()
{
  CQIllustratorLayerStack &layerStack = illustrator_->getLayerStack();

  CQIllustratorLayer *layer = layerStack.getCurrentLayer();

  label_->setText(layer->getName().c_str());
}

void
CQLayerOptionTool::
reloadLayers()
{
  dialog_->populate();
}

void
CQLayerOptionTool::
populateSlot()
{
  dialog_->populate();
}

//----------

CQLayerOptionDialog::
CQLayerOptionDialog(CQLayerOptionTool *tool) :
 CQOptionToolDialog(), tool_(tool)
{
  initWidgets();
}

void
CQLayerOptionDialog::
initWidgets()
{
  QVBoxLayout *layout = new QVBoxLayout(this);

  list_ = new QListWidget;

  layout->addWidget(list_);

  //list_->headerItem()->setHidden(true);

  connect(list_, SIGNAL(itemClicked(QListWidgetItem *)),
          this, SLOT(itemSelectedSlot(QListWidgetItem *)));

  QHBoxLayout *buttonLayout = new QHBoxLayout;

  CQImageButton *upButton     = new CQImageButton(QPixmap(up_data   ));
  CQImageButton *downButton   = new CQImageButton(QPixmap(down_data ));
  CQImageButton *addButton    = new CQImageButton(QPixmap(plus_data ));
  CQImageButton *removeButton = new CQImageButton(QPixmap(minus_data));

  connect(addButton, SIGNAL(clicked()), this, SLOT(addLayerSlot()));

  buttonLayout->addWidget(upButton);
  buttonLayout->addWidget(downButton);
  buttonLayout->addStretch();
  buttonLayout->addWidget(addButton);
  buttonLayout->addWidget(removeButton);
  buttonLayout->addStretch();

  layout->addLayout(buttonLayout);
}

void
CQLayerOptionDialog::
itemSelectedSlot(QListWidgetItem *item)
{
  QString name = item->text();

  CQIllustrator *illustrator = tool_->getIllustrator();

  illustrator->setLayer(name.toStdString());
}

void
CQLayerOptionDialog::
addLayerSlot()
{
  CQIllustrator *illustrator = tool_->getIllustrator();

  illustrator->addLayer();
}

void
CQLayerOptionDialog::
populate()
{
  CQIllustrator *illustrator = tool_->getIllustrator();

  list_->clear();

  const CQIllustratorLayerStack &layerStack = illustrator->getLayerStack();

  const CQIllustratorLayerStack::LayerStack &layers = layerStack.getLayerStack();

  CQIllustratorLayerStack::LayerStack::const_iterator p1, p2;

  for (p1 = layers.begin(), p2 = layers.end(); p1 != p2; ++p1) {
    uint id = *p1;

    CQIllustratorLayer *layer = layerStack.getLayer(id);

    std::string name = layer->getName();

    QListWidgetItem *item = new QListWidgetItem(name.c_str());

    list_->addItem(item);
  }
}
##concat##CQLineCap.cpp
#include <CQLineCap.h>
#include <CQUtil.h>
#include <QAction>

#include <pixmaps/cap_square.xpm>
#include <pixmaps/cap_butt.xpm>
#include <pixmaps/cap_round.xpm>

CQLineCap::
CQLineCap(QWidget *parent) :
 QComboBox(parent)
{
  CImagePtr cap_image1 = CImage::create(cap_butt_data  , sizeof(cap_butt_data  )/sizeof(char *),
                                        CFILE_TYPE_IMAGE_XPM);
  CImagePtr cap_image2 = CImage::create(cap_round_data , sizeof(cap_round_data )/sizeof(char *),
                                        CFILE_TYPE_IMAGE_XPM);
  CImagePtr cap_image3 = CImage::create(cap_square_data, sizeof(cap_square_data)/sizeof(char *),
                                        CFILE_TYPE_IMAGE_XPM);

  addItem(CQUtil::imageToIcon(cap_image1), "Butt"  );
  addItem(CQUtil::imageToIcon(cap_image2), "Round" );
  addItem(CQUtil::imageToIcon(cap_image3), "Square");

  setToolTip("Line Cap");

  connect(this, SIGNAL(currentIndexChanged(int)), this, SLOT(capChangedSlot(int)));
}

void
CQLineCap::
setLineCap(CLineCapType cap)
{
  setCurrentIndex(int(cap) - 1);
}

CLineCapType
CQLineCap::
getLineCap() const
{
  return CLineCapType(currentIndex() + 1);
}

void
CQLineCap::
capChangedSlot(int value)
{
  emit valueChanged(CLineCapType(value + 1));
}
##concat##CQLineDash.cpp
#include <CQLineDash.h>
#include <CQUtil.h>
#include <QContextMenuEvent>
#include <QMenu>

#include <pixmaps/dot1.xpm>
#include <pixmaps/dash1.xpm>

#define IMAGE_DATA(I) I, sizeof(I)/sizeof(char *)

CQLineDash::
CQLineDash(QWidget *parent) :
 QLineEdit(parent)
{
  setToolTip("Line Dash\n(List of Dash Lengths)");

  connect(this, SIGNAL(editingFinished()), this, SLOT(dashChangedSlot()));

  CImagePtr image1 = CImageMgrInst->createImage(CImageXPMSrc(IMAGE_DATA(dot1_data)));
  CImagePtr image2 = CImageMgrInst->createImage(CImageXPMSrc(IMAGE_DATA(dash1_data)));

  menu_ = new QMenu;

  menu_->addAction(CQUtil::imageToIcon(image1), "1, 8")->setIconVisibleInMenu(true);
  menu_->addAction(CQUtil::imageToIcon(image2), "4, 4")->setIconVisibleInMenu(true);

  connect(menu_, SIGNAL(triggered(QAction *)), this, SLOT(menuItemActivated(QAction *)));
}

void
CQLineDash::
setLineDash(const CLineDash &dash)
{
  dash_ = dash;

  setText(dash_.toString().c_str());
}

CLineDash
CQLineDash::
getLineDash() const
{
  return dash_;
}

void
CQLineDash::
dashChangedSlot()
{
  CLineDash dash;

  QString str = text();

  if (dash.fromString(str.toStdString())) {
    dash_ = dash;

    emit valueChanged(dash);
  }
}

void
CQLineDash::
contextMenuEvent(QContextMenuEvent *e)
{
  menu_->exec(e->globalPos());
}

void
CQLineDash::
menuItemActivated(QAction *action)
{
  setText(action->text());

  dashChangedSlot();
}
##concat##CQLineJoin.cpp
#include <CQLineJoin.h>
#include <CQUtil.h>
#include <QAction>

#include <pixmaps/join_mitre.xpm>
#include <pixmaps/join_round.xpm>
#include <pixmaps/join_bevel.xpm>

CQLineJoin::
CQLineJoin(QWidget *parent) :
 QComboBox(parent)
{
  CImagePtr join_image1 = CImage::create(join_mitre_data, sizeof(join_mitre_data)/sizeof(char *),
                                         CFILE_TYPE_IMAGE_XPM);
  CImagePtr join_image2 = CImage::create(join_round_data, sizeof(join_round_data)/sizeof(char *),
                                         CFILE_TYPE_IMAGE_XPM);
  CImagePtr join_image3 = CImage::create(join_bevel_data, sizeof(join_bevel_data)/sizeof(char *),
                                         CFILE_TYPE_IMAGE_XPM);

  addItem(CQUtil::imageToIcon(join_image1), "Mitre");
  addItem(CQUtil::imageToIcon(join_image2), "Round");
  addItem(CQUtil::imageToIcon(join_image3), "Bevel");

  setToolTip("Line Join");

  connect(this, SIGNAL(currentIndexChanged(int)), this, SLOT(joinChangedSlot(int)));
}

void
CQLineJoin::
setLineJoin(CLineJoinType join)
{
  setCurrentIndex(int(join) - 1);
}

CLineJoinType
CQLineJoin::
getLineJoin() const
{
  return CLineJoinType(currentIndex() + 1);
}

void
CQLineJoin::
joinChangedSlot(int ind)
{
  emit valueChanged(CLineJoinType(ind + 1));
}
##concat##CQMatrix2D.cpp
#include <CQMatrix2D.h>
#include <CQTableWidget.h>
#include <CQRealEdit.h>
#include <CStrUtil.h>

#include <QVBoxLayout>
#include <QPointer>

class MatrixCell : public CQTableWidgetItem {
 public:
  enum { TYPE = QTableWidgetItem::UserType + 1 };

  MatrixCell(CQMatrix2D *m, int row=-1, int col=-1) :
   CQTableWidgetItem(m->getTableWidget()), m_(m), row_(row), col_(col) {
  }

  MatrixCell *clone() const { return new MatrixCell(m_); }

  QString getString()  {
    double v = getValue();

    return CStrUtil::toString(v).c_str();
  }

  QWidget *createEditor(QWidget *parent) const {
    edit_ = new CQRealEdit(parent);

    return edit_;
  }

  void setEditorData() {
    if (edit_.isNull()) return;

    double v = getValue();

    edit_->setValue(v);
  }

  void getEditorData(QString &str) {
    if (edit_.isNull()) return;

    double v = edit_->getValue();

    m_->setValue(row_, col_, v);

    str = getString();
  }

  bool sizeHint(const QStyleOptionViewItem &, QSize &size) const {
    QFontMetrics fm(font());

    size = QSize(fm.width("XXX.XXXX") + 8, fm.ascent() + fm.descent() + 8);

    return true;
  }

  double getValue() const {
    double v = 0.0;

    if (row_ >= 0 && row_ < 3 && col_ >= 0 && col_ < 3)
      v = m_->getValue(row_, col_);

    return v;
  }

  void setValue(double value) {
    setText(CStrUtil::toString(value).c_str());
  }

 private:
  static uint type_;

  mutable QPointer<CQRealEdit>  edit_;
  CQMatrix2D                   *m_;
  int                           row_, col_;
};

CQMatrix2D::
CQMatrix2D(const CMatrix2D &m) :
 QWidget(0), m_(m)
{
  init();
}

CQMatrix2D::
CQMatrix2D(QWidget *parent, const CMatrix2D &m) :
 QWidget(parent), m_(m)
{
  init();
}

QSize
CQMatrix2D::
minimumSizeHint() const
{
  return sizeHint();
}

QSize
CQMatrix2D::
sizeHint() const
{
  QFontMetrics fm(font());

  QSize size(fm.width("XXX.XXXX") + 8, fm.ascent() + fm.descent() + 8);

  return QSize(3*size.width() + 42, 4*size.height() + 42);
}

void
CQMatrix2D::
init()
{
  QVBoxLayout *layout = new QVBoxLayout(this);

  table_ = new CQTableWidget;

  table_->setColumnCount(3);

  table_->setColumnLabels(QStringList() << "1" << "2" << "3");
  table_->setRowLabels   (QStringList() << "1" << "2" << "3");

  layout->addWidget(table_);

  table_->registerType(MatrixCell::TYPE, new MatrixCell(this));

  table_->setRowCount(3);

  table_->setItem(0, 0, new MatrixCell(this, 0, 0));
  table_->setItem(0, 1, new MatrixCell(this, 0, 1));
  table_->setItem(0, 2, new MatrixCell(this, 0, 2));
  table_->setItem(1, 0, new MatrixCell(this, 1, 0));
  table_->setItem(1, 1, new MatrixCell(this, 1, 1));
  table_->setItem(1, 2, new MatrixCell(this, 1, 2));
  table_->setItem(2, 0, new MatrixCell(this, 2, 0));
  table_->setItem(2, 1, new MatrixCell(this, 2, 1));
  table_->setItem(2, 2, new MatrixCell(this, 2, 2));
}

void
CQMatrix2D::
setValue(const CMatrix2D &m)
{
  m_ = m;

  updateValues();

  update();
}

void
CQMatrix2D::
updateValues()
{
  for (int row = 0; row < 3; ++row)
    for (int col = 0; col < 3; ++col)
      table_->getItem<MatrixCell>(row, col)->setValue(m_.getValue(row, col));
}

void
CQMatrix2D::
setValue(int row, int col, double v)
{
  m_.setValue(col, row, v);

  emit valueChanged();
}

double
CQMatrix2D::
getValue(int row, int col) const
{
  return m_.getValue(col, row);
}
##concat##CQObjectOption.cpp
#include <CQObjectOption.h>
#include <CQIllustrator.h>

#include <QHBoxLayout>
#include <QVBoxLayout>
#include <QLabel>
#include <QTreeWidget>

CQObjectOptionTool::
CQObjectOptionTool(CQIllustrator *illustrator) :
 CQOptionTool(), illustrator_(illustrator), dialog_(0)
{
  dialog_ = new CQObjectOptionDialog(this);

  QVBoxLayout *layout = new QVBoxLayout(this);
  layout->setMargin(0); layout->setSpacing(0);

  QLabel *label = new QLabel("<small><b>Selection</b></small>");

  layout->addWidget(label);

  label_ = new QLabel;

  QFontMetrics fm(font());

  int width = fm.width("ABCDEFGHIJKLM");

  label_->setMinimumWidth(width);

  layout->addWidget(label_);

  connect(illustrator_, SIGNAL(selectionChanged()),
          this, SLOT(selectionChangedSlot()));

  connect(dialog_, SIGNAL(valueChanged(const QString &)),
          this, SIGNAL(valueChanged(const QString &)));

  connect(this, SIGNAL(poppingUp()), this, SLOT(populateSlot()));
}

CQOptionToolDialog *
CQObjectOptionTool::
getDialog()
{
  return dialog_;
}

void
CQObjectOptionTool::
selectionChangedSlot()
{
  const CQIllustratorSelectedShapes *selection = illustrator_->getSelection();

  uint num_selected = selection->size();

  if      (num_selected == 0)
    label_->setText("None");
  else if (num_selected == 1) {
    const CQIllustratorSelectedShape &sshape = selection->front();

    const CQIllustratorShape *shape = sshape.getShape();

    uint num_points = sshape.numPoints();
    uint num_lines  = sshape.numLines ();

    std::string str = shape->getName();

    if (num_points > 0)
      str += " P#" + CStrUtil::toString(num_points);

    if (num_lines > 0)
      str += " L#" + CStrUtil::toString(num_lines);

    label_->setText(str.c_str());
  }
  else
    label_->setText(QString("#%1").arg(num_selected));
}

void
CQObjectOptionTool::
populateSlot()
{
  dialog_->populate(illustrator_);
}

void
CQObjectOptionTool::
selectShape(const std::string &name)
{
  illustrator_->setSelectShape(name);
}

//----------

CQObjectOptionDialog::
CQObjectOptionDialog(CQObjectOptionTool *tool) :
 CQOptionToolDialog(), tool_(tool)
{
  initWidgets();
}

void
CQObjectOptionDialog::
initWidgets()
{
  QVBoxLayout *layout = new QVBoxLayout(this);

  list_ = new QTreeWidget;

  layout->addWidget(list_);

  list_->headerItem()->setHidden(true);

  connect(list_, SIGNAL(itemClicked(QTreeWidgetItem *, int)),
          this, SLOT(itemSelectedSlot(QTreeWidgetItem *, int)));
}

void
CQObjectOptionDialog::
updateWidgets()
{
}

void
CQObjectOptionDialog::
itemSelectedSlot(QTreeWidgetItem *item, int pos)
{
  QString name = item->text(pos);

  tool_->selectShape(name.toStdString());
}

void
CQObjectOptionDialog::
populate(CQIllustrator *illustrator)
{
  list_->clear();

  const CQIllustratorData::ShapeStack &shapes = illustrator->getShapes();

  CQIllustratorData::ShapeStack::const_iterator ps1, ps2;

  for (ps1 = shapes.begin(), ps2 = shapes.end(); ps1 != ps2; ++ps1) {
    const CQIllustratorShape *shape = *ps1;

    if (shape->getParent()) continue;

    QStringList strs;

    strs << shape->getName().c_str();

    QTreeWidgetItem *item = new QTreeWidgetItem(strs);

    list_->addTopLevelItem(item);

    populateChildren(illustrator, item, shape);
  }
}

void
CQObjectOptionDialog::
populateChildren(CQIllustrator *illustrator, QTreeWidgetItem *pitem,
                 const CQIllustratorShape *shape)
{
  const CQIllustratorShape::ShapeList &children = shape->getChildren();

  CQIllustratorShape::ShapeList::const_iterator pc1, pc2;

  for (pc1 = children.begin(), pc2 = children.end(); pc1 != pc2; ++pc1) {
    const CQIllustratorShape *child = *pc1;

    QStringList strs;

    strs << child->getName().c_str();

    QTreeWidgetItem *item = new QTreeWidgetItem(strs);

    pitem->addChild(item);

    populateChildren(illustrator, item, child);
  }
}
##concat##CQOptionToolSet.cpp
#include <CQOptionToolSet.h>

#include <QLabel>
#include <QHBoxLayout>

#include <menu.xpm>
#include <menu_active.xpm>

CQOptionToolSet::
CQOptionToolSet(QWidget *parent) :
 QWidget(parent), currentTool_(0)
{
  QHBoxLayout *layout = new QHBoxLayout(this);
  layout->setMargin(0); layout->setSpacing(0);

  dialogArea_ = new CQOptionToolDialogArea(this);

  dialogArea_->hide();
}

void
CQOptionToolSet::
setPopupArea(QWidget *popupArea)
{
  popdown();

  popupArea_ = popupArea;

  dialogArea_->setParent(popupArea_);
}

void
CQOptionToolSet::
addOption(CQOptionTool *tool)
{
  CQOptionToolArea *area = new CQOptionToolArea(this, tool);

  tool->setArea(area);

  layout()->addWidget(area);

  toolList_.push_back(area);
}

void
CQOptionToolSet::
popup(CQOptionToolArea *tool_area)
{
  CQOptionToolDialog *dialog = tool_area->getTool()->getDialog();

  if (tool_area != currentTool_) {
    popdown();

    if (currentTool_) {
      CQOptionToolMenu *menu = currentTool_->getMenuButton();

      menu->setChecked(false);
    }

    dialogArea_->setWidget(dialog);

    currentTool_ = tool_area;
  }

  tool_area->getTool()->popup(dialogArea_, popupArea_);
}

void
CQOptionToolSet::
popdown(CQOptionToolArea *tool_area)
{
  if (tool_area == currentTool_)
    popdown();
}

void
CQOptionToolSet::
popdown()
{
  if (currentTool_) {
    currentTool_->getTool()->popdown(dialogArea_);

    CQOptionToolMenu *menu = currentTool_->getMenuButton();

    menu->setChecked(false);
  }
}

//------

CQOptionToolArea::
CQOptionToolArea(CQOptionToolSet *toolset, CQOptionTool *tool) :
 QFrame(0), toolset_(toolset), tool_(tool)
{
  setFrameStyle(QFrame::Panel | QFrame::Sunken);
  setLineWidth(1);

  QHBoxLayout *layout = new QHBoxLayout(this);
  layout->setMargin(0); layout->setSpacing(0);

  menuButton_ = new CQOptionToolMenu;

  layout->addWidget(tool);
  layout->setAlignment(tool, Qt::AlignBottom);

  layout->addWidget(menuButton_);
  layout->setAlignment(menuButton_, Qt::AlignBottom);

  connect(menuButton_, SIGNAL(clicked(bool)), this, SLOT(menuPressed(bool)));
}

void
CQOptionToolArea::
menuPressed(bool show)
{
  if (show)
    toolset_->popup(this);
  else
    toolset_->popdown(this);
}

//------

CQOptionToolMenu::
CQOptionToolMenu()
{
  off_pixmap_ = QPixmap((const char **) menu_data);
  on_pixmap_  = QPixmap((const char **) menu_active_data);

  setIcon(QIcon(off_pixmap_));

  setCheckable(true);

  connect(this, SIGNAL(toggled(bool)), this, SLOT(updatePixmap(bool)));

  setFixedSize(QSize(10,20));
}

void
CQOptionToolMenu::
updatePixmap(bool checked)
{
  setIcon(QIcon(checked ? on_pixmap_ : off_pixmap_));
}

//------

CQOptionToolDialogArea::
CQOptionToolDialogArea(CQOptionToolSet *set) :
 CQWinWidget(), set_(set), w_(0)
{
  setResizable(false);

  connect(this, SIGNAL(closed()), this, SLOT(closedSlot()));

}

void
CQOptionToolDialogArea::
setWidget(QWidget *w)
{
  setChild(w);

  w_ = w;
}

void
CQOptionToolDialogArea::
updateSize()
{
  fitChild();
}

void
CQOptionToolDialogArea::
closedSlot()
{
  set_->popdown();
}

//------

CQOptionTool::
CQOptionTool() :
 area_(0)
{
}

void
CQOptionTool::
setArea(CQOptionToolArea *area)
{
  area_ = area;
}

void
CQOptionTool::
popup(CQOptionToolDialogArea *dialogArea, QWidget *popupArea)
{
  emit poppingUp();

  dialogArea->updateSize();

  dialogArea->show();

  // move dialog area bottom right to tool area top right in popup area

  QPoint rt = popupArea->mapFromGlobal(area_->mapToGlobal(area_->rect().topRight()));

  int w = dialogArea->width () + 4;
  int h = dialogArea->height() + 4;

  int x = rt.x() - w;
  int y = rt.y() - h;

  if (x > popupArea->width ()) x = popupArea->width () - w;
  if (x < 0                  ) x = 0;
  if (y > popupArea->height()) y = popupArea->height() - h;
  if (y < 0                  ) y = 0;

  dialogArea->move(x, y);

  emit poppedUp();
}

void
CQOptionTool::
popdown(CQOptionToolDialogArea *area)
{
  emit poppingDown();

  area->hide();

  emit poppedDown();
}

//------

CQOptionToolDialog::
CQOptionToolDialog()
{
}
##concat##CQPointEdit.cpp
#include <CQPointEdit.h>
#include <QDoubleValidator>

#include <CStrUtil.h>
#include <CStrParse.h>

class CQPointEditValidator : public QValidator {
 public:
  CQPointEditValidator(CQPointEdit *edit) :
   QValidator(edit), edit_(edit) {
  }

  State validate(QString &input, int &) const {
    CPoint2D point;

    return edit_->stringToPoint(input.toStdString(), point);
  }

 private:
  CQPointEdit *edit_;
};

//------

CQPointEdit::
CQPointEdit(QWidget *parent, const CPoint2D &value) :
 QLineEdit(parent)
{
  init("edit", value);
}

CQPointEdit::
CQPointEdit(const CPoint2D &value)
{
  init("edit", value);
}

void
CQPointEdit::
init(const QString &name, const CPoint2D &value)
{
  setObjectName(name);

  CQPointEditValidator *validator = new CQPointEditValidator(this);

  setValidator(validator);

  connect(this, SIGNAL(editingFinished()), this, SLOT(editingFinishedI()));

  connect(this, SIGNAL(returnPressed()), this, SLOT(returnPressedI()));

  setValue(value);
}

void
CQPointEdit::
setValue(const CPoint2D &point)
{
  point_ = point;

  pointToWidget();
}

const CPoint2D &
CQPointEdit::
getValue() const
{
  return point_;
}

void
CQPointEdit::
editingFinishedI()
{
  if (widgetToPoint())
    emit valueChanged();
}

void
CQPointEdit::
returnPressedI()
{
  if (widgetToPoint()) {
    emit valueChanged();

    emit valueAccepted();
  }
}

void
CQPointEdit::
pointToWidget()
{
  setText(pointToString(point_).c_str());
}

std::string
CQPointEdit::
pointToString(const CPoint2D &point)
{
  return CStrUtil::strprintf("%g %g", point.getX(), point.getY());
}

bool
CQPointEdit::
widgetToPoint()
{
  CPoint2D point;

  QValidator::State state = stringToPoint(text().toStdString(), point);

  if (state != QValidator::Acceptable)
    return false;

  if (point == point_)
    return false;

  point_ = point;

  return true;
}

QValidator::State
CQPointEdit::
stringToPoint(const std::string &text, CPoint2D &point)
{
  static const char lchars[] = "({[<";
  static const char rchars[] = ")]>";
  static const char mchars[] = ",:;";

  double x, y;

  CStrParse parse(text);

  parse.skipSpace();

  if (parse.eof()) return QValidator::Intermediate;

  char c = parse.getCharAt();

  if (strchr(lchars, c) != 0) {
    parse.skipChar();

    parse.skipSpace();

    if (parse.eof()) return QValidator::Intermediate;
  }

  std::string str;

  if (! parse.readReal(&x)) {
    char c = parse.getCharAt();

    if (c == '-' || c == '+') {
      parse.skipChar();

      c = parse.getCharAt();
    }

    if (parse.eof()) return QValidator::Intermediate;

    if (! isdigit(c))
      return QValidator::Invalid;

    if (! parse.readReal(&x))
      return QValidator::Intermediate;
  }

  parse.skipSpace();

  if (parse.eof()) return QValidator::Intermediate;

  c = parse.getCharAt();

  if (strchr(mchars, c) != 0) {
    parse.skipChar();

    parse.skipSpace();

    if (parse.eof()) return QValidator::Intermediate;
  }

  if (! parse.readReal(&y)) {
    char c = parse.getCharAt();

    if (c == '-' || c == '+') {
      parse.skipChar();

      c = parse.getCharAt();
    }

    if (parse.eof()) return QValidator::Intermediate;

    if (! isdigit(c))
      return QValidator::Invalid;

    if (! parse.readReal(&y))
      return QValidator::Intermediate;
  }

  parse.skipSpace();

  if (! parse.eof()) {
    c = parse.getCharAt();

    if (strchr(rchars, c) != 0) {
      parse.skipChar();

      parse.skipSpace();
    }
  }

  if (! parse.eof()) return QValidator::Invalid;

  point = CPoint2D(x, y);

  return QValidator::Acceptable;
}
##concat##CQPropertiesOption.cpp
#include <CQPropertiesOption.h>
#include <CQIllustrator.h>

#include <CQPointEdit.h>
#include <CQMatrix2D.h>
#include <CQRealEdit.h>
#include <CQAngleSpinBox.h>

#include <QHBoxLayout>
#include <QVBoxLayout>
#include <QGridLayout>
#include <QLabel>
#include <QPushButton>
#include <QLineEdit>
#include <QTabWidget>

CQPropertiesOptionTool::
CQPropertiesOptionTool(CQIllustrator *illustrator) :
 CQOptionTool(), illustrator_(illustrator), dialog_(0)
{
  dialog_ = new CQPropertiesOptionDialog(this);

  QVBoxLayout *layout = new QVBoxLayout(this);
  layout->setMargin(0); layout->setSpacing(0);

  QLabel *label = new QLabel("<small><b>Properties</b></small>");

  layout->addWidget(label);

  label_ = new QLabel;

  QFontMetrics fm(font());

  int width = fm.width("ABCDEFGHIJKLM");

  label_->setMinimumWidth(width);

  layout->addWidget(label_);

  connect(illustrator_, SIGNAL(selectionChanged()),
          this, SLOT(selectionChangedSlot()));
}

CQOptionToolDialog *
CQPropertiesOptionTool::
getDialog()
{
  return dialog_;
}

void
CQPropertiesOptionTool::
selectionChangedSlot()
{
  const CQIllustratorShape *shape = 0;

  const CQIllustratorSelectedShapes *selection = illustrator_->getSelection();

  uint num_selected = selection->size();

  if (num_selected == 1) {
    const CQIllustratorSelectedShape &sshape = selection->front();

    shape = sshape.getShape();
  }

  if (shape)
    label_->setText(shape->getName().c_str());
  else
    label_->setText("");

  dialog_->update(shape);
}

void
CQPropertiesOptionTool::
emitValueChanged()
{
  emit valueChanged();
}

//----------

CQPropertiesOptionDialog::
CQPropertiesOptionDialog(CQPropertiesOptionTool *tool) :
 CQOptionToolDialog(), tool_(tool)
{
  initWidgets();
}

CQIllustrator *
CQPropertiesOptionDialog::
getIllustrator() const
{
  return tool_->getIllustrator();
}

void
CQPropertiesOptionDialog::
initWidgets()
{
  QVBoxLayout *layout = new QVBoxLayout(this);

  layout->setMargin(0); layout->setSpacing(0);

  tab_ = new QTabWidget;

  layout->addWidget(tab_);

  //-----

  QWidget *valuesPanel = new QWidget;

  QGridLayout *valuesLayout = new QGridLayout(valuesPanel);

  valuesLayout->setMargin(2); valuesLayout->setSpacing(2);

  valuesLayout->addWidget(new QLabel("Name"    ), 0, 0);
  valuesLayout->addWidget(new QLabel("Class"   ), 1, 0);
  valuesLayout->addWidget(new QLabel("Position"), 2, 0);
  valuesLayout->addWidget(new QLabel("Size"    ), 3, 0);
  valuesLayout->addWidget(new QLabel("Text"    ), 4, 0);

  nameEdit_  = new QLineEdit;
  classEdit_ = new QLineEdit;
  posEdit_   = new CQPointEdit;
  sizeEdit_  = new CQPointEdit;
  textEdit_  = new QLineEdit;

  connect(nameEdit_, SIGNAL(returnPressed()), this, SLOT(updateShape()));
  connect(posEdit_ , SIGNAL(valueAccepted()), this, SLOT(updateShape()));
  connect(sizeEdit_, SIGNAL(valueAccepted()), this, SLOT(updateShape()));
  connect(textEdit_, SIGNAL(returnPressed()), this, SLOT(updateShape()));

  valuesLayout->addWidget(nameEdit_ , 0, 1);
  valuesLayout->addWidget(classEdit_, 1, 1);
  valuesLayout->addWidget(posEdit_  , 2, 1);
  valuesLayout->addWidget(sizeEdit_ , 3, 1);
  valuesLayout->addWidget(textEdit_ , 4, 1);

  valuesLayout->setRowStretch(5, 1);

  tab_->addTab(valuesPanel, "Values");

  //-----

  QWidget *pointsPanel = new QWidget;

  QVBoxLayout *pointsLayout = new QVBoxLayout(pointsPanel);

  pointsLayout->setMargin(2); pointsLayout->setSpacing(2);

  table_ = new CQControlPointsTable(this);

  pointsLayout->addWidget(table_);

  tab_->addTab(pointsPanel, "Points");

  //-----

  transformPanel_ = new CQTransformPanel(this);

  tab_->addTab(transformPanel_, "Transform");

  //-----

  QWidget *filterPanel = new QWidget;

  QGridLayout *filterLayout = new QGridLayout(filterPanel);

  filterLayout->setMargin(2); filterLayout->setSpacing(2);

  filterLayout->addWidget(new QLabel("Filter"), 0, 0);

  filterEdit_ = new QLineEdit;

  connect(filterEdit_, SIGNAL(returnPressed()), this, SLOT(updateShape()));

  filterLayout->addWidget(filterEdit_, 0, 1);

  filterLayout->setRowStretch(2, 1);

  tab_->addTab(filterPanel, "Filter");
}

void
CQPropertiesOptionDialog::
updateWidgets()
{
}

void
CQPropertiesOptionDialog::
update(const CQIllustratorShape *shape)
{
  table_->clear();

  if (shape) {
    name_ = shape->getName();

    const CBBox2D &bbox = shape->getBBox();

    nameEdit_ ->setText (name_.c_str());
    classEdit_->setText (shape->getClassName());
    posEdit_  ->setValue(bbox.getLL());
    sizeEdit_ ->setValue(CPoint2D(bbox.getWidth(), bbox.getHeight()));

    const CQIllustratorTextShape *text = dynamic_cast<const CQIllustratorTextShape *>(shape);

    if (text)
      textEdit_->setText(text->getText().c_str());
    else
      textEdit_->setText("");

    CQIllustratorShape::ControlPointList points;

    shape->getControlPoints(points);

    uint num_points = points.size();

    table_->setRowCount(num_points);

    for (uint i = 0; i < num_points; ++i) {
      CQIllustratorShapeControlPoint *point = points[i];

      table_->addPoint(shape, i, point);
    }

    transformPanel_->getMatrix()->setValue(shape->getMatrix());

    CQIllustratorShapeFilter *filter = shape->getFilter();

    if (filter)
      filterEdit_->setText(QString("%1").arg(filter->getId()));
    else
      filterEdit_->setText("<none>");
  }
  else {
    name_ = "";

    nameEdit_ ->setText("");
    classEdit_->setText("");
    posEdit_  ->setText("");
    sizeEdit_ ->setText("");
    textEdit_ ->setText("");

    transformPanel_->getMatrix()->setValue(CMatrix2D(CMATRIX_TYPE_IDENTITY));

    filterEdit_->setText("");
  }
}

void
CQPropertiesOptionDialog::
updateShape()
{
  CQIllustrator *illustrator = getIllustrator();

  CQIllustratorShape *shape = illustrator->getShape(name_);

  if (shape) {
    illustrator->checkoutShape(shape, CQIllustratorData::CHANGE_GEOMETRY);

    shape->setName(nameEdit_->text().toStdString());

    CPoint2D pos = posEdit_->getValue();

    shape->moveTo(pos);

    CQIllustratorTextShape *text = dynamic_cast<CQIllustratorTextShape *>(shape);

    if (text)
      text->setText(textEdit_->text().toStdString());

    shape->setMatrix(transformPanel_->getMatrix()->getValue());

    bool ok;

    int filterNum = filterEdit_->text().toInt(&ok);

    if (ok)
      shape->setFilter(filterNum);
    else
      shape->unsetFilter();

    illustrator->checkinShape(shape, CQIllustratorData::CHANGE_GEOMETRY);
  }

  tool_->emitValueChanged();
}

void
CQPropertiesOptionDialog::
replaceMatrixSlot()
{
  CQIllustratorShape *shape = tool_->getIllustrator()->getShape(name_);

  if (! shape) return;

  CMatrix2D m = transformPanel_->getNewMatrix();

  shape->setMatrix(m);

  tool_->emitValueChanged();
}

void
CQPropertiesOptionDialog::
appendMatrixSlot()
{
  CQIllustratorShape *shape = tool_->getIllustrator()->getShape(name_);

  if (! shape) return;

  CMatrix2D m = transformPanel_->getNewMatrix();

  shape->setMatrix(m*shape->getMatrix());

  tool_->emitValueChanged();
}

void
CQPropertiesOptionDialog::
resetMatrixSlot()
{
  CQIllustratorShape *shape = tool_->getIllustrator()->getShape(name_);

  if (! shape) return;

  shape->setMatrix(CMatrix2D(CMATRIX_TYPE_IDENTITY));

  tool_->emitValueChanged();
}

//------

CQControlPointsTable::
CQControlPointsTable(CQPropertiesOptionDialog *dialog) :
 CQTableWidget(), dialog_(dialog)
{
  clear();

  connect(this, SIGNAL(valueChanged(int, int)), this, SLOT(updatePointsSlot()));
}

CQIllustrator *
CQControlPointsTable::
getIllustrator() const
{
  return dialog_->getIllustrator();
}

void
CQControlPointsTable::
clear()
{
  CQTableWidget::clear();

  setColumnCount(2);

  setColumnLabel(0, "Index");
  setColumnLabel(1, "Point");
}

void
CQControlPointsTable::
addPoint(const CQIllustratorShape *shape, uint pos, CQIllustratorShapeControlPoint *point)
{
  CQControlPointItem *item = new CQControlPointItem(this, shape, point);

  int ind = point->getId();

  setItem(pos, 0, QString("%1").arg(ind));
  setItem(pos, 1, item);
}

void
CQControlPointsTable::
updatePointsSlot()
{
#if 0
  int num_rows = rowCount();

  int ind = 0;

  CGenGradient::StopList &stops = list_->getStops();

  CGenGradient::StopList::iterator p1, p2;

  for (p1 = stops.begin(), p2 = stops.end(); p1 != p2 && ind < num_rows; ++p1, ++ind) {
    CGradientStop &stop = *p1;

    CQControlPointItem *item = getItem<CQControlPointItem >(ind, 1);

    CPoint2D p = item->getValue();

    shape->setControlPoint(p);
  }

  list_->emitStopsChanged();
#endif
}

//------

CQControlPointItem::
CQControlPointItem(CQControlPointsTable *t, const CQIllustratorShape *shape,
                   CQIllustratorShapeControlPoint *point) :
 CQTableWidgetItem(t), table_(t), shape_(shape), point_(0), edit_(0)
{
  point_ = point->dup();
}

CQControlPointItem::
~CQControlPointItem()
{
  delete point_;
}

CQControlPointItem *
CQControlPointItem::
clone() const
{
  return new CQControlPointItem(table_, shape_, point_);
}

QString
CQControlPointItem::
getString()
{
  return CQPointEdit::pointToString(point_->getPoint(shape_)).c_str();
}

QWidget *
CQControlPointItem::
createEditor(QWidget *parent) const
{
  edit_ = new CQPointEdit(parent);

  return edit_;
}

void
CQControlPointItem::
setEditorData()
{
  if (edit_.isNull()) return;

  edit_->setValue(point_->getPoint(shape_));
}

void
CQControlPointItem::
getEditorData(QString &str)
{
  if (edit_.isNull()) return;

  CQIllustrator *illustrator = table_->getIllustrator();

  CPoint2D point = edit_->getValue();

  str = CQPointEdit::pointToString(point).c_str();

  CPoint2D point1 = point_->getPoint(shape_);

  if (point != point1) {
    CQIllustratorShape *shape = const_cast<CQIllustratorShape *>(shape_);

    illustrator->checkoutShape(shape, CQIllustratorData::CHANGE_GEOMETRY);

    point_->setPoint(shape, point);

    illustrator->checkinShape(shape, CQIllustratorData::CHANGE_GEOMETRY);
  }
}

bool
CQControlPointItem::
sizeHint(const QStyleOptionViewItem &option, QSize &size) const
{
  size = QSize(option.rect.width(), option.rect.height());

  return true;
}

//---------------

CQTransformPanel::
CQTransformPanel(CQPropertiesOptionDialog *dialog) :
 dialog_(dialog)
{
  QVBoxLayout *layout = new QVBoxLayout(this);

  layout->setMargin(2); layout->setSpacing(2);

  matrix_ = new CQMatrix2D(this);

  connect(matrix_, SIGNAL(valueChanged()), dialog, SLOT(updateShape()));

  layout->addWidget(matrix_);

  tabWidget_ = new QTabWidget;

  //------

  QWidget *translatePanel = new QWidget;

  QGridLayout *translateLayout = new QGridLayout(translatePanel);

  QLabel *translateXLabel = new QLabel("X");
  QLabel *translateYLabel = new QLabel("Y");

  translateXEdit_ = new CQRealEdit(0.0);
  translateYEdit_ = new CQRealEdit(0.0);

  translateLayout->addWidget(translateXLabel, 0, 0);
  translateLayout->addWidget(translateXEdit_, 0, 1);
  translateLayout->addWidget(translateYLabel, 1, 0);
  translateLayout->addWidget(translateYEdit_, 1, 1);

  tabWidget_->addTab(translatePanel, "Translate");

  //------

  QWidget *scalePanel = new QWidget;

  QGridLayout *scaleLayout = new QGridLayout(scalePanel);

  QLabel *scaleXLabel = new QLabel("X");
  QLabel *scaleYLabel = new QLabel("Y");

  scaleXEdit_ = new CQRealEdit(1.0);
  scaleYEdit_ = new CQRealEdit(1.0);

  scaleLayout->addWidget(scaleXLabel, 0, 0);
  scaleLayout->addWidget(scaleXEdit_, 0, 1);
  scaleLayout->addWidget(scaleYLabel, 1, 0);
  scaleLayout->addWidget(scaleYEdit_, 1, 1);

  tabWidget_->addTab(scalePanel, "Scale");

  //------

  QWidget *rotatePanel = new QWidget;

  QGridLayout *rotateLayout = new QGridLayout(rotatePanel);

  QLabel *rotateAngleLabel = new QLabel("Angle");

  rotateAngleEdit_ = new CQAngleSpinBox(0.0);

  rotateLayout->addWidget(rotateAngleLabel, 0, 0);
  rotateLayout->addWidget(rotateAngleEdit_, 0, 1);

  tabWidget_->addTab(rotatePanel, "Rotate");

  //------

  QWidget *skewPanel = new QWidget;

  QGridLayout *skewLayout = new QGridLayout(skewPanel);

  QLabel *skewXLabel = new QLabel("X");
  QLabel *skewYLabel = new QLabel("Y");

  skewXEdit_ = new CQRealEdit(0.0);
  skewYEdit_ = new CQRealEdit(0.0);

  skewLayout->addWidget(skewXLabel, 0, 0);
  skewLayout->addWidget(skewXEdit_, 0, 1);
  skewLayout->addWidget(skewYLabel, 1, 0);
  skewLayout->addWidget(skewYEdit_, 1, 1);

  tabWidget_->addTab(skewPanel, "Skew");

  //------

  layout->addWidget(tabWidget_);

  QHBoxLayout *buttonsLayout = new QHBoxLayout;

  QPushButton *replaceMatrix = new QPushButton("Replace");
  QPushButton *appendMatrix  = new QPushButton("Append");
  QPushButton *resetMatrix   = new QPushButton("Reset");

  buttonsLayout->addWidget(replaceMatrix);
  buttonsLayout->addWidget(appendMatrix);
  buttonsLayout->addWidget(resetMatrix);

  layout->addLayout(buttonsLayout);

  connect(replaceMatrix, SIGNAL(clicked()), dialog, SLOT(replaceMatrixSlot()));
  connect(appendMatrix , SIGNAL(clicked()), dialog, SLOT(appendMatrixSlot()));
  connect(resetMatrix  , SIGNAL(clicked()), dialog, SLOT(resetMatrixSlot()));
}

CMatrix2D
CQTransformPanel::
getNewMatrix() const
{
  int ind = tabWidget_->currentIndex();

  switch (ind) {
    case 0:
      return CMatrix2D::translation(translateXEdit_->getValue(), translateYEdit_->getValue());
    case 1:
      return CMatrix2D::scale(scaleXEdit_->getValue(), scaleYEdit_->getValue());
    case 2:
      return CMatrix2D::rotation(M_PI*rotateAngleEdit_->getValue()/180.0);
    case 3:
      return CMatrix2D::skew(skewXEdit_->getValue(), skewYEdit_->getValue());
  }

  return CMatrix2D::identity();
}
##concat##CQRadioButtons.cpp
#include <CQRadioButtons.h>

#include <QHBoxLayout>
#include <QVBoxLayout>
#include <QLabel>
#include <QRadioButton>

CQHRadioButtons::
CQHRadioButtons(QWidget *parent, const char *name, ...) :
 CQRadioButtons(parent)
{
  va_list vargs;

  va_start(vargs, name);

  std::vector<QString> names;

  while (name != 0) {
    names.push_back(name);

    name = va_arg(vargs, char *);
  }

  va_end(vargs);

  addButtons(names);
}

CQHRadioButtons::
CQHRadioButtons(QWidget *parent) :
 CQRadioButtons(parent)
{
}

QLayout *
CQHRadioButtons::
createLayout(QWidget *parent)
{
  QHBoxLayout *l = new QHBoxLayout(parent);
  l->setMargin(0); l->setSpacing(0);

  return l;
}

void
CQHRadioButtons::
addWidget(QWidget *widget)
{
  QHBoxLayout *l = qobject_cast<QHBoxLayout *>(layout());

  l->addWidget(widget);
}

//-----------

CQVRadioButtons::
CQVRadioButtons(QWidget *parent, const char *name, ...) :
 CQRadioButtons(parent)
{
  va_list vargs;

  va_start(vargs, name);

  std::vector<QString> names;

  while (name != 0) {
    names.push_back(name);

    name = va_arg(vargs, char *);
  }

  va_end(vargs);

  addButtons(names);
}

CQVRadioButtons::
CQVRadioButtons(QWidget *parent) :
 CQRadioButtons(parent)
{
}

QLayout *
CQVRadioButtons::
createLayout(QWidget *parent)
{
  QVBoxLayout *l = new QVBoxLayout(parent);
  l->setMargin(0); l->setSpacing(0);

  return l;
}

void
CQVRadioButtons::
addWidget(QWidget *widget)
{
  QVBoxLayout *l = qobject_cast<QVBoxLayout *>(layout());

  l->addWidget(widget);
}

//-----------

CQToolbarRadioButtons::
CQToolbarRadioButtons(QWidget *parent, const char *title, const char *name, ...) :
 CQRadioButtons(parent), title_(title)
{
  va_list vargs;

  va_start(vargs, name);

  std::vector<QString> names;

  while (name != 0) {
    names.push_back(name);

    name = va_arg(vargs, char *);
  }

  va_end(vargs);

  addButtons(names);
}

CQToolbarRadioButtons::
CQToolbarRadioButtons(QWidget *parent, const char *title) :
 CQRadioButtons(parent), title_(title)
{
}

QLayout *
CQToolbarRadioButtons::
createLayout(QWidget *parent)
{
  QGridLayout *l = new QGridLayout(parent);
  l->setMargin(0); l->setSpacing(0);

  return l;
}

void
CQToolbarRadioButtons::
addWidget(QWidget *widget)
{
  QGridLayout *l = qobject_cast<QGridLayout *>(layout());

  if (buttons_.empty()) {
    QLabel *titleLabel = new QLabel("<small><b>" + title_ + "</b></mode>");

    l->addWidget(titleLabel, 0, 0);
  }

  int pos = buttons_.size();

  l->addWidget(widget, 1, pos);
}

//-----------

CQRadioButtons::
CQRadioButtons(QWidget *parent) :
 QWidget(parent), hasLayout_(false)
{
}

CQRadioButtons::
~CQRadioButtons()
{
}

void
CQRadioButtons::
addButtons(const std::vector<QString> &names)
{
  std::vector<QString>::const_iterator p1, p2;

  for (p1 = names.begin(), p2 = names.end() ; p1 != p2; ++p1)
    addButton(*p1);

  qobject_cast<QBoxLayout *>(layout())->addStretch();
}

void
CQRadioButtons::
addButton(const QString &name)
{
  if (! hasLayout_) {
    (void) createLayout(this);

    hasLayout_ = true;
  }

  QRadioButton *button = new QRadioButton(name);

  addWidget(button);

  if (buttons_.empty())
    button->setChecked(true);

  buttons_.push_back(button);

  connect(button, SIGNAL(toggled(bool)), this, SLOT(valueChangedI(bool)));
}

QLayout *
CQRadioButtons::
createLayout(QWidget *parent)
{
  QHBoxLayout *l = new QHBoxLayout(parent);
  l->setMargin(0); l->setSpacing(0);

  return l;
}

void
CQRadioButtons::
addWidget(QWidget *widget)
{
  QHBoxLayout *l = qobject_cast<QHBoxLayout *>(layout());

  l->addWidget(widget);
}

void
CQRadioButtons::
valueChangedI(bool value)
{
  if (! value) return;

  int id = getCurrentValue();

  emit valueChanged(id);

  emit valueChanged(buttons_[id]->text());
}

int
CQRadioButtons::
getCurrentValue() const
{
  std::vector<QRadioButton *>::const_iterator p1 = buttons_.begin();
  std::vector<QRadioButton *>::const_iterator p2 = buttons_.end  ();

  for (int i = 0; p1 != p2; ++p1, ++i)
    if ((*p1)->isChecked())
      return i;

  return -1;
}

QString
CQRadioButtons::
getCurrentName() const
{
  std::vector<QRadioButton *>::const_iterator p1 = buttons_.begin();
  std::vector<QRadioButton *>::const_iterator p2 = buttons_.end  ();

  for (int i = 0; p1 != p2; ++p1, ++i)
    if ((*p1)->isChecked())
      return (*p1)->text();

  return "";
}
##concat##CQRealEdit.cpp
#include <CQRealEdit.h>
#include <CStrUtil.h>

#include <QMenu>
#include <QHBoxLayout>
#include <QDoubleValidator>
#include <QContextMenuEvent>
#include <cmath>

CQRealEdit::
CQRealEdit(QWidget *parent, double value) :
 QLineEdit(parent), menu_(0)
{
  init("edit", value);
}

CQRealEdit::
CQRealEdit(double value) :
 QLineEdit(0), menu_(0)
{
  init("edit", value);
}

void
CQRealEdit::
init(const QString &name, double value)
{
  if (name.length()) setObjectName(name);

  validator_ = new QDoubleValidator(this);

  setValidator(validator_);

  //setMinimumSize(QSize(60,0));
  //setMaximumSize(QSize(60,22));

  //setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);

  connect(this, SIGNAL(editingFinished()), this, SLOT(editingFinishedI()));

  setValue(value);
}

void
CQRealEdit::
addMenuValue(double value)
{
  if (menu_ == 0) {
    menu_ = new QMenu;

    connect(menu_, SIGNAL(triggered(QAction *)), this, SLOT(menuItemActivated(QAction *)));
  }

  CQRealEditAction *action = new CQRealEditAction(value);

  menu_->addAction(action);
}

void
CQRealEdit::
setValue(double value)
{
  value_ = value;

  valueToWidget();
}

double
CQRealEdit::
getValue() const
{
  return value_;
}

void
CQRealEdit::
setRange(double lower, double upper, int decimals)
{
  validator_->setRange(lower, upper, decimals);
}

void
CQRealEdit::
editingFinishedI()
{
  if (widgetToValue())
    emit valueChanged(value_);
}

void
CQRealEdit::
valueToWidget()
{
  setText(CStrUtil::toString(value_).c_str());
}

bool
CQRealEdit::
widgetToValue()
{
  double value = CStrUtil::toReal(text().toStdString());

  bool changed = (fabs(value - value_) > 1E-6);

  value_ = value;

  return changed;
}

void
CQRealEdit::
contextMenuEvent(QContextMenuEvent *e)
{
  if (menu_)
    menu_->exec(e->globalPos());
}

void
CQRealEdit::
menuItemActivated(QAction *action)
{
  CQRealEditAction *raction = dynamic_cast<CQRealEditAction *>(action);
  if (! raction) return;

  double value = raction->getValue();

  bool changed = (fabs(value - value_) > 1E-6);

  setValue(value);

  if (changed)
    emit valueChanged(value_);
}

//------

CQRealEditAction::
CQRealEditAction(double value) :
 QAction(QString("%1").arg(value), 0), value_(value)
{
}
##concat##CQScrollArea.cpp
#include <CQScrollArea.h>

#include <QGridLayout>
#include <QScrollBar>

CQScrollArea::
CQScrollArea(QWidget *widget) :
 QWidget  (0),
 widget_  (widget),
 x_size_  (-1),
 y_size_  (-1),
 x_offset_(0),
 y_offset_(0)
{
  QGridLayout *grid = new QGridLayout(this);
  grid->setMargin(0); grid->setSpacing(0);

  hbar_ = new QScrollBar(Qt::Horizontal);
  vbar_ = new QScrollBar(Qt::Vertical  );

  grid->addWidget(widget_, 0, 0);
  grid->addWidget(hbar_  , 1, 0);
  grid->addWidget(vbar_  , 0, 1);

  QObject::connect(hbar_, SIGNAL(valueChanged(int)), this, SLOT(hscrollSlot(int)));
  QObject::connect(vbar_, SIGNAL(valueChanged(int)), this, SLOT(vscrollSlot(int)));
}

void
CQScrollArea::
showHBar(bool flag)
{
  flag ? hbar_->show() : hbar_->hide();
}

void
CQScrollArea::
showVBar(bool flag)
{
  flag ? vbar_->show() : vbar_->hide();
}

void
CQScrollArea::
setCornerWidget(QWidget *w)
{
  QGridLayout *grid = qobject_cast<QGridLayout *>(layout());

  grid->addWidget(w, 1, 1);
}

void
CQScrollArea::
setXSize(int x_size)
{
  x_size_ = x_size;

  updateScrollbars();
}

void
CQScrollArea::
setYSize(int y_size)
{
  y_size_ = y_size;

  updateScrollbars();
}

void
CQScrollArea::
setXOffset(int x_offset)
{
  x_offset_ = x_offset;

  updateScrollbars();
}

void
CQScrollArea::
setYOffset(int y_offset)
{
  y_offset_ = y_offset;

  updateScrollbars();
}

void
CQScrollArea::
setXPageStep(int x)
{
  hbar_->setPageStep(x);
}

void
CQScrollArea::
setYPageStep(int y)
{
  vbar_->setPageStep(y);
}

void
CQScrollArea::
scrollUp(bool page)
{
  vbar_->triggerAction(page ? QAbstractSlider::SliderPageStepSub :
                              QAbstractSlider::SliderSingleStepSub);
}

void
CQScrollArea::
scrollDown(bool page)
{
  vbar_->triggerAction(page ? QAbstractSlider::SliderPageStepAdd :
                              QAbstractSlider::SliderSingleStepAdd);
}

void
CQScrollArea::
scrollLeft(bool page)
{
  hbar_->triggerAction(page ? QAbstractSlider::SliderPageStepSub :
                              QAbstractSlider::SliderSingleStepSub);
}

void
CQScrollArea::
scrollRight(bool page)
{
  hbar_->triggerAction(page ? QAbstractSlider::SliderPageStepAdd :
                              QAbstractSlider::SliderSingleStepAdd);
}

void
CQScrollArea::
ensureVisible(int x, int y, int xmargin, int ymargin)
{
  int xmin = -getXOffset();
  int xmax = xmin + width();
  int ymin = -getYOffset();
  int ymax = ymin + height();

  if      (y < ymin)
    setYOffset(-y + ymargin);
  else if (y > ymax)
    setYOffset(-y + height() - ymargin);

  if      (x < xmin)
    setXOffset(-x + xmargin);
  else if (x > xmax)
    setXOffset(-x + width() - xmargin);
}

void
CQScrollArea::
updateScrollbars()
{
  int w = widget_->width ();
  int h = widget_->height();

  int dx = std::max(0, getXSize() - w);
  int dy = std::max(0, getYSize() - h);

  hbar_->setPageStep(w);

  hbar_->setMinimum(0);
  hbar_->setMaximum(dx);

  hbar_->setValue(-getXOffset());

  vbar_->setPageStep(h);

  vbar_->setMinimum(0);
  vbar_->setMaximum(dy);

  vbar_->setValue(-getYOffset());
}

void
CQScrollArea::
hscrollSlot(int value)
{
  setXOffset(-value);

  emit updateArea();
}

void
CQScrollArea::
vscrollSlot(int value)
{
  setYOffset(-value);

  emit updateArea();
}
##concat##CQStrokeOption.cpp
#include <CQStrokeOption.h>
#include <CQIllustrator.h>

#include <CQColorChooser.h>
#include <CQLineDash.h>
#include <CQLineCap.h>
#include <CQLineJoin.h>
#include <CQUtil.h>

#include <QVBoxLayout>
#include <QGridLayout>
#include <QLabel>
#include <QDoubleSpinBox>
#include <QPushButton>
#include <QPainter>

class CQStrokeOptionSwab : public QWidget {
 public:
  CQStrokeOptionSwab(CQStrokeOptionDialog *dialog);

 private:
  void paintEvent(QPaintEvent *e);

 private:
  CQStrokeOptionDialog *dialog_;
  int                   tw_, th_, fw_;
};

//----------

CQStrokeOptionTool::
CQStrokeOptionTool(CQIllustrator *illustrator) :
 CQOptionTool(), illustrator_(illustrator), dialog_(0)
{
  dialog_ = new CQStrokeOptionDialog(this);

  QVBoxLayout *layout = new QVBoxLayout(this);
  layout->setMargin(0); layout->setSpacing(0);

  QLabel *label = new QLabel("<small><b>Stroke</b></small>");

  layout->addWidget(label);

  swab_ = new CQStrokeOptionSwab(dialog_);

  layout->addWidget(swab_);

  connect(dialog_, SIGNAL(valueChanged(const CQIllustratorShapeStroke &)),
          this, SIGNAL(valueChanged(const CQIllustratorShapeStroke &)));

  connect(illustrator_, SIGNAL(selectionChanged()),
          this, SLOT(selectionChangedSlot()));
}

CQOptionToolDialog *
CQStrokeOptionTool::
getDialog()
{
  return dialog_;
}

void
CQStrokeOptionTool::
selectionChangedSlot()
{
  const CQIllustratorShape *shape = 0;

  const CQIllustratorSelectedShapes *selection = illustrator_->getSelection();

  uint num_selected = selection->size();

  if (num_selected == 1) {
    const CQIllustratorSelectedShape &sshape = selection->front();

    shape = sshape.getShape();
  }

  CQIllustratorShapeStroke stroke;

  if (shape)
    stroke = shape->getStroke();
  else
    stroke = illustrator_->getDefaultStroke();

  dialog_->setStroke(stroke);

  swab_->update();
}

//----------

CQStrokeOptionSwab::
CQStrokeOptionSwab(CQStrokeOptionDialog *dialog) :
 dialog_(dialog)
{
  QFontMetrics fm(font());

  tw_ = fm.width("XX.XX");
  th_ = fm.ascent() + fm.descent();
  fw_ = 32;

  setFixedSize(tw_ + fw_ + 6, th_ + 4);
}

void
CQStrokeOptionSwab::
paintEvent(QPaintEvent *)
{
  QPainter painter(this);

  const CQIllustratorShapeStroke &stroke = dialog_->getStroke();

  QString wstr = QString("%1").arg(stroke.getWidth());

  QFontMetrics fm(font());

  //int w = fm.width(wstr);

  int x1 = 2;
  int x2 = x1 + fw_;
  int x3 = x2 + 2;

  int y1 = 2;
  int y2 = y1 + th_;

  painter.eraseRect(rect());

  painter.setPen(QColor(0,0,0));

  painter.drawText(QRect(x3, y1, tw_, y2 - y1), wstr);

  painter.setBrush(CQUtil::rgbaToColor(stroke.getColor()));

  painter.drawRect(QRect(x1, y1, x2 - x1, y2 - y1));
}

//----------

CQStrokeOptionDialog::
CQStrokeOptionDialog(CQStrokeOptionTool *tool) :
 CQOptionToolDialog(), tool_(tool), colorChooser_(0)
{
  initWidgets();
}

void
CQStrokeOptionDialog::
setStroke(const CQIllustratorShapeStroke &stroke)
{
  stroke_ = stroke;

  updateWidgets();
}

void
CQStrokeOptionDialog::
initWidgets()
{
  QVBoxLayout *layout = new QVBoxLayout(this);

  QGridLayout *gridLayout = new QGridLayout;

  gridLayout->addWidget(new QLabel("Color"      ), 0, 0);
  gridLayout->addWidget(new QLabel("Width"      ), 1, 0);
  gridLayout->addWidget(new QLabel("Opacity"    ), 2, 0);
  gridLayout->addWidget(new QLabel("Dash"       ), 3, 0);
  gridLayout->addWidget(new QLabel("Line Cap"   ), 4, 0);
  gridLayout->addWidget(new QLabel("Line Join"  ), 5, 0);
  gridLayout->addWidget(new QLabel("Mitre Limit"), 6, 0);

  colorChooser_ = new CQColorChooser;
  widthEdit_    = new QDoubleSpinBox;
  opacityEdit_  = new QDoubleSpinBox;
  dashEdit_     = new CQLineDash;
  capEdit_      = new CQLineCap;
  joinEdit_     = new CQLineJoin;
  mitreEdit_    = new QDoubleSpinBox;

  widthEdit_->setRange(0.01, 1000);
  widthEdit_->setSingleStep(1.0);
  widthEdit_->setDecimals(3);
//widthEdit_->setValidator(new QDoubleValidator(0.01, 1000.0, 3, widthEdit_));

  opacityEdit_->setRange(0.0, 1.0);
  opacityEdit_->setSingleStep(0.1);
  opacityEdit_->setDecimals(5);
//opacityEdit_->setValidator(new QDoubleValidator(0.00,    1.0, 5, opacityEdit_));

  mitreEdit_->setRange(0.01, 100.0);
  mitreEdit_->setSingleStep(1.0);
  mitreEdit_->setDecimals(3);
//mitreEdit_->setValidator(new QDoubleValidator(0.01,  100.0, 3, mitreEdit_));

  colorChooser_->setStyles(CQColorChooser::ColorButton);

  connect(colorChooser_, SIGNAL(colorChanged(const QColor &)),
          this, SLOT(colorSlot(const QColor &)));
  connect(widthEdit_   , SIGNAL(valueChanged(double)),
          this, SLOT(widthSlot(double)));
  connect(opacityEdit_ , SIGNAL(valueChanged(double)),
          this, SLOT(opacitySlot(double)));
  connect(dashEdit_    , SIGNAL(valueChanged(const CLineDash &)),
          this, SLOT(dashSlot(const CLineDash &)));
  connect(capEdit_     , SIGNAL(valueChanged(CLineCapType)),
          this, SLOT(capSlot(CLineCapType)));
  connect(joinEdit_    , SIGNAL(valueChanged(CLineJoinType)),
          this, SLOT(joinSlot(CLineJoinType)));
  connect(mitreEdit_   , SIGNAL(valueChanged(double)),
          this, SLOT(mitreSlot(double)));

  gridLayout->addWidget(colorChooser_, 0, 1);
  gridLayout->addWidget(widthEdit_   , 1, 1);
  gridLayout->addWidget(opacityEdit_ , 2, 1);
  gridLayout->addWidget(dashEdit_    , 3, 1);
  gridLayout->addWidget(capEdit_     , 4, 1);
  gridLayout->addWidget(joinEdit_    , 5, 1);
  gridLayout->addWidget(mitreEdit_   , 6, 1);

  layout->addLayout(gridLayout);

  //------

  QPushButton *defButton = new QPushButton("Set Default");

  connect(defButton, SIGNAL(clicked()), this, SLOT(setDefaultSlot()));

  layout->addWidget(defButton);
}

void
CQStrokeOptionDialog::
updateWidgets()
{
  colorChooser_->setColor   (CQUtil::rgbaToColor(stroke_.getColor()));
  widthEdit_   ->setValue   (stroke_.getWidth());
  opacityEdit_ ->setValue   (stroke_.getOpacity());
  dashEdit_    ->setLineDash(stroke_.getLineDash());
  capEdit_     ->setLineCap (stroke_.getLineCap());
  joinEdit_    ->setLineJoin(stroke_.getLineJoin());
  mitreEdit_   ->setValue   (stroke_.getMitreLimit());
}

void
CQStrokeOptionDialog::
colorSlot(const QColor &color)
{
  CRGBA rgba = CQUtil::colorToRGBA(color);

  if (rgba == stroke_.getColor())
    return;

  stroke_.setColor(rgba);

  tool_->update();

  emit valueChanged(stroke_);
}

void
CQStrokeOptionDialog::
widthSlot(double new_width)
{
  if (new_width == stroke_.getWidth())
    return;

  stroke_.setWidth(new_width);

  tool_->update();

  emit valueChanged(stroke_);
}

void
CQStrokeOptionDialog::
opacitySlot(double new_opacity)
{
  if (new_opacity == stroke_.getOpacity())
    return;

  stroke_.setOpacity(new_opacity);

  tool_->update();

  emit valueChanged(stroke_);
}

void
CQStrokeOptionDialog::
dashSlot(const CLineDash &dash)
{
  if (dash == stroke_.getLineDash())
    return;

  stroke_.setLineDash(dash);

  emit valueChanged(stroke_);
}

void
CQStrokeOptionDialog::
capSlot(CLineCapType cap)
{
  if (cap == stroke_.getLineCap())
    return;

  stroke_.setLineCap(cap);

  emit valueChanged(stroke_);
}

void
CQStrokeOptionDialog::
joinSlot(CLineJoinType join)
{
  if (join == stroke_.getLineJoin())
    return;

  stroke_.setLineJoin(join);

  emit valueChanged(stroke_);
}

void
CQStrokeOptionDialog::
mitreSlot(double new_mitre_limit)
{
  if (new_mitre_limit == stroke_.getMitreLimit())
    return;

  stroke_.setMitreLimit(new_mitre_limit);

  tool_->update();

  emit valueChanged(stroke_);
}

void
CQStrokeOptionDialog::
setDefaultSlot()
{
  tool_->getIllustrator()->setDefaultStroke(stroke_);
}
##concat##CQSwatch.cpp
#include <CQSwatch.h>
#include <QGridLayout>
#include <QFrame>
#include <QLabel>

CQSwatch::
CQSwatch() :
 QWidget(0)
{
  init();
}

CQSwatch::
CQSwatch(QWidget *widget) :
 QWidget(0)
{
  init();

  addWidget(widget);
  addSeparator();
}

CQSwatch::
CQSwatch(const char *title, QWidget *w) :
 QWidget(0)
{
  init();

  setTitle(title);

  addWidget(w);
  addSeparator();
}

CQSwatch::
CQSwatch(const char *title, QWidget *w1, QWidget *w2) :
 QWidget(0)
{
  init();

  setTitle(title);

  addWidget(w1);
  addWidget(w2);
  addSeparator();
}

CQSwatch::
CQSwatch(const char *title, QWidget *w1, QWidget *w2, QWidget *w3) :
 QWidget(0)
{
  init();

  setTitle(title);

  addWidget(w1);
  addWidget(w2);
  addWidget(w3);
  addSeparator();
}

CQSwatch::
CQSwatch(const char *title, QWidget *w1, QWidget *w2, QWidget *w3, QWidget *w4) :
 QWidget(0)
{
  init();

  setTitle(title);

  addWidget(w1);
  addWidget(w2);
  addWidget(w3);
  addWidget(w4);
  addSeparator();
}

void
CQSwatch::
init()
{
  pos_ = 0;

  has_title_ = false;

  grid_ = new QGridLayout(this);

  grid_->setMargin(0); grid_->setSpacing(1);
}

void
CQSwatch::
setTitle(const char *title)
{
  int rows = 1;
  int cols = 1;

  QString title1 = title;

  int len = title1.length();

  if (len > 3 && title1[len - 3] == '<' && title1[len - 2].isDigit() && title1[len - 1] == '>') {
    cols = title1[len - 2].toLatin1() - '0';

    title1 = title1.mid(0, len - 3);
  }

  QLabel *label = new QLabel("<small><b>" + title1 + "</b></small>");

  grid_->addWidget(label, 0, 0, rows, cols);

  has_title_ = true;
}

void
CQSwatch::
addWidget(QWidget *w)
{
  int row = (has_title_ ? 1 : 0);

  grid_->addWidget(w, row, pos_++);
}

void
CQSwatch::
addWidget(QWidget *w, int rows, int cols)
{
  int row = (has_title_ ? 1 : 0);

  grid_->addWidget(w, row, pos_++, rows, cols);
}

void
CQSwatch::
addSeparator()
{
  QFrame *frame = new QFrame;

  frame->setFrameShadow(QFrame::Raised);
  frame->setFrameShape (QFrame::VLine);

  grid_->addWidget(frame, 0, pos_++, 2, 1);
}
##concat##CQTableWidget.cpp
#include <CQTableWidget.h>

#include <QTableWidget>
#include <QTableWidgetItem>
#include <QItemDelegate>
#include <QHeaderView>
#include <QStringList>
#include <QFont>
#include <QFontMetrics>
#include <QPainter>
#include <QAbstractItemView>

//----------------------------

class CQTableWidgetDelegate : public QItemDelegate {
 public:
  CQTableWidgetDelegate(CQTableWidget *t) :
   QItemDelegate(t), t_(t) {
  }

  // Override to create editor
  QWidget *createEditor(QWidget *parent, const QStyleOptionViewItem &option,
                        const QModelIndex &index) const;

  // Override to get content from editor
  void setEditorData(QWidget *editor, const QModelIndex &index) const;

  // Override to set editor from content
  void setModelData(QWidget *editor, QAbstractItemModel *model, const QModelIndex &index) const;

  QSize sizeHint(const QStyleOptionViewItem &option, const QModelIndex &index) const;

  void updateEditorGeometry(QWidget *editor, const QStyleOptionViewItem &option,
                            const QModelIndex &index) const;

  void paint(QPainter *painter, const QStyleOptionViewItem &option,
             const QModelIndex &index) const;

 private:
  CQTableWidget *t_;
};

//----------------------------

uint CQTableWidgetItem::type_ = 0;

//----------------------------

CQTableWidget::
CQTableWidget(QWidget* parent) :
 QTableWidget(parent)
{
  verticalHeader()->hide();

  // Set Item Delegate
  CQTableWidgetDelegate *delegate = new CQTableWidgetDelegate(this);

  setItemDelegate(delegate);
  setEditTriggers(QAbstractItemView::AllEditTriggers);

  setSelectionMode(QAbstractItemView::SingleSelection);
  setSelectionBehavior(QAbstractItemView::SelectRows);

  // Set the value column to stretch to fit the table and other table attributes.
  QHeaderView *header = horizontalHeader();

  header->setStretchLastSection(true) ;

  setEditTriggers(QAbstractItemView::DoubleClicked | QAbstractItemView::EditKeyPressed);

  //setSortingEnabled(false);

  //setRowMovingEnabled(false);
  //setColumnMovingEnabled(false);
}

CQTableWidget::
~CQTableWidget()
{
}

void
CQTableWidget::
registerType(uint type, CQTableWidgetItem *item)
{
  assert(type > QTableWidgetItem::UserType);

  item->setType(type);

  types_[type] = item;
}

void
CQTableWidget::
setColumnLabel(int col, const QString &label)
{
  QTableWidgetItem *item = horizontalHeaderItem(col);

  if (! item) {
    item = new QTableWidgetItem;

    setHorizontalHeaderItem(col, item);
  }

  item->setText(label);
}

void
CQTableWidget::
setRowLabel(int row, const QString &label)
{
  verticalHeader()->show();

  QTableWidgetItem *item = verticalHeaderItem(row);

  if (! item) {
    item = new QTableWidgetItem;

    setVerticalHeaderItem(row, item);
  }

  item->setText(label);
}

void
CQTableWidget::
setColumnLabels(const QStringList &labels)
{
  setHorizontalHeaderLabels(labels);
}

void
CQTableWidget::
setRowLabels(const QStringList &labels)
{
  verticalHeader()->show();

  setVerticalHeaderLabels(labels);
}

CQTableWidgetItem *
CQTableWidget::
createItem(int row, int column, uint type)
{
  assert(types_.find(type) != types_.end());

  CQTableWidgetItem *item = types_[type]->clone();

  QTableWidget::setItem(row, column, item);

  return item;
}

void
CQTableWidget::
setItem(int row, int column, CQTableWidgetItem *item)
{
  QTableWidget::setItem(row, column, item);

  QModelIndex index = model()->index(row, column);

  model()->setData(index, item->getString());
}

void
CQTableWidget::
setItem(int row, int column, const QString &str)
{
  QTableWidgetItem *item = new QTableWidgetItem(str);

  item->setFlags(item->flags() & !Qt::ItemIsEditable);

  QTableWidget::setItem(row, column, item);
}

void
CQTableWidget::
setItem(int row, int column, QWidget *w)
{
  QTableWidget::setCellWidget(row, column, w);
}

void
CQTableWidget::
showEvent(QShowEvent *)
{
  resizeColumnsToContents();

  //fixTableColumnWidths(this, 16, true);
}

void
CQTableWidget::
fixTableColumnWidths()
{
  resizeColumnsToContents();

  //fixTableColumnWidths(this, 16, false);
}

void
CQTableWidget::
fixTableColumnWidths(QTableWidget *table, int max_len, bool init)
{
  const QFont &font = table->font();

  QFontMetrics fm(font);

  int num_cols = table->columnCount();

  for (int c = 0; c < num_cols - 1; ++c) {
    if (table->isColumnHidden(c)) continue;

    int width = (init ? 0 : table->columnWidth(c));

    if (table->horizontalHeader()->isVisible()) {
      QTableWidgetItem *item = table->horizontalHeaderItem(c);

      if (item) {
        QVariant var = item->data(Qt::DisplayRole);

        QString str = var.toString();

        if (str.length() <= max_len)
          width = qMax(width, fm.width(str) + 10);
      }
    }

    int num_rows = table->rowCount();

    for (int r = 0; r < num_rows; ++r) {
      QTableWidgetItem *item = table->item(r, c);

      if (item) {
        QVariant var = item->data(Qt::DisplayRole);

        QString str = var.toString();

        if (str.length() <= max_len)
          width = qMax(width, fm.width(str) + 28);

        QWidget *w = table->cellWidget(r, c);

        if (w)
          width = qMax(width, w->width());
      }
    }

    table->setColumnWidth(c, qMax(24, width));
  }
}

void
CQTableWidget::
emitValueChanged(int row, int col)
{
  emit valueChanged(row, col);
}

//----------------------------

QWidget *
CQTableWidgetDelegate::
createEditor(QWidget *parent, const QStyleOptionViewItem &option, const QModelIndex &index) const
{
  QTableWidgetItem *item = t_->item(index.row(), index.column());

  CQTableWidgetItem *item1 = dynamic_cast<CQTableWidgetItem *>(item);

  if (item1) {
    QWidget *w = item1->createEditor(parent);

    if (w)
      w->installEventFilter(const_cast<CQTableWidgetDelegate*>(this));

    return w;
  }
  else
    return QItemDelegate::createEditor(parent, option, index);
}

void
CQTableWidgetDelegate::
setEditorData(QWidget *, const QModelIndex &index) const
{
  QTableWidgetItem *item = t_->item(index.row(), index.column());

  CQTableWidgetItem *item1 = dynamic_cast<CQTableWidgetItem *>(item);

  if (item1)
    item1->setEditorData();
}

void
CQTableWidgetDelegate::
setModelData(QWidget *, QAbstractItemModel *model, const QModelIndex &index) const
{
  QTableWidgetItem *item = t_->item(index.row(), index.column());

  CQTableWidgetItem *item1 = dynamic_cast<CQTableWidgetItem *>(item);

  if (item1) {
    QString str;

    item1->getEditorData(str);

    model->setData(index, str);

    t_->emitValueChanged(index.row(), index.column());
  }
}

QSize
CQTableWidgetDelegate::
sizeHint(const QStyleOptionViewItem &option, const QModelIndex &index) const
{
  QTableWidgetItem *item = t_->item(index.row(), index.column());

  CQTableWidgetItem *item1 = dynamic_cast<CQTableWidgetItem *>(item);

  if (item1) {
    QSize size;

    if (item1->sizeHint(option, size))
      return size;
  }

  return QItemDelegate::sizeHint(option, index);
}

void
CQTableWidgetDelegate::
updateEditorGeometry(QWidget *editor, const QStyleOptionViewItem &option,
                     const QModelIndex &/* index */) const
{
  editor->setGeometry(option.rect);
}

void
CQTableWidgetDelegate::
paint(QPainter *painter, const QStyleOptionViewItem &option, const QModelIndex &index) const
{
  QTableWidgetItem *item = t_->item(index.row(), index.column());

  CQTableWidgetItem *item1 = dynamic_cast<CQTableWidgetItem *>(item);

  if (! item1 || ! item1->paint(painter, option))
    QItemDelegate::paint(painter, option, index);
}

//------------------------------

CQTableWidgetItem::
CQTableWidgetItem(CQTableWidget *t) :
 t_(t)
{
}

void
CQTableWidgetItem::
paintBackground(QPainter *painter, const QStyleOptionViewItem &option) const
{
  if (option.state & QStyle::State_Selected) {
    QPalette::ColorGroup cg =
     (option.state & QStyle::State_Enabled ? QPalette::Normal : QPalette::Disabled);

    painter->fillRect(option.rect, option.palette.brush(cg, QPalette::Highlight));
  }
}

void
CQTableWidgetItem::
setTextPen(QPainter *painter, const QStyleOptionViewItem &option) const
{
  QPalette::ColorGroup cg =
   (option.state & QStyle::State_Enabled ? QPalette::Normal : QPalette::Disabled);

  if (option.state & QStyle::State_Selected)
    painter->setPen(option.palette.color(cg, QPalette::HighlightedText));
  else
    painter->setPen(option.palette.color(cg, QPalette::Text));
}

//------------------------------

#if 0
CQObjEditStdItem::
CQObjEditStdItem(const QString &label) :
 CQTableWidgetItem(CQOBJ_EDIT_STD_ITEM_ID)
{
  setText(label);

  setFlags(flags() | Qt::ItemIsEditable);
}

CQObjEditStdItem::
CQObjEditStdItem(const CQObjEditStdItem &item) :
 QTreeWidgetItem(item)
{
  for (int i = 0; i < item.childCount(); ++i)
    setText(i, item.text(i));

  setFlags(flags() | Qt::ItemIsEditable);
}

bool
CQObjEditStdItem::
paint(QPainter *, const QStyleOptionViewItem &, const QModelIndex &) const
{
  return false;
}
#endif
##concat##CQWinWidget.cpp
#include <CQWinWidget.h>
#include <CQDrawUtil.h>

#include <QImage>
#include <QMenu>
#include <QPaintEvent>
#include <QMouseEvent>
#include <QPainter>
#include <QBrush>
#include <QBitmap>
#include <QStyleOption>
#include <QFileDialog>

#include <cursors/select.xbm>
#include <cursors/selectmask.xbm>

CQWinWidget::
CQWinWidget(QWidget *parent, const char *name) :
 QWidget        (parent),
 child_         (0),
 active_        (false),
 pressed_       (false),
 decoration_    (HeaderBorderDecoration, SideTop, 10, 1, QColor(80,80,100)),
 closeButton_   (style()->standardIcon(QStyle::SP_TitleBarCloseButton)),
 expandButton_  (style()->standardIcon(QStyle::SP_TitleBarShadeButton)),
 collapseButton_(style()->standardIcon(QStyle::SP_TitleBarUnshadeButton)),
 ops_           (MoveOp | ResizeOp | RaiseOp | LowerOp | CloseOp),
 edit_mode_     (EDIT_MODE_DRAG),
 constraint_    (NO_CONSTRAINT)
{
  setObjectName(name);

  setMouseTracking(true);

  setAutoFillBackground(true);
}

void
CQWinWidget::
setChild(QWidget *child)
{
  if (child_)
    child_->setParent(0);

  child_ = child;

  child_->setParent(this);

  child_->show();

  if (ops_ & ResizeOp)
    resizeEvent(0);
  else
    fitChild();
}

void
CQWinWidget::
fitChild()
{
  setChildSize(child_->sizeHint());
}

void
CQWinWidget::
setChildSize(const QSize &size)
{
  int w = size.width ();
  int h = size.height();

  if (w <= 0) w = 100;
  if (h <= 0) h = 100;

  int b = getBorder();

  w += 2*b;
  h += 2*b;

  if (decoration_.type & HeaderDecoration) {
    int hh = getHeaderHeight();

    if (decoration_.header_side == SideTop || decoration_.header_side == SideBottom)
      h += hh;
    else
      w += hh;
  }

  resize(w, h);
}

int
CQWinWidget::
getX() const
{
  int x = getBorder();

  if (decoration_.type & HeaderDecoration) {
    if (decoration_.header_side == SideLeft)
      x += getHeaderHeight();
  }

  return x;
}

int
CQWinWidget::
getY() const
{
  int y = getBorder();

  if (decoration_.type & HeaderDecoration) {
    if (decoration_.header_side == SideTop)
      y += getHeaderHeight();
  }

  return y;
}

int
CQWinWidget::
getWidth() const
{
  int b = getBorder();

  int h = 0;

  if (decoration_.type & HeaderDecoration) {
    if (decoration_.header_side == SideLeft || decoration_.header_side == SideRight)
      h = getHeaderHeight();
  }

  return width() - 2*b - h;
}

int
CQWinWidget::
getHeight() const
{
  int b = getBorder();

  int h = 0;

  if (decoration_.type & HeaderDecoration) {
    if (decoration_.header_side == SideTop || decoration_.header_side == SideBottom)
      h = getHeaderHeight();
  }

  return height() - 2*b - h;
}

int
CQWinWidget::
getHeaderHeight() const
{
  QFontMetrics fm(font());

  int h = qMax(decoration_.header_height, fm.height() + 4);

  return h;
}

void
CQWinWidget::
setPos(int x, int y)
{
  move(x - getX(), y - getY());
}

void
CQWinWidget::
setSize(int w, int h)
{
  int b = getBorder();

  int hw = 0, hh = 0;

  if (decoration_.type & HeaderDecoration) {
    if (decoration_.header_side == SideLeft || decoration_.header_side == SideRight)
      hw = getHeaderHeight();

    if (decoration_.header_side == SideTop || decoration_.header_side == SideBottom)
      hh = getHeaderHeight();
  }

  resize(w + hw + 2*b, h + hh + 2*b);
}

bool
CQWinWidget::
checkMove(QPoint &p) const
{
  if (constraint_ == VISIBLE_CONSTRAINT) {
    QRect r(p, this->size());

    int pw = parentWidget()->width();
    int ph = parentWidget()->height();

    if (p.x()            < 0 ) p = QPoint(0, p.y());
    if (p.y()            < 0 ) p = QPoint(p.x(), 0);
    if (p.x() + width () > pw) p = QPoint(pw - width(), p.y());
    if (p.y() + height() > ph) p = QPoint(p.x(), ph - height());
  }

  return true;
}

bool
CQWinWidget::
checkGeometry(const QRect &rect) const
{
  if (constraint_ == VISIBLE_CONSTRAINT) {
    if (rect.x()                 < 0 ||
        rect.y()                 < 0 ||
        rect.x() + rect.width () > parentWidget()->width() ||
        rect.y() + rect.height() > parentWidget()->height())
     return false;
  }

  return true;
}

void
CQWinWidget::
paintEvent(QPaintEvent *)
{
  QPainter painter(this);

  // draw border
  int b = getBorder();

  qDrawPlainRect(&painter, 0, 0, width(), height(), decoration_.border_color, b);

  // draw header
  if (decoration_.type & HeaderDecoration) {
    QPalette pal = palette();

    int hh = getHeaderHeight();

    // draw background
    QBrush bgBrush = QBrush(pal.color(QPalette::Window));

    if      (decoration_.header_side == SideTop)
      decoration_.header_rect = QRect(b, b, width() - 2*b, hh);
    else if (decoration_.header_side == SideBottom)
      decoration_.header_rect = QRect(b, height() - b - hh, width() - 2*b, hh);
    else if (decoration_.header_side == SideLeft)
      decoration_.header_rect = QRect(b, b, hh, height() - 2*b);
    else if (decoration_.header_side == SideRight)
      decoration_.header_rect = QRect(width() - b - hh, b, hh, height() - 2*b);

    painter.fillRect(decoration_.header_rect, bgBrush);

    int b1 = hh - 4;

    closeButton_   .displayed = (ops_ & CloseOp );
    expandButton_  .displayed = (ops_ & ExpandOp);
    collapseButton_.displayed = (ops_ & CollapseOp);

    // draw title bar handle
    int panelSize = 3;
    int margin    = (decoration_.header_height - 2*panelSize - 1)/2;

    if (decoration_.header_side == SideTop || decoration_.header_side == SideBottom) {
      int x1 = width() - b + 2;

      int panelWidth = qMax(1, x1 - 2*b - 2*margin);

      if (closeButton_   .displayed) panelWidth -= b1 + 2;
      if (expandButton_  .displayed) panelWidth -= b1 + 2;
      if (collapseButton_.displayed) panelWidth -= b1 + 2;

      qDrawShadePanel(&painter, b + margin, b + margin                , panelWidth, panelSize, pal);
      qDrawShadePanel(&painter, b + margin, b + margin + 1 + panelSize, panelWidth, panelSize, pal);
    }
    else {
       int y1 = b + 2;

      int panelWidth = qMax(1, height() - y1 - 2*b - 2*margin);

      if (closeButton_   .displayed) panelWidth -= b1 + 2;
      if (expandButton_  .displayed) panelWidth -= b1 + 2;
      if (collapseButton_.displayed) panelWidth -= b1 + 2;

      qDrawShadePanel(&painter, b + margin                , b + margin, panelSize, panelWidth, pal);
      qDrawShadePanel(&painter, b + margin + 1 + panelSize, b + margin, panelSize, panelWidth, pal);
    }

    // draw title
    QString text = windowTitle();

    if (text.length()) {
      painter.setPen(pal.color(QPalette::WindowText));

      QFontMetrics fm(font());

      int tw = fm.width(text);

      painter.save();

      if (decoration_.header_side == SideTop || decoration_.header_side == SideBottom)
        painter.fillRect(QRect(b, b, tw + 4, hh), bgBrush);
      else {
        painter.fillRect(QRect(b, height() - tw - b - 4, hh, tw + 4), bgBrush);

        painter.translate(0, height());
        painter.rotate(-90);
      }

      int ym = b + hh/2;

      painter.drawText(b + 2, b + ym - fm.height()/2 + fm.ascent(), text);

      painter.restore();
    }

    // draw header buttons
    painter.setPen(decoration_.border_color);

    if (decoration_.header_side == SideTop || decoration_.header_side == SideBottom) {
      int x1 = width() - b + 2;
      int y1 = b + 2;

      drawHeaderButtonH(&painter, closeButton_   , x1, y1, b1);
      drawHeaderButtonH(&painter, expandButton_  , x1, y1, b1);
      drawHeaderButtonH(&painter, collapseButton_, x1, y1, b1);
    }
    else {
      int x1 = b - 2;
      int y1 = b + 2;

      drawHeaderButtonV(&painter, closeButton_   , x1, y1, b1);
      drawHeaderButtonV(&painter, expandButton_  , x1, y1, b1);
      drawHeaderButtonV(&painter, collapseButton_, x1, y1, b1);
    }
  }
}

void
CQWinWidget::
drawHeaderButtonH(QPainter *painter, HeaderButton &button, int &x1, int y1, int b1)
{
  if (! button.displayed) return;

  x1 -= b1 + 2;

  button.rect = QRect(x1, y1, b1, b1);

  button.draw(painter, this);
}

void
CQWinWidget::
drawHeaderButtonV(QPainter *painter, HeaderButton &button, int x1, int &y1, int b1)
{
  if (! button.displayed) return;

  y1 += b1 + 2;

  button.rect = QRect(x1, y1, b1, b1);

  button.draw(painter, this);
}

void
CQWinWidget::
moveEvent(QMoveEvent *)
{
  resizeEvent(0);
}

void
CQWinWidget::
resizeEvent(QResizeEvent *)
{
  int b = getBorder();

  int x = b;
  int y = b;
  int w = width () - 2*b;
  int h = height() - 2*b;

  if (decoration_.type & HeaderDecoration) {
    int hh = getHeaderHeight();

    if      (decoration_.header_side == SideTop)
      y += hh;
    else if (decoration_.header_side == SideLeft)
      x += hh;

    if (decoration_.header_side == SideTop || decoration_.header_side == SideBottom)
      h -= hh;
    else
      w -= hh;
  }

  if (child_) {
    child_->move  (x, y);
    child_->resize(w, h);

    emit geometryChanging();
  }
}

void
CQWinWidget::
mousePressEvent(QMouseEvent *event)
{
  pressed_ = true;

  if (edit_mode_ == EDIT_MODE_CLICK) {
    if (state_.moving || state_.resizing) {
      edit_mode_ = EDIT_MODE_DRAG;

      mouseReleaseEvent(event);

      releaseMouse();

      edit_mode_ = EDIT_MODE_CLICK;

      return;
    }
  }

  //-----

  state_.init_pos  = pos();
  state_.init_size = size();
  state_.press_pos = event->globalPos();

  if      (event->button() == Qt::LeftButton) {
    state_.moving   = false;
    state_.resizing = false;

    QPoint p = event->pos();

    if (decoration_.type & HeaderDecoration) {
      closeButton_   .updateActive(p, pressed_);
      expandButton_  .updateActive(p, pressed_);
      collapseButton_.updateActive(p, pressed_);

      update();
    }

    if (ops_ & MoveOp) {
      if (decoration_.type & HeaderDecoration) {
        if (decoration_.header_rect.contains(p)) {
          if (! closeButton_.active && ! expandButton_.active && ! collapseButton_.active)
            state_.moving = true;
        }
      }
      else
        state_.moving = true;
    }

    if ((ops_ & ResizeOp) && ! state_.moving) {
      int b = getBorder() + 2;

      state_.resize_l = (event->x() <= b);
      state_.resize_t = (event->y() <= b);
      state_.resize_r = (event->x() >= width () - b - 1);
      state_.resize_b = (event->y() >= height() - b - 1);

      if (state_.resize_l || state_.resize_t || state_.resize_r || state_.resize_b)
        state_.resizing = true;
    }

    if (ops_ & RaiseOp)
      raise();

    if (edit_mode_ == EDIT_MODE_CLICK)
      grabMouse();
  }
  else if (event->button() == Qt::MidButton) {
    state_.moving   = false;
    state_.resizing = false;

    if (ops_ & MoveOp)
      state_.moving = true;

    if (ops_ & RaiseOp)
      raise();

    if (edit_mode_ == EDIT_MODE_CLICK)
      grabMouse();
  }
}

void
CQWinWidget::
mouseMoveEvent(QMouseEvent *event)
{
  if      (state_.moving) {
    QPoint d = event->globalPos() - state_.press_pos;

    QPoint p = state_.init_pos + d;

    if (checkMove(p))
      move(p);
  }
  else if (state_.resizing) {
    int dx = 0; int dy = 0;
    int dw = 0; int dh = 0;

    if (state_.resize_l) {
      dx = event->globalPos().x() - state_.press_pos.x();
      dw = -dx;
    }

    if (state_.resize_r)
      dw = event->globalPos().x() - state_.press_pos.x();

    if (state_.resize_t) {
      dy = event->globalPos().y() - state_.press_pos.y();
      dh = -dy;
    }

    if (state_.resize_b)
      dh = event->globalPos().y() - state_.press_pos.y();

    move  (pos () + QPoint(dx, dy));
    resize(size() + QSize (dw, dh));

    state_.press_pos = event->globalPos();
  }

  //------

  setCursor(select_bits, selectmask_bits, 2, 2);

  QPoint p = event->pos();

  if (decoration_.type & HeaderDecoration) {
    bool insideClose    = closeButton_   .rect.contains(p);
    bool insideExpand   = expandButton_  .rect.contains(p);
    bool insideCollapse = collapseButton_.rect.contains(p);

    bool changed = (insideClose    != closeButton_   .active ||
                    insideExpand   != expandButton_  .active ||
                    insideCollapse != collapseButton_.active);

    closeButton_   .updateActive(p, pressed_);
    expandButton_  .updateActive(p, pressed_);
    collapseButton_.updateActive(p, pressed_);

    if (changed)
      update();
  }

  if (ops_ & MoveOp) {
    if (decoration_.type & HeaderDecoration) {
      if (decoration_.header_rect.contains(p)) {
        if (closeButton_.active || expandButton_.active || collapseButton_.active)
          setCursor(select_bits, selectmask_bits, 2, 2);
        else
          QWidget::setCursor(Qt::SizeAllCursor);
      }
    }
    else
      QWidget::setCursor(Qt::SizeAllCursor);
  }

  if (ops_ & ResizeOp) {
    int b = getBorder() + 2;

    bool resize_l = (event->x() <= b);
    bool resize_t = (event->y() <= b);
    bool resize_r = (event->x() >= width () - b - 1);
    bool resize_b = (event->y() >= height() - b - 1);

    if      (resize_l && resize_t) QWidget::setCursor(Qt::SizeFDiagCursor);
    else if (resize_l && resize_b) QWidget::setCursor(Qt::SizeBDiagCursor);
    else if (resize_r && resize_t) QWidget::setCursor(Qt::SizeBDiagCursor);
    else if (resize_r && resize_b) QWidget::setCursor(Qt::SizeFDiagCursor);
    else if (resize_l            ) QWidget::setCursor(Qt::SizeHorCursor);
    else if (resize_r            ) QWidget::setCursor(Qt::SizeHorCursor);
    else if (resize_t            ) QWidget::setCursor(Qt::SizeVerCursor);
    else if (resize_b            ) QWidget::setCursor(Qt::SizeVerCursor);
  }
}

void
CQWinWidget::
mouseReleaseEvent(QMouseEvent *event)
{
  pressed_ = false;

  if (edit_mode_ == EDIT_MODE_DRAG) {
    if (state_.moving || state_.resizing) {
      mouseMoveEvent(event);

      if (! checkGeometry(geometry())) {
        move  (state_.init_pos );
        resize(state_.init_size);
      }
      else {
        emit geometryChanged();
      }

      state_.moving   = false;
      state_.resizing = false;
    }
  }

  QPoint p = event->pos();

  if (decoration_.type & HeaderDecoration) {
    closeButton_   .updateActive(p, pressed_);
    expandButton_  .updateActive(p, pressed_);
    collapseButton_.updateActive(p, pressed_);

    update();

    if (closeButton_.active)
      closeSlot();

    if (expandButton_.active)
      expandSlot();

    if (collapseButton_.active)
      collapseSlot();
  }
}

void
CQWinWidget::
contextMenuEvent(QContextMenuEvent *event)
{
  emit showContextMenu(event->globalPos());
}

void
CQWinWidget::
enterEvent(QEvent *)
{
  active_ = true;

  update();
}

void
CQWinWidget::
leaveEvent(QEvent *)
{
  active_ = false;

  update();
}

int
CQWinWidget::
getBorder() const
{
  int b = (decoration_.type & BorderDecoration ? decoration_.border : 0);

  return b;
}

void
CQWinWidget::
closeSlot()
{
  emit closing();

  hide();

  emit closed();
}

void
CQWinWidget::
expandSlot()
{
  emit expand();
}

void
CQWinWidget::
collapseSlot()
{
  emit collapse();
}

void
CQWinWidget::
setCursor(const uchar *bits, const uchar *mask, int xo, int yo)
{
  QCursor cursor(QBitmap::fromData(QSize(16,16), bits),
                 QBitmap::fromData(QSize(16,16), mask),
                 xo, yo);

  QWidget::setCursor(cursor);
}

//------

void
CQWinWidget::HeaderButton::
draw(QPainter *painter, CQWinWidget *preview)
{
  QStyle *style = preview->style();

  QStyleOptionButton opt;

  opt.init(preview);

  opt.rect = rect;

  opt.state    |= QStyle::State_AutoRaise;
  opt.features |= QStyleOptionButton::Flat;

  if (! active || ! pressed)
    opt.state |= QStyle::State_Raised;

  if (active && pressed)
    opt.state |= QStyle::State_Sunken;

  style->drawPrimitive(QStyle::PE_PanelButtonTool, &opt, painter, preview);

  int shiftHorizontal = (opt.state & QStyle::State_Sunken ?
                         style->pixelMetric(QStyle::PM_ButtonShiftHorizontal, &opt, preview) : 0);
  int shiftVertical   = (opt.state & QStyle::State_Sunken ?
                         style->pixelMetric(QStyle::PM_ButtonShiftVertical  , &opt, preview) : 0);

  QRect r = rect;

  r.adjust(2, 2, -2, -2);

  r.translate(shiftHorizontal, shiftVertical);

  QPixmap pm = icon.pixmap(r.size(),
                           active  ? QIcon::Active : QIcon::Normal,
                           pressed ? QIcon::On     : QIcon::Off);

  style->drawItemPixmap(painter, r, Qt::AlignCenter, pm);
}

//---------------

CQWinWidgetBase::
CQWinWidgetBase(QWidget *parent)
{
  widget_ = new CQWinWidget(parent);
}

CQWinWidgetBase::
~CQWinWidgetBase()
{
}

void
CQWinWidgetBase::
setEditMode(CQWinWidget::EditMode edit_mode)
{
  widget_->setEditMode(edit_mode);
}

//---------------

CQWinTextEdit::
CQWinTextEdit(QWidget *parent, const char *name) :
 CQWinWidgetBase(parent)
{
  QTextEdit::setObjectName(name);

  widget_->setChild(this);

  connect(this, SIGNAL(textChanged()), this, SIGNAL(valueChanged()));

  connect(widget_, SIGNAL(geometryChanging()), this, SIGNAL(geometryChanging()));
  connect(widget_, SIGNAL(geometryChanged()), this, SIGNAL(geometryChanged()));
}

//---------------

CQWinImage::
CQWinImage(QWidget *parent, const char *name) :
 CQWinWidgetBase(parent)
{
  QLabel::setObjectName(name);

  widget_->setChild(this);

  widget_->setDecorationType(CQWinWidget::BorderDecoration);

  widget_->setResizable(false);

  connect(widget_, SIGNAL(geometryChanging()), this, SIGNAL(geometryChanging()));
  connect(widget_, SIGNAL(geometryChanged()), this, SIGNAL(geometryChanged()));

  //------

  menu_ = new QMenu;

  QAction *loadAction = menu_->addAction("Load Image");

  connect(loadAction, SIGNAL(triggered()), this, SLOT(loadImage()));
}

void
CQWinImage::
setImageName(const QString &fileName)
{
  fileName_ = fileName;

  QImage image(fileName);

  setImage(image);
}

void
CQWinImage::
setImage(const QImage &image)
{
  image_ = image;

  QPixmap pixmap = QPixmap::fromImage(image_);

  if (! pixmap.isNull()) {
    setPixmap(pixmap);

    widget_->setResizable(true);

    widget_->setChildSize(pixmap.size());

    widget_->setResizable(false);
  }
}

void
CQWinImage::
contextMenuEvent(QContextMenuEvent *event)
{
  menu_->exec(event->globalPos());
}

void
CQWinImage::
loadImage()
{
  QString fileName = QFileDialog::getOpenFileName(this,
    "Open Image", "", "Image Files (*.png *.gif *.jpg)");

  if (fileName.length())
    setImageName(fileName);

  emit valueChanged();
}

//---------------

CQWinTable::
CQWinTable(QWidget *parent, const char *name) :
 CQWinWidgetBase(parent)
{
  QTableWidget::setObjectName(name);

  widget_->setChild(this);

  connect(widget_, SIGNAL(geometryChanging()), this, SIGNAL(geometryChanging()));
  connect(widget_, SIGNAL(geometryChanged()), this, SIGNAL(geometryChanged()));
}

//---------------

CQWinTree::
CQWinTree(QWidget *parent, const char *name) :
 CQWinWidgetBase(parent)
{
  QTreeWidget::setObjectName(name);

  widget_->setChild(this);

  connect(widget_, SIGNAL(geometryChanging()), this, SIGNAL(geometryChanging()));
  connect(widget_, SIGNAL(geometryChanged()), this, SIGNAL(geometryChanged()));
}
##concat##CQAccelerate.h
#ifndef ALT_KEY_HPP
#define ALT_KEY_HPP

/*
    Copyright (c) 2008-10 Qtrac Ltd. All rights reserved.
    This program or module is free software: you can redistribute it
    and/or modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation, either version 2 of
    the License, or version 3 of the License, or (at your option) any
    later version. This program is distributed in the hope that it will
    be useful, but WITHOUT ANY WARRANTY; without even the implied
    warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    See the GNU General Public License for more details.

    This module is used to show where keyboard accelerators should go in
    menu option texts and dialog labels and instantly produces optimal
    results using the Kuhn-Munkres algorithm. It easily outperforms all
    the naive algorithms.
*/

#include <QCoreApplication> // For Q_DECLARE_TR_FUNCTIONS
#include <QList>
#include <QPair>
#include <QStringList>

class QAction;
class QWidget;

namespace CQAccelerate {
  /*
      The original Alphabet QString constant wasn't translatable because
      it is translated before the application has a chance to load its
      translations. An ideal solution would be to make Alphabet a function
      that returns the string, but that would break the Alt_Key module's
      API. Konrad Rosenbaum spotted these problems and came up with this
      class as a solution. Thanks to the _Alphabet class the Alphabet can
      be translated and can also be used pretty well everywhere a string
      is required, thus preserving the Alt_Key module's API.
  */
  class _Alphabet {
    Q_DECLARE_TR_FUNCTIONS(_Alphabet);

   public:
    _Alphabet() {}

    operator QString() const {
      return tr("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ", "Accelerator Keys");
    }
  };

  const _Alphabet Alphabet;

  QStringList accelerated(const QStringList &strings, const QString &alphabet=Alphabet);

  void accelerateMenu   (QWidget *menuOrMenuBar, const QString &alphabet=Alphabet);
  void accelerateActions(QList<QAction*> actions, const QString &alphabet=Alphabet);
  void accelerateWidget (QWidget *widget, const QString &alphabet=Alphabet);
  void accelerateWidgets(QList<QWidget*> widgets, const QString &alphabet=Alphabet);

  bool isValid(const QStringList &listOfStrings, QPair<int, int> *where=0,
               const QString &alphabet=Alphabet);

  int numberAccelerated(const QStringList &listOfStrings);

  double quality(const QStringList &listOfStrings);
}

#endif // ALT_KEY_HPP
##concat##CQAlphaButton.h
#ifndef CQAlphaButton_H
#define CQAlphaButton_H

#include <QWidget>

class CQAlphaButton : public QWidget {
  Q_OBJECT

 public:
  CQAlphaButton(QWidget *parent=0);

  double getAlpha() const;

  void setAlpha(double alpha);

  void setColor(QColor color);

 private:
  void paintEvent(QPaintEvent *);

  void mousePressEvent(QMouseEvent *e);
  void mouseMoveEvent(QMouseEvent *e);
  void mouseReleaseEvent(QMouseEvent *e);

  void posToAlpha(int pos);
  int alphaToPos();

 signals:
  void valueChanged();

 private:
  double alpha_;
  QColor fg_, bg_;
};

#endif
##concat##CQAngleSpinBox.h
#ifndef CQANGLE_SPINBOX_H
#define CQANGLE_SPINBOX_H

#include <QDoubleSpinBox>

class CQAngleSpinBox : public QDoubleSpinBox {
  Q_OBJECT

 public:
  CQAngleSpinBox(QWidget *parent, double value=0.0);
  CQAngleSpinBox(double value=0.0);

  virtual ~CQAngleSpinBox() { }

  double getValue() const;

 private:
  void init(const QString &name, double value);

 signals:
  void angleChanged(double);
};

#endif
##concat##CQColorChooser.h
#ifndef CQColorChooser_H
#define CQColorChooser_H

#include <QWidget>
#include <CRGBA.h>

class QLineEdit;
class QPushButton;
class QToolButton;
class QLabel;
class CQAlphaButton;

class CQColorChooser : public QWidget {
  Q_OBJECT

  Q_PROPERTY(QColor  color     READ color     WRITE setColor    )
  Q_PROPERTY(QString colorName READ colorName WRITE setColorName)

 public:
  enum Style {
    Text        = (1<<0),
    ColorButton = (1<<1),
    ColorLabel  = (1<<2),
    ImageButton = (1<<3),
    AlphaButton = (1<<4)
  };

 public:
  CQColorChooser(QWidget *parent=0);

  CQColorChooser(uint styles, QWidget *parent=0);

  bool getEditable() const { return editable_; }
  void setEditable(bool editable=true);

  uint getStyles() const { return styles_; }
  void setStyles(uint styles);

  const QColor &color() const;
  void setColor(const QColor &color, double alpha=1.0);

  void setRGBA(const CRGBA &rgba);
  CRGBA getRGBA() const;

  QString colorName() const;
  void setColorName(const QString &colorName, double alpha=1.0);

  double getAlpha() const;
  void setAlpha(double alpha);

  QLineEdit *getTextWidget() const { return cedit_; }

 private:
  void init();
  void update();
  void changeColor();
  void applyColor();

 private slots:
  void textColorChanged();
  void imageButtonClicked();
  void colorButtonClicked();
  void alphaButtonChanged();

 signals:
  void colorChanged(const QColor &color);
  void colorChanged(const QString &colorName);

  void colorApplied(const QColor &color);
  void colorApplied(const QString &colorName);

 private:
  uint           styles_;
  bool           editable_;
  bool           has_alpha_;
  QColor         color_;
  QString        colorName_;
  double         alpha_;
  QLineEdit     *cedit_;   // text color name
  QToolButton   *cbutton_; // click color button
  QLabel        *clabel_;  // static color button
  CQAlphaButton *alphab_;  // alpha slider
  QToolButton   *button_;  // image click button
};

#endif
##concat##CQDockWidget.h
#ifndef CQDOCKWIDGET_H
#define CQDOCKWIDGET_H

#include <QDockWidget>
#include <CQMenu.h>

#define CQDockMgrInst CQDockMgr::getInstance()

class CQDockMgr {
 private:
  CQMenu *toolsMenu_;

 public:
  static CQDockMgr *getInstance() {
    static CQDockMgr *instance;

    if (! instance)
      instance = new CQDockMgr;

    return instance;
  }

  CQMenu *getToolsMenu() const { return toolsMenu_; }

  CQMenu *addToolsMenu(QMainWindow *main_window) {
    toolsMenu_ = new CQMenu(main_window, "&Tools");

    return toolsMenu_;
  }

 private:
  CQDockMgr() :
   toolsMenu_(0) {
  }
};

class CQDockWidget {
 private:
  QMainWindow *main_window_;
  QDockWidget *dock_;
  QWidget     *widget_;

 public:
  CQDockWidget(QMainWindow *main_window, const QString &name, QWidget *w,
               Qt::DockWidgetArea area=Qt::RightDockWidgetArea) :
   main_window_(main_window), widget_(w) {
    dock_ = new QDockWidget(name, main_window);

    dock_->setWidget(widget_);

    main_window->addDockWidget(area, dock_);

    addToToolsMenu(dock_);
  }

  void addToToolsMenu(QDockWidget *dock) {
    CQMenu *toolsMenu = CQDockMgrInst->getToolsMenu();

    if (toolsMenu)
      toolsMenu->addAction(dock->toggleViewAction());
  }

  QMainWindow *getMainWindow() const { return main_window_; }

  QDockWidget *getDockWidget() const { return dock_; }

  QWidget *getWidget() const { return widget_; }

  void setAllowedAreas(Qt::DockWidgetAreas areas) {
    dock_->setAllowedAreas(areas);
  }
};

#endif
##concat##CQDrawUtil.h
/****************************************************************************
**
** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
** Contact: http://www.qt-project.org/legal
**
** This file is part of the QtGui module of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:LGPL$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and Digia.  For licensing terms and
** conditions see http://qt.digia.com/licensing.  For further information
** use the contact form at http://qt.digia.com/contact-us.
**
** GNU Lesser General Public License Usage
** Alternatively, this file may be used under the terms of the GNU Lesser
** General Public License version 2.1 as published by the Free Software
** Foundation and appearing in the file LICENSE.LGPL included in the
** packaging of this file.  Please review the following information to
** ensure the GNU Lesser General Public License version 2.1 requirements
** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
**
** In addition, as a special exception, Digia gives you certain additional
** rights.  These rights are described in the Digia Qt LGPL Exception
** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
**
** GNU General Public License Usage
** Alternatively, this file may be used under the terms of the GNU
** General Public License version 3.0 as published by the Free Software
** Foundation and appearing in the file LICENSE.GPL included in the
** packaging of this file.  Please review the following information to
** ensure the GNU General Public License version 3.0 requirements will be
** met: http://www.gnu.org/copyleft/gpl.html.
**
**
** $QT_END_LICENSE$
**
****************************************************************************/

#ifndef QDRAWUTIL_H
#define QDRAWUTIL_H

#include <QtCore/qnamespace.h>
#include <QtCore/qstring.h> // char*->QString conversion
#include <QtCore/qmargins.h>
#include <QtGui/qpixmap.h>
QT_BEGIN_HEADER

QT_BEGIN_NAMESPACE

QT_MODULE(Gui)

class QPainter;
#ifndef QT3_SUPPORT
class QColorGroup;
#endif
class QPalette;
class QPoint;
class QColor;
class QBrush;
class QRect;

//
// Standard shade drawing
//

Q_GUI_EXPORT void qDrawShadeLine(QPainter *p, int x1, int y1, int x2, int y2,
                              const QPalette &pal, bool sunken = true,
                              int lineWidth = 1, int midLineWidth = 0);

Q_GUI_EXPORT void qDrawShadeLine(QPainter *p, const QPoint &p1, const QPoint &p2,
                              const QPalette &pal, bool sunken = true,
                              int lineWidth = 1, int midLineWidth = 0);

Q_GUI_EXPORT void qDrawShadeRect(QPainter *p, int x, int y, int w, int h,
                              const QPalette &pal, bool sunken = false,
                              int lineWidth = 1, int midLineWidth = 0,
                              const QBrush *fill = 0);

Q_GUI_EXPORT void qDrawShadeRect(QPainter *p, const QRect &r,
                              const QPalette &pal, bool sunken = false,
                              int lineWidth = 1, int midLineWidth = 0,
                              const QBrush *fill = 0);

Q_GUI_EXPORT void qDrawShadePanel(QPainter *p, int x, int y, int w, int h,
                               const QPalette &pal, bool sunken = false,
                               int lineWidth = 1, const QBrush *fill = 0);

Q_GUI_EXPORT void qDrawShadePanel(QPainter *p, const QRect &r,
                               const QPalette &pal, bool sunken = false,
                               int lineWidth = 1, const QBrush *fill = 0);

Q_GUI_EXPORT void qDrawWinButton(QPainter *p, int x, int y, int w, int h,
                              const QPalette &pal, bool sunken = false,
                              const QBrush *fill = 0);

Q_GUI_EXPORT void qDrawWinButton(QPainter *p, const QRect &r,
                              const QPalette &pal, bool sunken = false,
                              const QBrush *fill = 0);

Q_GUI_EXPORT void qDrawWinPanel(QPainter *p, int x, int y, int w, int h,
                              const QPalette &pal, bool sunken = false,
                             const QBrush *fill = 0);

Q_GUI_EXPORT void qDrawWinPanel(QPainter *p, const QRect &r,
                              const QPalette &pal, bool sunken = false,
                             const QBrush *fill = 0);

Q_GUI_EXPORT void qDrawPlainRect(QPainter *p, int x, int y, int w, int h, const QColor &,
                              int lineWidth = 1, const QBrush *fill = 0);

Q_GUI_EXPORT void qDrawPlainRect(QPainter *p, const QRect &r, const QColor &,
                              int lineWidth = 1, const QBrush *fill = 0);


#ifdef QT3_SUPPORT
//
// Use QStyle::itemRect(), QStyle::drawItem() and QStyle::drawArrow() instead.
//
Q_GUI_EXPORT QT3_SUPPORT QRect qItemRect(QPainter *p, Qt::GUIStyle gs, int x, int y, int w, int h,
                          int flags, bool enabled,
                          const QPixmap *pixmap, const QString& text, int len=-1);

Q_GUI_EXPORT QT3_SUPPORT void qDrawItem(QPainter *p, Qt::GUIStyle gs, int x, int y, int w, int h,
                         int flags, const QPalette &pal, bool enabled,
                         const QPixmap *pixmap, const QString& text,
                         int len=-1, const QColor* penColor = 0);

Q_GUI_EXPORT QT3_SUPPORT void qDrawArrow(QPainter *p, Qt::ArrowType type, Qt::GUIStyle style, bool down,
                          int x, int y, int w, int h,
                          const QPalette &pal, bool enabled);
#endif

struct QTileRules
{
    inline QTileRules(Qt::TileRule horizontalRule, Qt::TileRule verticalRule)
            : horizontal(horizontalRule), vertical(verticalRule) {}
    inline QTileRules(Qt::TileRule rule = Qt::StretchTile)
            : horizontal(rule), vertical(rule) {}
    Qt::TileRule horizontal;
    Qt::TileRule vertical;
};

#ifndef Q_QDOC
// For internal use only.
namespace QDrawBorderPixmap
{
    enum DrawingHint
    {
        OpaqueTopLeft = 0x0001,
        OpaqueTop = 0x0002,
        OpaqueTopRight = 0x0004,
        OpaqueLeft = 0x0008,
        OpaqueCenter = 0x0010,
        OpaqueRight = 0x0020,
        OpaqueBottomLeft = 0x0040,
        OpaqueBottom = 0x0080,
        OpaqueBottomRight = 0x0100,
        OpaqueCorners = OpaqueTopLeft | OpaqueTopRight | OpaqueBottomLeft | OpaqueBottomRight,
        OpaqueEdges = OpaqueTop | OpaqueLeft | OpaqueRight | OpaqueBottom,
        OpaqueFrame = OpaqueCorners | OpaqueEdges,
        OpaqueAll = OpaqueCenter | OpaqueFrame
    };

    Q_DECLARE_FLAGS(DrawingHints, DrawingHint)
}
#endif

Q_GUI_EXPORT void qDrawBorderPixmap(QPainter *painter,
                                    const QRect &targetRect,
                                    const QMargins &targetMargins,
                                    const QPixmap &pixmap,
                                    const QRect &sourceRect,
                                    const QMargins &sourceMargins,
                                    const QTileRules &rules = QTileRules()
#ifndef Q_QDOC
                                    , QDrawBorderPixmap::DrawingHints hints = 0
#endif
                                    );

inline void qDrawBorderPixmap(QPainter *painter,
                                           const QRect &target,
                                           const QMargins &margins,
                                           const QPixmap &pixmap)
{
    qDrawBorderPixmap(painter, target, margins, pixmap, pixmap.rect(), margins);
}

QT_END_NAMESPACE

QT_END_HEADER

#endif // QDRAWUTIL_H
##concat##CQFillOption.h
#include <CQOptionToolSet.h>
#include <CQIllustratorShape.h>

class QPaintEvent;
class QStackedWidget;
class QComboBox;
class QCheckBox;
class QDoubleSpinBox;

class CQFillOptionDialog;
class CQFillOptionSwab;
class CQImageButton;
class CQColorChooser;
class CQRealEdit;
class CQPointEdit;
class CQGradientStopList;
class CQImagePreview;
class CQIllustratorShapeFill;

class CQFillOptionTool : public CQOptionTool {
  Q_OBJECT

 public:
  CQFillOptionTool(CQIllustrator *illustrator);

  CQOptionToolDialog *getDialog();

  CQIllustrator *getIllustrator() const { return illustrator_; }

 private slots:
  void selectionChangedSlot();

 signals:
  void valueChanged(const CQIllustratorShapeFill &fill);
  void clipChanged(bool);

 private:
  CQIllustrator      *illustrator_;
  CQFillOptionDialog *dialog_;
  CQFillOptionSwab   *swab_;
};

class CQFillOptionDialog : public CQOptionToolDialog {
  Q_OBJECT

 public:
  CQFillOptionDialog(CQFillOptionTool *tool);

  void setFill(const CQIllustratorShapeFill &fill);

  const CQIllustratorShapeFill &getFill() const { return fill_; }

 private:
  void initWidgets();
  void setActiveState();
  void updateWidgets();

 private slots:
  void flatSlot();
  void lgradSlot();
  void rgradSlot();
  void imageSlot();

  void colorSlot   (const QColor &color);
  void opacitySlot (double value);
  void fillRuleSlot(const QString &value);
  void clipSlot    ();

  void updateLGrad();
  void updateLGradStops();
  void addLGradStop();
  void removeLGradStop();

  void updateRGrad();
  void updateRGradStops();
  void addRGradStop();
  void removeRGradStop();

  void setImageSlot();
  void imageScaleSlot(const QString &value);

  void setDefaultSlot();
  void setBackgroundSlot();

 signals:
  void valueChanged(const CQIllustratorShapeFill &fill);
  void clipChanged(bool);

 private:
  CQFillOptionTool       *tool_;
  CQIllustratorShapeFill  fill_;

  CQImageButton *flatButton_;
  CQImageButton *lgradButton_;
  CQImageButton *rgradButton_;
  CQImageButton *imageButton_;

  QStackedWidget *stack_;

  // Flat Widgets

  CQColorChooser *colorChooser_;
  QDoubleSpinBox *opacityEdit_;
  QComboBox      *fillRule_;
  QCheckBox      *clipCheck_;

  // Linear Gradient Widgets

  CQPointEdit        *lgrad1_;
  CQPointEdit        *lgrad2_;
  CQGradientStopList *lgradStops_;

  // Radial Gradient Widgets

  CQPointEdit        *rgradC_;
  CQRealEdit         *rgradR_;
  CQPointEdit        *rgradF_;
  CQGradientStopList *rgradStops_;

  // Image Widgets

  CQImagePreview *imagePreview_;
  QComboBox      *imageScale_;
};
##concat##CQFontChooser.h
#ifndef CQFontChooser_H
#define CQFontChooser_H

#include <QWidget>

class QLineEdit;
class QPushButton;
class QToolButton;
class QLabel;
class QFontComboBox;
class QComboBox;

class CQFontChooser : public QWidget {
  Q_OBJECT

  Q_PROPERTY(QFont   font     READ font     WRITE setFont    )
  Q_PROPERTY(QString fontName READ fontName WRITE setFontName)

 public:
  enum Style {
    FontNone,
    FontEdit,
    FontButton,
    FontLabel,
    FontCombo
  };

  CQFontChooser(QWidget *parent=0);

  const QFont &font() const;

  QString fontName() const;

 public slots:
  void setStyle(Style style);

  void setFixedWidth(bool fixedWidth);

  void setFont(const QFont &font);

  void setFontName(const QString &fontName);

 private:
  void updateWidgets();

  void updateCombos();

  void updateStyles();
  void updateSizes();

 private slots:
  void chooseFont();
  void editFont();
  void applyFont();
  void nameChanged();
  void styleChanged();
  void sizeChanged();

 signals:
  void fontChanged(const QFont &font);
  void fontChanged(const QString &fontName);
  void fontApplied(const QFont &font);
  void fontApplied(const QString &fontName);

 private:
  Style          style_;
  bool           fixedWidth_;
  QFont          font_;
  QString        fontName_;
  QLineEdit     *cedit_;
  QToolButton   *cbutton_;
  QLabel        *clabel_;
  QToolButton   *button_;
  QFontComboBox *ncombo_;
  QComboBox     *scombo_;
  QComboBox     *zcombo_;
};

#endif
##concat##CQFontOption.h
#include <CQOptionToolSet.h>

class CQFontOptionDialog;
class CQFontChooser;
class QPaintEvent;

class CQFontOptionTool : public CQOptionTool {
  Q_OBJECT

 public:
  CQFontOptionTool(QWidget *parent=0);

  CQOptionToolDialog *getDialog();

  void setFont(QFont font);

  QFont getFont() const;

 signals:
  void valueChanged(const QFont &);

 private:
  CQFontOptionDialog *dialog_;
};

class CQFontOptionDialog : public CQOptionToolDialog {
  Q_OBJECT

 public:
  CQFontOptionDialog(CQFontOptionTool *tool);

  void setFont(QFont font);

  QFont getFont() const { return font_; }

 private:
  void initWidgets();
  void updateWidgets();

 private slots:
  void fontSlot(const QFont &font);

 signals:
  void valueChanged(const QFont &);

 private:
  CQFontOptionTool *tool_;
  QFont             font_;
  CQFontChooser    *fontChooser_;
};
##concat##CQGradientStopList.h
#ifndef CQGRADIENT_STOP_LIST_H
#define CQGRADIENT_STOP_LIST_H

#include <QPointer>

#include <CQTableWidget.h>
#include <CGenGradient.h>

class CQGradientStopList;
class CQGradientStopTable;
class CQColorChooser;
class CQRealEdit;

//------

class CQGradientStopColorItem : public CQTableWidgetItem {
 public:
  enum { TYPE = QTableWidgetItem::UserType + 1 };

  CQGradientStopColorItem(CQGradientStopTable *t, uint ind, const CRGBA &rgba);

  const CRGBA &getColor() const { return rgba_; }

  CQGradientStopColorItem *clone() const;

  QString getString();

  QWidget *createEditor(QWidget *parent) const;

  void setEditorData();

  void getEditorData(QString &str);

  bool sizeHint(const QStyleOptionViewItem &option, QSize &size) const;

  bool paint(QPainter *painter, const QStyleOptionViewItem &option) const;

 private:
  CQGradientStopTable              *table_;
  uint                              ind_;
  CRGBA                             rgba_;
  mutable QPointer<CQColorChooser>  edit_;
};

//------

class CQGradientStopAlphaItem : public CQTableWidgetItem {
 public:
  enum { TYPE = QTableWidgetItem::UserType + 2 };

  CQGradientStopAlphaItem(CQGradientStopTable *t, uint ind, double offset);

  double getAlpha() const { return alpha_; }

  CQGradientStopAlphaItem *clone() const;

  QString getString();

  QWidget *createEditor(QWidget *parent) const;

  void setEditorData();

  void getEditorData(QString &str);

  QString toString() const;

 private:
  CQGradientStopTable          *table_;
  uint                          ind_;
  double                        alpha_;
  mutable QPointer<CQRealEdit>  edit_;
};

//------

class CQGradientStopOffsetItem : public CQTableWidgetItem {
 public:
  enum { TYPE = QTableWidgetItem::UserType + 2 };

  CQGradientStopOffsetItem(CQGradientStopTable *t, uint ind, double offset);

  double getOffset() const { return offset_; }

  CQGradientStopOffsetItem *clone() const;

  QString getString();

  QWidget *createEditor(QWidget *parent) const;

  void setEditorData();

  void getEditorData(QString &r);

  QString toString() const;

 private:
  CQGradientStopTable          *table_;
  uint                          ind_;
  double                        offset_;
  mutable QPointer<CQRealEdit>  edit_;
};

//------

class CQGradientStopTable : public CQTableWidget {
  Q_OBJECT

 public:
  CQGradientStopTable(CQGradientStopList *list);

  void clear();

 private:
  CQGradientStopList *list_;

 private slots:
  void updateStopsSlot();
};

//------

class CQGradientStopList : public QWidget {
  Q_OBJECT

 public:
  CQGradientStopList(QWidget *parent=0);

  void init(const CGenGradient &g);

  const CGenGradient::StopList &getStops() const { return stops_; }

  CGenGradient::StopList &getStops() { return stops_; }

  void emitStopsChanged();

 signals:
  void stopsChanged();

 private:
  CQGradientStopTable    *table_;
  CGenGradient::StopList  stops_;
};

#endif
##concat##CQIllustratorAlignMode.h
#ifndef CQIllustratorAlignMode_H
#define CQIllustratorAlignMode_H

#include <CQIllustrator.h>
#include <CQIllustratorMode.h>
#include <CQIllustratorToolbar.h>
#include <QToolButton>

class QDockWidget;
class QComboBox;
class QPushButton;
class QToolButton;
class QStackedWidget;
class QLineEdit;
class QLabel;

class CQAlignButtons;
class CQDistButtons;
class CQSpreadButtons;
class CQRealEdit;
class CQAlignAnchor;
class CQPointEdit;
class CQIllustratorAlignMode;

class CQIllustratorAlignToolbar : public CQIllustratorToolbar {
  Q_OBJECT

 public:
  enum AnchorMode {
    SELECTION_MODE,
    OBJECT_MODE,
    POSITION_MODE
  };

  enum ObjectEdgeType {
    EDGE_LEFT_BOTTOM,
    EDGE_RIGHT_TOP,
    EDGE_MIDDLE
  };

 public:
  CQIllustratorAlignToolbar(CQIllustratorAlignMode *mode);

  const char *getTitle() const { return "Align"; }

  QIcon getIcon();

  void addWidgets();

  double getOffset() const;

  AnchorMode getAnchorMode() const;

  QString getAnchorObject() const;

  void setAnchorObject(const QString &name);

  ObjectEdgeType getAnchorObjectEdgeType() const;

  QPointF getAnchorPosition() const;

  void setAnchorPosition(const QPointF &pos);

  void resetSelectMode();

 signals:
  void alignLeft();
  void alignBottom();
  void alignRight();
  void alignTop();
  void alignHorizontal();
  void alignVertical();

  void alignLeftPreview();
  void alignBottomPreview();
  void alignRightPreview();
  void alignTopPreview();
  void alignHorizontalPreview();
  void alignVerticalPreview();

  void alignPreviewClear();

  void selectAnchorObject();
  void selectAnchorPosition();
  void cancelSelectAnchor();

 private:
  CQIllustratorAlignMode *mode_;
  CQAlignButtons         *alignw_;
  CQDistButtons          *distw_;
  CQSpreadButtons        *spreadw_;
  CQRealEdit             *offset_;
  CQAlignAnchor          *anchor_;
};

class CQIllustratorAlignMode : public CQIllustratorMode {
  Q_OBJECT

 public:
  CQIllustratorAlignMode(CQIllustrator *illustrator);

  const char *getTitle() const { return "Align"; }

  CQIllustratorAlignToolbar *createToolbar();

  CQMenuItem *createMenuItem(CQMenu *menu);

  CQIllustratorAlignToolbar *getToolbar() const { return toolbar_; }

  void handleMouseRelease(const MouseEvent &e);
  void handleMouseDrag   (const MouseEvent &e);

  void drawOverlay(CQIllustratorShapeDrawer *drawer);

  QCursor getCursor() const;

  void align(CQIllustrator::AlignSide side, bool commit);

 private:
  CQIllustratorAlignToolbar *toolbar_;

 private slots:
  void alignLSlot();
  void alignLPreviewSlot();
  void alignBSlot();
  void alignBPreviewSlot();
  void alignRSlot();
  void alignRPreviewSlot();
  void alignTSlot();
  void alignTPreviewSlot();
  void alignHSlot();
  void alignHPreviewSlot();
  void alignVSlot();
  void alignVPreviewSlot();
  void alignPreviewClearSlot();
};

class CQAlignButtons : public QWidget {
  Q_OBJECT

 public:
  CQAlignButtons();

 signals:
  void alignLeft();
  void alignBottom();
  void alignRight();
  void alignTop();
  void alignHorizontal();
  void alignVertical();

  void alignLeftPreview();
  void alignBottomPreview();
  void alignRightPreview();
  void alignTopPreview();
  void alignHorizontalPreview();
  void alignVerticalPreview();

  void alignPreviewClear();
};

class CQDistButtons : public QWidget {
 public:
  CQDistButtons();
};

class CQSpreadButtons : public QWidget {
 public:
  CQSpreadButtons();
};

class CQAlignAnchorObject;
class CQAlignAnchorPoint;

class CQAlignAnchor : public QWidget {
  Q_OBJECT

 public:
  typedef CQIllustratorAlignToolbar::AnchorMode     AnchorMode;
  typedef CQIllustratorAlignToolbar::ObjectEdgeType ObjectEdgeType;

 public:
  CQAlignAnchor(QWidget *parent = 0);

  AnchorMode getMode() const;

  QString getObject() const;

  void setObject(const QString &name);

  ObjectEdgeType getObjectEdgeType() const;

  QPointF getPosition() const;

  void setPosition(const QPointF &pos);

  void resetSelectMode();

 private:
  void updateState();

 private:
  AnchorMode           mode_;
  QComboBox           *objectCombo_;
  QStackedWidget      *anchorStack_;
  QWidget             *anchorLabel_;
  CQAlignAnchorObject *anchorObject_;
  CQAlignAnchorPoint  *anchorPoint_;

 signals:
  void selectObject();
  void selectPosition();
  void cancelSelect();

 private slots:
  void objectSlot(const QString &obj);
};

class CQAlignAnchorObject : public QWidget {
  Q_OBJECT

 public:
  typedef CQIllustratorAlignToolbar::ObjectEdgeType ObjectEdgeType;

 public:
  CQAlignAnchorObject(QWidget *parent=0);

  QString getName() const;

  void setName(const QString &name);

  ObjectEdgeType getEdgeType() const { return edgeType_; }

  void resetSelectMode();

 private:
  ObjectEdgeType  edgeType_;
  QLineEdit      *nameEdit_;
  QToolButton    *edgeButton_;
  QToolButton    *selButton_;

 signals:
  void selectObject();
  void cancelSelect();

 private slots:
  void edgeSlot(QAction *);
  void selectSlot(bool);
};

class CQAlignAnchorPoint : public QWidget {
  Q_OBJECT

 public:
  CQAlignAnchorPoint(QWidget *parent=0);

  QPointF getValue() const;

  void setValue(const QPointF &point);

  void resetSelectMode();

 private:
  CQPointEdit *pointEdit_;
  QToolButton *selButton_;

 signals:
  void selectPoint();
  void cancelSelect();

 private slots:
  void selectSlot(bool);
};

class CQToolButton : public QToolButton {
  Q_OBJECT

 public:
  CQToolButton(const char **xpmData);

 private:
  bool event(QEvent*);

 signals:
  void previewStart();
  void previewStop();

 private:
  bool preview_;
};

#endif
##concat##CQIllustratorCanvas.h
#ifndef CQIllustratorCanvas_H
#define CQIllustratorCanvas_H

#include <QWidget>
#include <CDisplayRange2D.h>

class CQIllustrator;
class CQIllustratorShape;
class CQIllustratorInfo;
class CTimer;
class QMenu;

class CQIllustratorCanvas : public QWidget {
  Q_OBJECT

 public:
  CQIllustratorCanvas(CQIllustrator *illustrator);

  void mousePressEvent  (QMouseEvent *event);
  void mouseMoveEvent   (QMouseEvent *event);
  void mouseReleaseEvent(QMouseEvent *event);

  void keyPressEvent(QKeyEvent *e);

  void wheelEvent(QWheelEvent *event);

  void paintEvent (QPaintEvent  *event);
  void resizeEvent(QResizeEvent *event);

  bool getPressed() const { return pressed_; }

  const CMatrix2D &getMatrix() { return range_.getMatrix(); }

  const QTransform &getTransform () const { return transform_ ; }
  const QTransform &getITransform() const { return itransform_; }

  void updateStatus();

 private:
  void showMenu(const QPoint &pos);

 private slots:
  void timeoutSlot();

 private:
  CQIllustrator      *illustrator_;
  QPainter           *painter_;
  QMenu              *popupMenu_;
  CDisplayRange2D     range_;
  bool                pressed_;
  QTransform          transform_;
  QTransform          itransform_;
  QTimer             *timer_;
  CQIllustratorShape *infoShape_;
  CQIllustratorInfo  *infoLabel_;
};

#endif
##concat##CQIllustratorCmd.h
#ifndef CQIllustratorCmd_H
#define CQIllustratorCmd_H

#include <CArgs.h>
#include <map>

class CQIllustrator;
class CQIllustratorCmd;

class CQIllustratorCmdMgr {
 public:
  CQIllustratorCmdMgr(CQIllustrator *illustrator);

  void addCommand(CQIllustratorCmd *cmd);

  bool execCmd(const std::string &text) const;

  void displayCmds() const;

 private:
  typedef std::map<std::string, CQIllustratorCmd *> CmdList;

  CQIllustrator *illustrator_;
  CmdList        cmdList_;
};

class CQIllustratorCmd {
 public:
  CQIllustratorCmd(const char *args);

  virtual ~CQIllustratorCmd() { }

  virtual const char *getName() const = 0;

  virtual bool exec(const std::vector<std::string> &words) = 0;

  void setIllustrator(CQIllustrator *illustrator) { illustrator_ = illustrator; }

 protected:
  CQIllustrator *illustrator_;
  CArgs          args_;
};

#endif
##concat##CQIllustratorCreateEllipseMode.h
#ifndef CQIllustratorCreateEllipseMode_H
#define CQIllustratorCreateEllipseMode_H

#include <CQIllustratorMode.h>
#include <CQIllustratorToolbar.h>

#include <QComboBox>

class CQPointEdit;
class CQRealEdit;
class CQAngleSpinBox;
class CQIllustrator;
class CQIllustratorControlPointHandle;
class CQIllustratorCreateEllipseMode;
class CQIllustratorCreateEllipseSizer;

class CQEllipseShape2DConnectType : public QComboBox {
  Q_OBJECT

 public:
  CQEllipseShape2DConnectType(QWidget *parent=0);

  void setType(CEllipseConnectType value);

  CEllipseConnectType getType() const { return value_; }

 private slots:
  void itemSlot(const QString &name);

 signals:
  void valueChanged();

 private:
  std::map<QString,CEllipseConnectType> nameValue_;
  std::map<CEllipseConnectType,QString> valueName_;
  CEllipseConnectType                   value_;
};

class CQIllustratorCreateEllipseToolbar : public CQIllustratorToolbar {
  Q_OBJECT

 public:
  CQIllustratorCreateEllipseToolbar(CQIllustratorCreateEllipseMode *mode);

  const char *getTitle() const { return "Create Ellipse"; }

  QIcon getIcon();

  void addWidgets();

  void setSelectedShape(const CQIllustratorShape *shape);

  void setSize(const CBBox2D &bbox);

 private slots:
  void updateShape();

 private:
  CQIllustratorCreateEllipseMode *mode_;
  CQPointEdit                    *posEdit_;
  CQRealEdit                     *widthEdit_;
  CQRealEdit                     *heightEdit_;
  CQAngleSpinBox                 *angle1Edit_;
  CQAngleSpinBox                 *angle2Edit_;
  CQEllipseShape2DConnectType    *connectEdit_;
};

class CQIllustratorCreateEllipseSizer : public CQIllustratorModeSizer {
 public:
  CQIllustratorCreateEllipseSizer(CQIllustratorCreateEllipseMode *mode);

  void drawHandles(QPainter *painter, const CQIllustratorShape *shape);

 private:
  CQIllustratorControlPointHandle *rx_handle_;
  CQIllustratorControlPointHandle *ry_handle_;
  CQIllustratorControlPointHandle *a1_handle_;
  CQIllustratorControlPointHandle *a2_handle_;
};

class CQIllustratorCreateEllipseMode : public CQIllustratorMode {
  Q_OBJECT

 public:
  CQIllustratorCreateEllipseMode(CQIllustrator *illustrator);

  const char *getTitle() const { return "Create Ellipse"; }

  CQIllustratorCreateEllipseToolbar *getToolbar() { return toolbar_; }

  CQIllustratorCreateEllipseToolbar *createToolbar();

  CQIllustratorCreateEllipseSizer *createSizer();

  CQMenuItem *createMenuItem(CQMenu *menu);

  bool isCreateMode() const { return true; }

  CQIllustratorCreateEllipseToolbar *getToolbar() const { return toolbar_; }

  void handleMouseRelease(const MouseEvent &e);
  void handleMouseDrag   (const MouseEvent &e);

  void drawOverlay(CQIllustratorShapeDrawer *drawer);

 private:
  CQIllustratorCreateEllipseToolbar *toolbar_;
  CQIllustratorCreateEllipseSizer   *sizer_;
  bool                               equalSize_;
};

#endif
##concat##CQIllustratorCreatePathMode.h
#ifndef CQIllustratorCreatePathMode_H
#define CQIllustratorCreatePathMode_H

#include <CQIllustratorMode.h>
#include <CQIllustratorToolbar.h>

class QRadioButton;
class CQImageButton;
class CQPointEdit;
class CQIllustrator;
class CQIllustratorHandle;
class CQIllustratorCreatePathMode;

class CQIllustratorCreatePathToolbar : public CQIllustratorToolbar {
  Q_OBJECT

 public:
  enum CreateMode {
    CREATE_FREE_MODE,
    CREATE_RECT_MODE,
    CREATE_45_MODE
  };

 public:
  CQIllustratorCreatePathToolbar(CQIllustratorCreatePathMode *mode);

  const char *getTitle() const { return "Create Path"; }

  QIcon getIcon();

  void addWidgets();

  CreateMode getCreateMode() const { return createMode_; }

  void setSelectedShape(const CQIllustratorShape *shape);

  void setSelectedShapePoint(const CQIllustratorShape *shape,
                             const CQIllustratorShapeControlPoint *point);

  void updateShape();

  void setSize(const CBBox2D &bbox);

  void setSelectionPoint(const CPoint2D &p);

 private slots:
  void modeChangedSlot();

  void pathFreeSlot(bool);
  void pathRectSlot(bool);
  void path45Slot(bool);

  void selChangedSlot();

  void lineModeSlot(bool);
  void curve2ModeSlot(bool);
  void curve3ModeSlot(bool);

  void cornerNodeSlot();
  void curveNodeSlot();

  void addNodeSlot();
  void removeNodeSlot();

  void updateNodeSlot();

 private:
  void setPathMode(CPathPartType pathMode, bool state);

  void updateMode();

 private:
  CQIllustratorCreatePathMode *mode_;
  CreateMode                   createMode_;
  QRadioButton                *createRadio_;
  QRadioButton                *editRadio_;
  CQImageButton               *pathFreeButton_;
  CQImageButton               *pathRectButton_;
  CQImageButton               *path45Button_;
  QRadioButton                *pointRadio_;
  QRadioButton                *lineRadio_;
  CQImageButton               *pathLineButton_;
  CQImageButton               *pathCurve2Button_;
  CQImageButton               *pathCurve3Button_;
  CQImageButton               *nodeCornerButton_;
  CQImageButton               *nodeCurveButton_;
  CQImageButton               *addNodeButton_;
  CQImageButton               *removeNodeButton_;
  CQPointEdit                 *pointEdit_;
};

class CQIllustratorCreatePathSizer : public CQIllustratorModeSizer {
 public:
  CQIllustratorCreatePathSizer(CQIllustratorCreatePathMode *mode);

  void drawHandles(QPainter *painter, const CQIllustratorShape *shape);

  void updateHandles(uint numHandles);
};

class CQIllustratorCreatePathMode : public CQIllustratorMode {
 public:
  enum SelMode {
    POINT_SEL,
    LINE_SEL
  };

 public:
  CQIllustratorCreatePathMode(CQIllustrator *illustrator);

  const char *getTitle() const { return "Create Path"; }

  CQIllustratorCreatePathToolbar *createToolbar();

  CQIllustratorCreatePathSizer *createSizer();

  void setSelMode(SelMode mode);

  SelMode getSelMode() const { return selMode_; }

  void setPathMode(CPathPartType pathMode);

  CPathPartType getPathMode() const { return pathMode_; }

  CQMenuItem *createMenuItem(CQMenu *menu);

  bool isCreateMode() const { return true; }

  CQIllustratorCreatePathToolbar *getToolbar() const { return toolbar_; }

  void handleMousePress  (const MouseEvent &e);
  void handleMouseRelease(const MouseEvent &e);
  void handleMouseDrag   (const MouseEvent &e);
  void handleMouseMove   (const MouseEvent &e);

  bool handleKeyPress(const KeyEvent &e);

 private:
  void addPoint(QPointF w, QPoint p);

  void snapPoint(CPoint2D &p);

  void addCloseHandle(const CPoint2D &cp, const CPoint2D &p);
  void addSnapHandle (const CPoint2D &cp, const CPoint2D &p);

  void accept();

  bool cancel();

  void drawOverlay(CQIllustratorShapeDrawer *drawer);

  void drawPathPoints(QPainter *painter);

  QCursor getCursor() const;

  void commitPathPoints(bool closed);

 public:
  void setCurrentToCornerNode();
  void setCurrentToCurveNode();

  void addNodeToCurrent();
  void removeNodeFromCurrent();

 private:
  struct PathPoint {
    CPathPartType type;
    CPoint2D      p;
    CPoint2D      c1;
    CPoint2D      c2;

    PathPoint(CPathPartType type1, const CPoint2D &p1=CPoint2D()) :
     type(type1), p(p1), c1(p1), c2(p1) {
    }
  };

  typedef std::vector<PathPoint> PathPointList;

  CQIllustratorCreatePathToolbar     *toolbar_;
  CQIllustratorCreatePathSizer       *sizer_;
  SelMode                             selMode_;
  CPathPartType                       pathMode_;
  std::vector<CQIllustratorHandle *>  closeHandles_;
  uint                                closeHandleNum_;
  std::vector<CQIllustratorHandle *>  snapHandles_;
  uint                                snapHandleNum_;
  QPoint                              pathStart_;
  PathPointList                       pathPoints_;
};

#endif
##concat##CQIllustratorCreatePolygonMode.h
#ifndef CQIllustratorCreatePolygonMode_H
#define CQIllustratorCreatePolygonMode_H

#include <CQIllustratorMode.h>
#include <CQIllustratorToolbar.h>

class QRadioButton;
class CQImageButton;
class CQPointEdit;
class CQIllustrator;
class CQIllustratorHandle;
class CQIllustratorCreatePolygonMode;

class CQIllustratorCreatePolygonToolbar : public CQIllustratorToolbar {
  Q_OBJECT

 public:
  enum CreateMode {
    CREATE_FREE_MODE,
    CREATE_RECT_MODE,
    CREATE_45_MODE
  };

 public:
  CQIllustratorCreatePolygonToolbar(CQIllustratorCreatePolygonMode *mode);

  const char *getTitle() const { return "Create Polygon"; }

  QIcon getIcon();

  void addWidgets();

  CreateMode getCreateMode() const { return createMode_; }

  void setSelectedShape(const CQIllustratorShape *shape);

  void setSelectedShapePoint(const CQIllustratorShape *shape,
                             const CQIllustratorShapeControlPoint *point);

  void updateShape();

  void setSize(const CBBox2D &bbox);

  void setSelectionPoint(const CPoint2D &p);

 private slots:
  void modeChangedSlot();

  void polyFreeSlot(bool);
  void polyRectSlot(bool);
  void poly45Slot(bool);

  void addPointSlot();
  void removePointSlot();

  void updatePointSlot();

 private:
  CQIllustratorCreatePolygonMode *mode_;
  CreateMode                      createMode_;
  QRadioButton                   *createRadio_;
  QRadioButton                   *editRadio_;
  CQImageButton                  *polyFreeButton_;
  CQImageButton                  *polyRectButton_;
  CQImageButton                  *poly45Button_;
  CQImageButton                  *addPointButton_;
  CQImageButton                  *removePointButton_;
  CQPointEdit                    *pointEdit_;
};

class CQIllustratorCreatePolygonSizer : public CQIllustratorModeSizer {
 public:
  CQIllustratorCreatePolygonSizer(CQIllustratorCreatePolygonMode *mode);

  void drawHandles(QPainter *painter, const CQIllustratorShape *shape);

  void updateHandles(uint numHandles);
};

class CQIllustratorCreatePolygonMode : public CQIllustratorMode {
 public:
  CQIllustratorCreatePolygonMode(CQIllustrator *illustrator);

  const char *getTitle() const { return "Create Polygon"; }

  CQIllustratorCreatePolygonToolbar *createToolbar();

  CQIllustratorCreatePolygonSizer *createSizer();

  CQMenuItem *createMenuItem(CQMenu *menu);

  bool isCreateMode() const { return true; }

  CQIllustratorCreatePolygonToolbar *getToolbar() const { return toolbar_; }

  void handleMousePress  (const MouseEvent &e);
  void handleMouseRelease(const MouseEvent &e);
  void handleMouseDrag   (const MouseEvent &e);
  void handleMouseMove   (const MouseEvent &e);

  bool handleKeyPress(const KeyEvent &e);

 private:
  void addPoint(QPointF w, QPoint p);

  void snapPoint(CPoint2D &p);

  void addCloseHandle(const CPoint2D &cp, const CPoint2D &p);
  void addSnapHandle (const CPoint2D &cp, const CPoint2D &p);

  void accept();

  bool cancel();

  void drawOverlay(CQIllustratorShapeDrawer *drawer);

  void drawPolygonPoints(QPainter *painter);

  QCursor getCursor() const;

  void commitPolygonPoints();

 public:
  void addPointToCurrent();
  void removePointFromCurrent();

 private:
  typedef std::vector<CPoint2D> PointList;

  CQIllustratorCreatePolygonToolbar  *toolbar_;
  CQIllustratorCreatePolygonSizer    *sizer_;
  std::vector<CQIllustratorHandle *>  closeHandles_;
  uint                                closeHandleNum_;
  std::vector<CQIllustratorHandle *>  snapHandles_;
  uint                                snapHandleNum_;
  QPoint                              polygonStart_;
  PointList                           polygonPoints_;
};

#endif
##concat##CQIllustratorCreateRectMode.h
#ifndef CQIllustratorCreateRectMode_H
#define CQIllustratorCreateRectMode_H

#include <CQIllustratorMode.h>
#include <CQIllustratorToolbar.h>

class CQPointEdit;
class CQRealEdit;
class CQIllustrator;
class CQIllustratorControlPointHandle;
class CQIllustratorCreateRectMode;
class CQIllustratorCreateRectSizer;

class CQIllustratorCreateRectToolbar : public CQIllustratorToolbar {
  Q_OBJECT

 public:
  CQIllustratorCreateRectToolbar(CQIllustratorCreateRectMode *mode);

  const char *getTitle() const { return "Create Rect"; }

  QIcon getIcon();

  void addWidgets();

  void setSelectedShape(const CQIllustratorShape *shape);

  void setSize(const CBBox2D &bbox);

 private slots:
  void updateShape();

 private:
  CQIllustratorCreateRectMode *mode_;
  CQPointEdit                 *posEdit_;
  CQRealEdit                  *widthEdit_;
  CQRealEdit                  *heightEdit_;
  CQRealEdit                  *xRadEdit_;
  CQRealEdit                  *yRadEdit_;
};

class CQIllustratorCreateRectSizer : public CQIllustratorModeSizer {
 public:
  CQIllustratorCreateRectSizer(CQIllustratorCreateRectMode *mode);

  void drawHandles(QPainter *painter, const CQIllustratorShape *shape);

 private:
  CQIllustratorControlPointHandle *ll_handle_;
  CQIllustratorControlPointHandle *ur_handle_;
  CQIllustratorControlPointHandle *rx_handle_;
  CQIllustratorControlPointHandle *ry_handle_;
};

class CQIllustratorCreateRectMode : public CQIllustratorMode {
  Q_OBJECT

 public:
  CQIllustratorCreateRectMode(CQIllustrator *illustrator);

  const char *getTitle() const { return "Create Rectangle"; }

  CQIllustratorCreateRectToolbar *getToolbar() { return toolbar_; }

  CQIllustratorCreateRectToolbar *createToolbar();

  CQIllustratorCreateRectSizer *createSizer();

  CQMenuItem *createMenuItem(CQMenu *menu);

  bool isCreateMode() const { return true; }

  CQIllustratorCreateRectToolbar *getToolbar() const { return toolbar_; }

  void handleMouseRelease(const MouseEvent &e);
  void handleMouseDrag   (const MouseEvent &e);

  void drawOverlay(CQIllustratorShapeDrawer *drawer);

 private:
  CQIllustratorCreateRectToolbar *toolbar_;
  CQIllustratorCreateRectSizer   *sizer_;
  bool                            equalSize_;
};

#endif
##concat##CQIllustratorCreateStarMode.h
#ifndef CQIllustratorCreateStarMode_H
#define CQIllustratorCreateStarMode_H

#include <CQIllustratorMode.h>
#include <CQIllustratorToolbar.h>

#include <QComboBox>
#include <QSpinBox>

class CQImageButton;
class CQPointEdit;
class CQRealEdit;
class CQAngleSpinBox;
class CQIllustrator;
class CQIllustratorControlPointHandle;
class CQIllustratorCreateStarMode;
class CQIllustratorCreateStarSizer;

class CQIllustratorCreateStarToolbar : public CQIllustratorToolbar {
  Q_OBJECT

 public:
  enum CreateMode {
    CREATE_STAR_MODE,
    CREATE_POLY_MODE
  };

 public:
  CQIllustratorCreateStarToolbar(CQIllustratorCreateStarMode *mode);

  const char *getTitle() const { return "Create Star"; }

  QIcon getIcon();

  void addWidgets();

  CreateMode getCreateMode() const { return createMode_; }

  void setSelectedShape(const CQIllustratorShape *shape);

  void setSize(const CBBox2D &bbox);

 private slots:
  void starModeSlot(bool);
  void polyModeSlot(bool);

  void updateShape();

 private:
  CQIllustratorCreateStarMode *mode_;
  CreateMode                   createMode_;
  CQImageButton               *starButton_;
  CQImageButton               *polyButton_;
  CQPointEdit                 *centerEdit_;
  QSpinBox                    *numEdit_;
  CQRealEdit                  *radius1Edit_;
  CQRealEdit                  *radius2Edit_;
  CQAngleSpinBox              *angle1Edit_;
  CQAngleSpinBox              *angle2Edit_;
};

class CQIllustratorCreateStarSizer : public CQIllustratorModeSizer {
 public:
  CQIllustratorCreateStarSizer(CQIllustratorCreateStarMode *mode);

  void drawHandles(QPainter *painter, const CQIllustratorShape *shape);

 private:
  CQIllustratorControlPointHandle *c_handle_;
  CQIllustratorControlPointHandle *ir_handle_;
  CQIllustratorControlPointHandle *or_handle_;
};

class CQIllustratorCreateStarMode : public CQIllustratorMode {
  Q_OBJECT

 public:
  CQIllustratorCreateStarMode(CQIllustrator *illustrator);

  const char *getTitle() const { return "Create Star"; }

  CQIllustratorCreateStarToolbar *getToolbar() { return toolbar_; }

  CQIllustratorCreateStarToolbar *createToolbar();

  CQIllustratorCreateStarSizer *createSizer();

  CQMenuItem *createMenuItem(CQMenu *menu);

  bool isCreateMode() const { return true; }

  CQIllustratorCreateStarToolbar *getToolbar() const { return toolbar_; }

  void handleMouseRelease(const MouseEvent &e);
  void handleMouseDrag   (const MouseEvent &e);

  void drawOverlay(CQIllustratorShapeDrawer *drawer);

 private:
  CQIllustratorCreateStarToolbar *toolbar_;
  CQIllustratorCreateStarSizer   *sizer_;
};

#endif
##concat##CQIllustratorCreateTextMode.h
#ifndef CQIllustratorCreateTextMode_H
#define CQIllustratorCreateTextMode_H

#include <CQIllustratorMode.h>
#include <CQIllustratorToolbar.h>

class QFontComboBox;
class QComboBox;
class CQRealEdit;
class QLineEdit;
class CQImageButton;
class CQIllustrator;
class CQIllustratorControlPointHandle;
class CQIllustratorCreateTextMode;
class CQIllustratorCreateTextSizer;

class CQIllustratorCreateTextToolbar : public CQIllustratorToolbar {
  Q_OBJECT

 public:
  CQIllustratorCreateTextToolbar(CQIllustratorCreateTextMode *createTextMode);

  const char *getTitle() const { return "Create Text"; }

  QFont getFont() const { return qfont_; }

  QIcon getIcon();

  void addWidgets();

  void setSelectedShape(const CQIllustratorShape *shape);

  void setSize(const CBBox2D &bbox);

 private:
  void updateWidgets();
  void updateFontWidgets();
  void updateFontFromWidgets();

 private slots:
  void updateShape();

  void fontComboSlot();
  void sizeComboSlot();
  void boldSlot();
  void italicSlot();

  void lalignSlot();
  void hcalignSlot();
  void ralignSlot();

  void talignSlot();
  void vcalignSlot();
  void balignSlot();

 private:
  CQIllustratorCreateTextMode *mode_;
  QFont                        qfont_;
  int                          font_ind_;
  int                          font_size_;
  CHAlignType                  halign_;
  CVAlignType                  valign_;
  QFontComboBox               *fontCombo_;
  QComboBox                   *sizeCombo_;
  CQImageButton               *boldButton_;
  CQImageButton               *italicButton_;
  QLineEdit                   *textEdit_;
  CQRealEdit                  *widthEdit_;
  CQRealEdit                  *heightEdit_;
  CQImageButton               *lalignButton_;
  CQImageButton               *hcalignButton_;
  CQImageButton               *ralignButton_;
  CQImageButton               *talignButton_;
  CQImageButton               *vcalignButton_;
  CQImageButton               *balignButton_;
};

class CQIllustratorCreateTextSizer : public CQIllustratorModeSizer {
 public:
  CQIllustratorCreateTextSizer(CQIllustratorCreateTextMode *mode);

  void drawHandles(QPainter *painter, const CQIllustratorShape *shape);

 private:
  CQIllustratorControlPointHandle *ll_handle_;
  CQIllustratorControlPointHandle *ur_handle_;
};

class CQIllustratorCreateTextMode : public CQIllustratorMode {
  Q_OBJECT

 public:
  CQIllustratorCreateTextMode(CQIllustrator *illustrator);

  const char *getTitle() const { return "Create Text"; }

  CQIllustratorCreateTextToolbar *getToolbar() { return toolbar_; }

  CQIllustratorCreateTextToolbar *createToolbar();

  CQIllustratorCreateTextSizer *createSizer();

  CQMenuItem *createMenuItem(CQMenu *menu);

  bool isCreateMode() const { return true; }

  CQIllustratorCreateTextToolbar *getToolbar() const { return toolbar_; }

  void handleMouseRelease(const MouseEvent &e);
  void handleMouseDrag   (const MouseEvent &e);

  bool handleKeyPress(const KeyEvent &e);

  void drawOverlay(CQIllustratorShapeDrawer *drawer);

  const QString &getText() const { return text_; }

  void setText(const QString &text);

 private:
  CQIllustratorCreateTextToolbar *toolbar_;
  CQIllustratorCreateTextSizer   *sizer_;
  bool                            equalSize_;
  QString                         text_;
  int                             cursor_pos_;
};

#endif
##concat##CQIllustratorData.h
#ifndef CQIllustratorData_H
#define CQIllustratorData_H

#include <QObject>

#include <CStack.h>
#include <CBBox2D.h>
#include <CQuadTree.h>

class CQIllustrator;
class CQIllustratorShape;

class CQIllustratorData : public QObject {
  Q_OBJECT

 public:
  enum ChangeType {
    CHANGE_NAME,
    CHANGE_GEOMETRY,
    CHANGE_STROKE,
    CHANGE_FILL,
    CHANGE_FONT,
    CHANGE_GENERIC
  };

  typedef CStack<CQIllustratorShape>            ShapeStack;
  typedef std::vector<CQIllustratorShape *>     ShapeList;
  typedef CQuadTree<CQIllustratorShape,CBBox2D> QuadTree;

 public:
  CQIllustratorData(CQIllustrator *illustrator);
 ~CQIllustratorData();

  const ShapeStack &getShapes() const { return shapes_; }

  const QuadTree *getQuadTree() const { return quadTree_; }

  void raiseShape(CQIllustratorShape *shape);
  void lowerShape(CQIllustratorShape *shape);

  void addShape(CQIllustratorShape *shape);

  void removeShape(CQIllustratorShape *shape);

  void checkoutShape(CQIllustratorShape *shape, ChangeType changeType);
  void checkinShape (CQIllustratorShape *shape, ChangeType changeType);

  void getObjectsAt(const CPoint2D &p, ShapeList &shapes) const;

  CQIllustratorShape *getObjectAt(const CPoint2D &p) const;

  void getObjectsInside(const CBBox2D &bbox, ShapeList &shapes);

  void getObjectsTouching(const CBBox2D &bbox, ShapeList &shapes);

  void getOrderedObjectsTouching(const CBBox2D &bbox, ShapeList &shapes);

 signals:
  void objectCreated(CQIllustratorShape *shape);
  void objectDeleted(CQIllustratorShape *shape);

  void objectPreModify (CQIllustratorShape *shape, ChangeType changeType);
  void objectPostModify(CQIllustratorShape *shape, ChangeType changeType);

 private:
  CQIllustrator *illustrator_;
  ShapeStack     shapes_;
  QuadTree      *quadTree_;
};

#endif
##concat##CQIllustrator.h
#ifndef CQILLUSTRATOR_H
#define CQILLUSTRATOR_H

#include <CQMainWindow.h>
#include <CAutoPtr.h>
#include <CPoint2D.h>
#include <CImageLib.h>
#include <CEvent.h>
#include <CBooleanOp.h>

#include <CStack.h>

class CQIllustrator;
class CQIllustratorCanvas;
class CQIllustratorToolbar;

class CQMenu;
class CQMenuItem;
class CQToolBar;
class CQColorChooser;
class CQStrokeOptionTool;
class CQFillOptionTool;
//class CQFontOptionTool;
class CQObjectOptionTool;
class CQLayerOptionTool;
class CQPropertiesOptionTool;
class CQIllustratorAlignToolbar;
class CQIllustratorTranformToolbar;
class CQIllustratorLayerStack;
class CQIllustratorUndoDock;
class CQIllustratorPreferenceDock;
class CQIllustratorSnapDock;

class QLabel;
class QLineEdit;
class QStackedWidget;

class CSVGObject;

class CQIllustrator;
class CQIllustratorCmd;
class CQIllustratorCmdMgr;

#include <CQIllustratorSaveData.h>
#include <CQIllustratorMode.h>
#include <CQIllustratorSelection.h>
#include <CQIllustratorUndo.h>
#include <CQIllustratorSandbox.h>
#include <CQIllustratorShapeDrawer.h>
#include <CQIllustratorLayer.h>
#include <CQIllustratorShape.h>

class CQIllustratorGrid {
 public:
  CQIllustratorGrid() :
   enabled_(false), origin_(0,0), dx_(10), dy_(10) {
  }

  bool getEnabled() const { return enabled_; }
  void setEnabled(bool enabled) { enabled_ = enabled; }

  void draw(CQIllustratorShapeDrawer *drawer, const CBBox2D &bbox);

 private:
  bool     enabled_;
  CPoint2D origin_;
  double   dx_, dy_;
};

class CQIllustratorSnap {
 public:
  CQIllustratorSnap() :
   enabled_(false), xpitch_(1), ypitch_(1) {
  }

  bool getEnabled() const { return enabled_; }
  void setEnabled(bool enabled) { enabled_ = enabled; }

  double getXPitch() const { return xpitch_; }
  void setXPitch(double xpitch) { xpitch_ = xpitch; }

  double getYPitch() const { return ypitch_; }
  void setYPitch(double ypitch) { ypitch_ = ypitch; }

  CPoint2D snapPoint(const CPoint2D &point) const;

 private:
  bool   enabled_;
  double xpitch_, ypitch_;
};

class CQIllustrator : public CQMainWindow {
  Q_OBJECT

 public:
  enum Mode {
    MODE_SELECT,
    MODE_POINT_SELECT,
    MODE_RECT,
    MODE_ELLIPSE,
    MODE_POLYGON,
    MODE_PATH,
    MODE_STAR,
    MODE_TEXT,
    MODE_LGRADIENT,
    MODE_RGRADIENT,
    MODE_IMAGE,
    MODE_ZOOM,
    MODE_SLICE,
    MODE_PAN,
    MODE_ALIGN,
    MODE_TRANSFORM,
    MODE_ANCHOR_OBJECT,
    MODE_ANCHOR_POSITION,
    MODE_OFFSET_PATH
  };

  enum AlignSide {
    ALIGN_LEFT,
    ALIGN_BOTTOM,
    ALIGN_RIGHT,
    ALIGN_TOP,
    ALIGN_HORIZONTAL,
    ALIGN_VERTICAL
  };

  class PreviewObject {
   public:
    PreviewObject() { }

    virtual ~PreviewObject() { }

    virtual void draw(CQIllustrator *illustrator, QPainter *painter) const = 0;
  };

  class PreviewShape : public PreviewObject {
   private:
    CQIllustratorShape *shape_;
    CPoint2D            d_;

   public:
    PreviewShape(CQIllustratorShape *shape, const CPoint2D &d) :
     shape_(shape), d_(d) {
    }

    const CBBox2D &getBBox() const;

    void draw(CQIllustrator *illustrator, QPainter *painter) const;
  };

  class PreviewLine : public PreviewObject {
   private:
    CPoint2D p1_, p2_;

   public:
    PreviewLine(const CPoint2D &p1, const CPoint2D &p2) :
     p1_(p1), p2_(p2) {
    }

    void draw(CQIllustrator *illustrator, QPainter *painter) const;
  };

  typedef CQIllustratorMode::MouseEvent MouseEvent;
  typedef CQIllustratorMode::KeyEvent   KeyEvent;
  typedef std::vector<PreviewObject *>  PreviewObjectList;

 public:
  CQIllustrator();
 ~CQIllustrator();

  void addMode(CQIllustratorMode *mode);

  CQIllustratorMode *getMode(Mode id) const;

  QWidget *createCentralWidget();

  CQIllustratorShapeDrawer *getDrawer() const { return drawer_; }

  void initTerm();
  void createWorkspace();
  void createMenus();
  void createToolBars();
  void createStatusBar();
  void createDockWindows();

  void emitFillChanged();

  void addModeToolbar(CQIllustratorMode *mode, CQIllustratorToolbar *toolbar);

  void updateTitle();

  void resizeCanvas(int w, int h);

  void mousePress  (const MouseEvent &e);
  void mouseRelease(const MouseEvent &e);
  void mouseDrag   (const MouseEvent &e);
  void mouseMove   (const MouseEvent &e);

  void keyPress(const KeyEvent &e);

  bool getFlipY() const { return flip_y_; }

  void setFlipY(bool flip);

  const CQIllustratorData::ShapeStack &getShapes() const;

  const CQIllustratorSelectedShapes *getSelection() const { return selection_; }

  CQIllustratorSelectedShapes *getSelection() { return selection_; }

  void setLayer(const std::string &name);

  void checkoutShape(CQIllustratorShape *shape, CQIllustratorData::ChangeType changeType);
  void checkinShape (CQIllustratorShape *shape, CQIllustratorData::ChangeType changeType);

#if 0
  uint getNumSelected() const;

  CQIllustratorSelectedShapes::iterator getSelectionBegin();
  CQIllustratorSelectedShapes::iterator getSelectionEnd();

  CQIllustratorSelectedShapes::const_iterator getSelectionBegin() const;
  CQIllustratorSelectedShapes::const_iterator getSelectionEnd() const;

  CQIllustratorSelectedShape &getSelectionFront();

  const CQIllustratorSelectedShape &getSelectionFront() const;
#endif

  void moveSelectedShapes  (const CPoint2D &d);
  void moveSelectedPoints  (const CPoint2D &d);
  void resizeSelectedShapes(const CBBox2D  &d);

  void deleteSelectedShapes();
  void deleteSelectedPoints();

  CQIllustratorShape *selectAt(const CPoint2D &p, bool add=false, bool remove=false);

  void selectIn(const CBBox2D &bbox, bool add=false, bool remove=false);

  void selectOverlap(const CBBox2D &bbox, bool add=false, bool remove=false);

  void selectPointAt(const CPoint2D &p, CQIllustratorShape::ControlType type,
                     bool add=false, bool remove=false);

  void selectPointAt(CQIllustratorShape *shape, const CPoint2D &p,
                     CQIllustratorShape::ControlType type,
                     bool add=false, bool remove=false);

  void selectPointsIn(const CBBox2D &bbox, CQIllustratorShape::ControlType type,
                      bool add=false, bool remove=false);

  void selectLinesIn(const CBBox2D &bbox, bool add=false, bool remove=false);

  CQIllustratorShape *getObjectAt(const CPoint2D &p) const;

  void cyclePrev();
  void cycleNext();

  void zoomIn();
  void zoomOut();

  void zoomFull();
  void zoomFit();
  void zoomSelected();

  CBBox2D getFitBBox() const;

  void setMode(Mode mode);

  void setCursor(QCursor cursor);

  bool getDimmed() const { return dimmed_; }
  void setDimmed(bool dimmed);

  void clearSelection();

  void setSelectShape(const std::string &name);

  void setSelectShape(CQIllustratorShape *shape);

  void addSelectShape(CQIllustratorShape *shape);

  void removeSelectShape(CQIllustratorShape *shape);

  void removeShapeFromSelection(CQIllustratorShape *shape);

  CQIllustratorShape *getShape(const std::string &name) const;
  CQIllustratorShape *getShape(uint id) const;

  void draw(QPainter *painter);

  void dimQImage(const QImage &qimage, QImage &dim_qimage);

  void drawContents(QPainter *painter);

  void drawOverlay(QPainter *painter);

  void drawQuadTree(QPainter *painter);
  void drawQuadTree(QPainter *painter, const CQIllustratorData::QuadTree *tree, uint max_num);

  void setDefaultStroke(const CQIllustratorShapeStroke &stroke);
  void setDefaultFill(const CQIllustratorShapeFill &fill);

  const CQIllustratorShapeStroke &getDefaultStroke() const;
  const CQIllustratorShapeFill   &getDefaultFill() const;

  void acceptMode();
  void cancelMode();

  const CBBox2D &getBBox() const { return bbox_; }

  void setBBox(const CBBox2D &bbox);

  const CBBox2D &getFullBBox() const { return fullBBox_; }

  void setFullBBox(const CBBox2D &bbox);

  CQIllustratorCanvas *getCanvas() const { return canvas_; }

  const QTransform &getTransform () const;
  const QTransform &getITransform() const;

  CQIllustratorLayerStack &getLayerStack() { return *layerStack_; }

  CQIllustratorData *getData() const;

  CQIllustratorUndo *getUndo() const { return undo_; }

  CQIllustratorSandbox *getSandbox() const { return sandbox_; }

  const CRGBA &getBackground() const { return bg_; }

  void setBackground(const CRGBA &bg);

  void showConsole();

  void setCanvasFocus();

  void loadFile(const QString &filename);

  void loadSVG(const QString &filename);
  void loadPS (const QString &filename);

  void saveSVG(const QString &filename);
  void saveCmd(const QString &filename);

  CQIllustratorShape *addSVGObject(CSVGObject *parent, CSVGObject *object);

  void addShape(CQIllustratorShape *shape);

  void removeShape(CQIllustratorShape *shape);

  //QFont getCurrentFont() const;

  CQIllustratorAlignToolbar *getAlignToolbar() const;

  void selectAll();
  void selectNone();

  void addCommand(CQIllustratorCmd *cmd);

  bool loadCmd(const std::string &filename);

  bool execCommand(const std::string &cmd);

  void offsetPath(double o);
  void strokePath(double d);

  void toCurve();
  void flatten();

  void geomOp(CBooleanOp op);

  void intersectOp(CBooleanOp op, bool split=false, bool keepOld=false);

  void addLayer();

  void clearPreviewObjects();
  void addPreviewObject(PreviewObject *object);
  void drawPreviewObjects(QPainter *painter);

  void addLinearGradient(const CPoint2D &p1, const CPoint2D &p2);
  void addRadialGradient(const CPoint2D &p1, const CPoint2D &p2);

  void setStroke(QPainter *painter, CQIllustratorShape *shape,
                 const CQIllustratorShapeStroke &stroke);
  void setStroke(QPainter *painter, const CQIllustratorShape *shape,
                 const CQIllustratorShapeStroke &stroke);

  void setFill(QPainter *painter, CQIllustratorShape *shape,
               const CQIllustratorShapeFill &fill, const CBBox2D &bbox);
  void setFill(QPainter *painter, const CQIllustratorShape *shape,
               const CQIllustratorShapeFill &fill, const CBBox2D &bbox);

  void redrawOverlay();

  bool isInUndoGroup() const;

  void startUndoGroup(const std::string &str);
  void endUndoGroup();

  void setDeltaLabel(const QString &title, const QString &str);

  //------

  bool getSnapEnabled() const { return snap_.getEnabled(); }
  void setSnapEnabled(bool enabled) { snap_.setEnabled(enabled); }

  double getSnapXPitch() const { return snap_.getXPitch(); }
  void setSnapXPitch(double xpitch) { snap_.setXPitch(xpitch); }

  double getSnapYPitch() const { return snap_.getYPitch(); }
  void setSnapYPitch(double ypitch) { snap_.setYPitch(ypitch); }

  CPoint2D snapPoint(const CPoint2D &point) const { return snap_.snapPoint(point); }

  CQIllustratorCmdMgr *getCmdMgr() const { return cmdMgr_; }

 signals:
  void selectionChanged();

  void fillChanged();

  void fullBBoxChanged();

 public slots:
  void cancelAnchorSlot();

 private slots:
  void selectionChangedSlot();

  void layerChangedSlot();
  void layersModifiedSlot();

  void selectAllSlot();
  void selectNoneSlot();
  void groupSlot();
  void ungroupSlot();
  void copySlot();
  void deleteSlot();
  void raiseSlot();
  void lowerSlot();
  void flipXSlot();
  void flipYSlot();
  void lockSlot();
  void unlockSlot();

  void copyStrokeSlot();
  void pasteStrokeSlot();

  void anchorObjectSlot();
  void anchorPositionSlot();

  void loadFileSlot();
  void saveSVGSlot();
  void saveCmdSlot();

  void snapShotSlot();

  void undoSlot();
  void redoSlot();
  void undoChangedSlot();

  void addLayerSlot();

  void zoomFullSlot();
  void zoomFitSlot();
  void zoomSelSlot();

  void gridSlot();

  void flipViewSlot(bool);

  void toPolygonSlot();
  void toPathSlot();

  void offsetPathSlot();
  void strokePathSlot();

  void geomAndSlot();
  void geomOrSlot();
  void geomXorSlot();
  void geomNotSlot();

  void toCurveSlot();
  void flattenSlot();

  void intersectOrSlot();
  void intersectAndSlot();
  void intersectXor1Slot();
  void intersectXor2Slot();

  void triangulateSlot();
  void giftWrapSlot();
  void delaunaySlot();

  void combineSlot();

  void aboutSlot();

  void consoleExecSlot();

  void strokeSlot(const CQIllustratorShapeStroke &);
  void fillSlot(const CQIllustratorShapeFill &);
  void clipSlot(bool clip);
//void fontSlot(const QFont &font);
  void objectSlot(const QString &);
  void propSlot();

  void setShapeSVGStrokeAndFill(CQIllustratorShape *shape, CSVGObject *object);

  void setSVGShapeName(CQIllustratorShape *shape, CSVGObject *object);

  void setShapeName(CQIllustratorShape *shape);

 public:
  CQIllustratorRectShape    *createRectShape(const CPoint2D &p1, const CPoint2D &p2,
                                             double rx=0.0, double ry=0.0);
  CQIllustratorEllipseShape *createEllipseShape(const CPoint2D &p1, const CPoint2D &p2);
  CQIllustratorPolygonShape *createPolygonShape(const std::vector<CPoint2D> &points=
                                                 std::vector<CPoint2D>());
  CPathShape                *createPathShape();
  CQIllustratorTextShape    *createTextShape(const CPoint2D &p1, const CPoint2D &p2,
                                             const std::string &str);
  CQIllustratorNPolyShape   *createNPolyShape(const CPoint2D &c, uint n, double r, double a);
  CQIllustratorStarShape    *createStarShape(const CPoint2D &c, uint n, double r1, double r2,
                                             double a1, double a2);
  CQIllustratorGroupShape   *createGroupShape();

 public slots:
  void redraw();

 private:
  typedef std::map<Mode,CQIllustratorMode *> ModeMap;

  CQIllustratorCanvas               *canvas_;

  // Menu and Toolbar
  CQMenu                            *fileMenu_;
  CQMenu                            *createMenu_;
  CQMenu                            *modeMenu_;
  CQMenu                            *pathMenu_;
  CQMenu                            *selectMenu_;
  CQMenu                            *editMenu_;
  CQMenuItem                        *undoItem_;
  CQMenuItem                        *redoItem_;
  CQMenu                            *layerMenu_;
  CQMenuItem                        *addLayerItem_;
  CQMenu                            *viewMenu_;
  CQMenu                            *helpMenu_;
  CQToolBar                         *modeToolBar_;
  CQToolBar                         *pathModeToolBar_;
  CQToolBar                         *selectToolBar_;
  CQToolBar                         *editToolBar_;
  CQToolBar                         *layerToolBar_;
  CQToolBar                         *mouseToolToolBar_;
  QStackedWidget                    *mouseToolStack_;
  CQToolBar                         *toolsToolBar_;
  CQToolBar                         *consoleToolBar_;
  CQMenuItem                        *alignItem_;
  CQMenuItem                        *groupItem_;
  CQMenuItem                        *ungroupItem_;
  CQMenuItem                        *copyItem_;
  CQMenuItem                        *deleteItem_;
  CQMenuItem                        *raiseItem_;
  CQMenuItem                        *lowerItem_;
  CQMenuItem                        *flipXItem_;
  CQMenuItem                        *flipYItem_;
  CQMenuItem                        *lockItem_;
  CQMenuItem                        *unlockItem_;
  CQMenuItem                        *copyStroke_;
  CQMenuItem                        *pasteStroke_;
  CQMenuItem                        *selectAllItem_;
  CQMenuItem                        *selectNoneItem_;
  CQMenuItem                        *flipViewItem_;

  // Tools
  CQStrokeOptionTool                *strokeTool_;
  CQFillOptionTool                  *fillTool_;
//CQFontOptionTool                  *fontTool_;
  CQObjectOptionTool                *objectTool_;
  CQLayerOptionTool                 *layerTool_;
  CQPropertiesOptionTool            *propTool_;

  // Dock Widgets
  CQIllustratorUndoDock             *undoDock_;
  CQIllustratorPreferenceDock       *preferenceDock_;
  CQIllustratorSnapDock             *snapDock_;

  // Console
  QLineEdit                         *consoleEdit_;
  QAction                           *consoleAction_;

  // Status Labels
  QLabel                            *modeLabel_;
  QLabel                            *selLabel_;
  QLabel                            *posLabel_;
  QLabel                            *deltaLabel_;

  // Current File
  QString                            fileName_;
  CFileType                          fileType_;

  bool                               flip_y_;
  bool                               changed_;
  bool                               escape_;
  QImage                             qimage_;
  QImage                             dim_qimage_;
  bool                               dimmed_;
  bool                               dim_valid_;
  bool                               quad_tree_;
  CAutoPtr<CQIllustratorShapeDrawer> drawer_;
  Mode                               mode_;
  ModeMap                            modeMap_;
  CQIllustratorMode                 *currentMode_;
  CQIllustratorLayerStack           *layerStack_;
  CBBox2D                            fullBBox_;
  CBBox2D                            bbox_;
  CAutoPtr<CQIllustratorUndo>        undo_;
  CAutoPtr<CQIllustratorSandbox>     sandbox_;
  CRGBA                              bg_;
  CQIllustratorSelectedShapes       *selection_;
  PreviewObjectList                  previewObjects_;
  QPointF                            press_wpos_;
  QPoint                             current_ppos_;
  CQIllustratorGrid                  grid_;
  CQIllustratorSnap                  snap_;
  CQIllustratorCmdMgr               *cmdMgr_;
  CQIllustratorShapeStroke           def_stroke_;
  CQIllustratorShapeFill             def_fill_;
  CQIllustratorShapeStroke           save_stroke_;
  CQIllustratorShapeFill             save_fill_;
};

namespace CQIllustratorUtil {
  template<typename T>
  T *getCurrentShape(CQIllustrator *illustrator) {
    T *shape = 0;

    CQIllustratorSelectedShapes *selection = illustrator->getSelection();

    CQIllustratorSelectedShapes::iterator ps1, ps2;

    for (ps1 = selection->begin(), ps2 = selection->end(); ps1 != ps2; ++ps1) {
      CQIllustratorShape *shape1 = (*ps1).getShape();

      T *tshape = dynamic_cast<T *>(shape1);

      if (tshape == 0) continue;

      if (shape == 0)
        shape = tshape;
      else
        break;
    }

    return shape;
  }
}

#endif
##concat##CQIllustratorHandle.h
#ifndef CQIllustratorHandle_H
#define CQIllustratorHandle_H

#include <QPointF>
#include <CPoint2D.h>
#include <CISize2D.h>
#include <CImagePtr.h>

class CQIllustrator;
class QPainter;
class CQIllustratorShape;
class CQIllustratorShapeControlPoint;
class CQIllustratorShapeStroke;

class CQIllustratorHandle {
 public:
  // use CSymbol2D for more symbols
  enum Style {
    IMAGE_STYLE,
    RECT_STYLE,
    CIRCLE_STYLE
  };

 public:
  CQIllustratorHandle(CQIllustrator *illustrator);

  virtual ~CQIllustratorHandle() { }

  void setImage(const char **strings, uint num_strings,
                const char **active_strings=0, uint num_active_strings=0);

  void setStyle(Style style);

  virtual CISize2D getSize();

  bool getActive() const { return active_; }

  bool getVisible() const { return visible_; }

  void setVisible(bool visible) { visible_ = visible; }

  const CPoint2D &getPosition() const { return pos_; }

  void setPosition(const CPoint2D &pos);

  bool updateActive(const QPointF &p);

  virtual void draw(QPainter *painter, const CPoint2D &point, const CIPoint2D &offset);
  virtual void draw(QPainter *painter, const CPoint2D &point);
  virtual void draw(QPainter *painter);

 private:
  void drawI(QPainter *painter);

 protected:
  CQIllustrator *illustrator_;
  Style          style_;
  bool           active_;
  bool           visible_;
  CPoint2D       pos_;
  CIPoint2D      offset_;
  CImagePtr      image_;
  CImagePtr      active_image_;
};

class CQIllustratorControlPointHandle : public CQIllustratorHandle {
 public:
  CQIllustratorControlPointHandle(CQIllustrator *illustrator);

 ~CQIllustratorControlPointHandle();

  // draw control point (and assign current point for handle)
  // Note: can't save shape here as this is a 'const' shape (not checked out)
  void draw(const CQIllustratorShape *shape, CQIllustratorShapeControlPoint *point,
            QPainter *painter);

  // update point on 'checked out' shape
  void updatePoint(CQIllustratorShape *shape, const CPoint2D &point);

 private:
  CQIllustratorShapeControlPoint *point_;
};

#endif
##concat##CQIllustratorInfo.h
#include <QWidget>

class QLabel;
class CQIllustratorCanvas;
class CQIllustratorShape;

class CQIllustratorInfo : public QWidget {
  Q_OBJECT

 public:
  CQIllustratorInfo(CQIllustratorCanvas *canvas);

  void setShape(const CQIllustratorShape *shape);

 private:
  CQIllustratorCanvas *canvas_;
  QLabel              *label_;
};
##concat##CQIllustratorInfoTip.h
#ifndef CQIllustratorInfoTip_H
#define CQIllustratorInfoTip_H

class CQIllustratorInfoTip : public QWidget {
};

#endif
##concat##CQIllustratorLayer.h
#ifndef CQIllustratorLayer_H
#define CQIllustratorLayer_H

#include <map>
#include <list>

#include <QObject>
#include <CQIllustratorData.h>

class CQIllustrator;
class CQIllustratorShape;
class CQIllustratorLayerStack;

class CQIllustratorLayer : public QObject {
  Q_OBJECT

 public:
  typedef CQIllustratorData::ChangeType ChangeType;

 private:
  CQIllustratorLayer(CQIllustratorLayerStack *stack, uint id);
 ~CQIllustratorLayer();

  friend class CQIllustratorLayerStack;

 public:
  const std::string &getName() const { return name_; }

  CQIllustratorData *getData() const { return data_; }

  void setName(const std::string &name);

 signals:
  void objectPostModify(CQIllustratorShape *, ChangeType);

 private:
  CQIllustratorLayerStack *stack_;
  uint                     id_;
  std::string              name_;
  CQIllustratorData       *data_;
};

class CQIllustratorLayerStack : public QObject {
  Q_OBJECT

 public:
  typedef CQIllustratorData::ChangeType ChangeType;
  typedef std::list<uint>               LayerStack;

 public:
  CQIllustratorLayerStack(CQIllustrator *illustrator);

  CQIllustrator *getIllustrator() { return illustrator_; }

  const LayerStack &getLayerStack() const { return layerStack_; }

  uint getCurrent() const;

  CQIllustratorLayer *getCurrentLayer() const;

  CQIllustratorData *getCurrentData() const;

  uint addLayer(const std::string &name="");

  void deleteLayer(uint id);

  CQIllustratorLayer *getLayer(uint id) const;

  void setLayer(const std::string &name);

 signals:
  void objectPostModify(CQIllustratorShape *, ChangeType);

  void layerChanged();

  void layersModified();

 private:
  typedef std::map<uint,CQIllustratorLayer *> LayerMap;

  CQIllustrator *illustrator_;
  uint           id_;
  uint           current_;
  LayerMap       layerMap_;
  LayerStack     layerStack_;
};

#endif
##concat##CQIllustratorMode.h
#ifndef CQILLUSTRATOR_MODE_H
#define CQILLUSTRATOR_MODE_H

#include <QObject>
#include <QPoint>
#include <QCursor>
#include <QTransform>
#include <CEvent.h>
#include <CPoint2D.h>
#include <CBBox2D.h>

#include <CQIllustratorData.h>
#include <CQIllustratorShape.h>

class QMouseEvent;
class QKeyEvent;
class QStackedWidget;
class CQMenu;
class CQMenuItem;

class CQIllustrator;
class CQIllustratorShapeDrawer;
class CQIllustratorToolbar;
class CQIllustratorModeSizer;
class CQIllustratorShape;
class CQIllustratorSelectedShape;
class CQIllustratorHandle;
class CQIllustratorControlPointHandle;

class CQIllustratorMode : public QObject {
  Q_OBJECT

 public:
  enum EditMode {
    CREATE_MODE,
    EDIT_MODE
  };

  struct MouseEvent {
    QPoint       pixel;
    QPointF      window;
    CMouseEvent *event;

    MouseEvent(QMouseEvent *event, const QTransform &transform);
  };

  struct KeyEvent {
    QPoint     pixel;
    QPointF    window;
    CKeyEvent *event;

    KeyEvent(QKeyEvent *event, const QPoint &pos, const QTransform &transform);
  };

 public:
  CQIllustratorMode(CQIllustrator *illustrator, uint id);
  CQIllustratorMode(CQIllustratorMode *parentMode, uint id);

  virtual ~CQIllustratorMode() { }

  void init();

  virtual CQIllustratorToolbar *createToolbar() = 0;

  virtual CQIllustratorModeSizer *createSizer();

  virtual const char *getTitle() const = 0;

  CQIllustrator *getIllustrator() const { return illustrator_; }

  CQIllustratorMode *getParentMode() const { return parentMode_; }

  uint getId() const { return id_; }

  virtual CQIllustratorData::ChangeType getChangeType() const {
    return CQIllustratorData::CHANGE_GEOMETRY;
  }

  virtual CQIllustratorShape::ControlType getControlType() const {
    return CQIllustratorShape::CONTROL_GEOMETRY;
  }

  CQMenuItem *getMenuItem() const { return menuItem_; }

  virtual CQMenuItem *createMenuItem(CQMenu *menu) = 0;

  void setEditMode(EditMode mode);

  EditMode getEditMode() const { return editMode_; }

  virtual bool isCreateMode() const { return false; }
  virtual bool isSelectMode() const { return false; }

  void setStack(QStackedWidget *stack);

  virtual CQIllustratorToolbar *getToolbar() const = 0;

  void mousePress  (const MouseEvent &e);
  void mouseRelease(const MouseEvent &e);
  void mouseDrag   (const MouseEvent &e);
  void mouseMove   (const MouseEvent &e);

  bool keyPress(const KeyEvent &e);

  virtual void showToolbar(bool show);

  virtual void handleMousePress  (const MouseEvent &e);
  virtual void handleMouseRelease(const MouseEvent &e);
  virtual void handleMouseDrag   (const MouseEvent &e) = 0;
  virtual void handleMouseMove   (const MouseEvent &e);

  virtual bool handleKeyPress(const KeyEvent &);

  virtual void selectControlPoint(const MouseEvent &e);

  virtual void addSelectionToSandbox();

  virtual void moveCurrent  (const CPoint2D &d);
  virtual void resizeCurrent(const CBBox2D  &d);

  virtual void deleteCurrent();

  virtual void moveCurrentPoint(const CPoint2D &d);

  virtual void accept() { }
  virtual bool cancel();

  virtual void escape();

  virtual void drawSelection(CQIllustratorShapeDrawer *drawer);

  virtual void drawOverlay(CQIllustratorShapeDrawer *drawer);

  virtual void setSelectedShape(const CQIllustratorShape *shape);

  virtual void setSelectedShapePoint(const CQIllustratorShape *shape,
                                     const CQIllustratorShapeControlPoint *point);

  void setCursor(const uchar *bits, const uchar *mask, int xo, int yo);

  virtual QCursor getCursor() const;

 public slots:
  void menuItemSlot();

  void selectionSlot();

 protected:
  CQIllustrator          *illustrator_;
  CQIllustratorMode      *parentMode_;
  uint                    id_;
  CQIllustratorToolbar   *toolbar_;
  CQIllustratorModeSizer *sizer_;
  CQMenuItem             *menuItem_;
  EditMode                editMode_;
  QStackedWidget         *stack_;
  QCursor                 cursor_;
  bool                    pressed_;
  bool                    moving_;
  bool                    dragging_;
  QPoint                  press_ppos_;
  QPointF                 press_wpos_;
  QPoint                  prev_ppos_;
  QPointF                 prev_wpos_;
  QPoint                  curr_ppos_;
  QPointF                 curr_wpos_;
  QPoint                  release_ppos_;
  QPointF                 release_wpos_;
};

class CQIllustratorModeSizer : public QObject {
  Q_OBJECT

 public:
  typedef CQIllustratorMode::KeyEvent KeyEvent;

 public:
  CQIllustratorModeSizer(CQIllustratorMode *mode);

  virtual ~CQIllustratorModeSizer() { }

  virtual void addHandle(CQIllustratorControlPointHandle *handle);

  virtual void addHandle(CQIllustratorHandle *handle);

  virtual void removeHandle(CQIllustratorControlPointHandle *);

  virtual void removeHandle(CQIllustratorHandle *);

  virtual void draw(QPainter *painter, const CQIllustratorShape *shape);

  virtual void drawHandles(QPainter *painter, const CQIllustratorShape *shape);

  virtual void drawSelectionHandles(QPainter *painter, const CQIllustratorSelectedShape &sshape);

  virtual bool updateActive(const QPointF &p);

  virtual void updatePoint(CQIllustratorShape *shape, const QPointF &p);

  virtual bool isActive() const;

  virtual void updateSelectionHandles(const CQIllustratorSelectedShape &sshape);

  virtual void updatePointSelectionHandles(uint num_handles);
  virtual void updateLineSelectionHandles(uint num_handles);

  virtual bool handleKeyPress(const KeyEvent &e);

 protected:
  typedef std::vector<CQIllustratorControlPointHandle *> ControlPointHandleList;
  typedef std::vector<CQIllustratorHandle *>             HandleList;

  CQIllustratorMode      *mode_;
  QTransform              transform_;
  ControlPointHandleList  controlPointHandles_;
  HandleList              handles_;
  HandleList              lineSelectionHandles_;
  HandleList              pointSelectionHandles_;
};

#endif
##concat##CQIllustratorOffsetPathMode.h
#ifndef CQIllustratorOffsetPathMode_H
#define CQIllustratorOffsetPathMode_H

#include <CQIllustratorMode.h>
#include <CQIllustratorToolbar.h>

class CQRealEdit;
class CQIllustrator;
class CQIllustratorHandle;
class CQIllustratorOffsetPathMode;
class CQIllustratorOffsetPathSizer;

class CQIllustratorOffsetPathToolbar : public CQIllustratorToolbar {
  Q_OBJECT

 public:
  CQIllustratorOffsetPathToolbar(CQIllustratorOffsetPathMode *mode);

  const char *getTitle() const { return "Offset Path"; }

  QIcon getIcon();

  void addWidgets();

  void setSelectedShape(const CQIllustratorShape *shape);

  void setWidth(double w);

 private slots:
  void updateShape();

 private:
  CQIllustratorOffsetPathMode *mode_;
  CQRealEdit                  *widthEdit_;
};

class CQIllustratorOffsetPathSizer : public CQIllustratorModeSizer {
 public:
  CQIllustratorOffsetPathSizer(CQIllustratorOffsetPathMode *mode);

  void setSelectedShape(CQIllustratorShape *shape);

  void updatePoint(CQIllustratorShape *shape, const QPointF &p);

  void drawHandles(QPainter *painter, const CQIllustratorShape *shape);

 private:
  CQIllustratorHandle *width_handle_;
  CQIllustratorShape  *shape_;
};

class CQIllustratorOffsetPathMode : public CQIllustratorMode {
  Q_OBJECT

 public:
  CQIllustratorOffsetPathMode(CQIllustrator *illustrator);

  const char *getTitle() const { return "Offset Path"; }

  CQIllustratorOffsetPathToolbar *getToolbar() { return toolbar_; }

  CQIllustratorOffsetPathToolbar *createToolbar();

  CQIllustratorOffsetPathSizer *createSizer();

  CQMenuItem *createMenuItem(CQMenu *menu);

  CQIllustratorOffsetPathToolbar *getToolbar() const { return toolbar_; }

  void handleMouseRelease(const MouseEvent &e);
  void handleMouseDrag   (const MouseEvent &e);

  void addSelectionToSandbox();

  void drawOverlay(CQIllustratorShapeDrawer *drawer);

  void setSelectedShape(CQIllustratorShape *shape);

  void setWidth(double w);

 private:
  CQIllustratorOffsetPathToolbar *toolbar_;
  CQIllustratorOffsetPathSizer   *sizer_;
  double                          w_;
};

#endif
##concat##CQIllustratorPanMode.h
#ifndef CQIllustratorPanMode_H
#define CQIllustratorPanMode_H

#include <CQIllustratorMode.h>
#include <CQIllustratorToolbar.h>

class CQIllustrator;
class CQIllustratorPanMode;

class CQIllustratorPanToolbar : public CQIllustratorToolbar {
  Q_OBJECT

 public:
  CQIllustratorPanToolbar(CQIllustratorPanMode *mode);

  const char *getTitle() const { return "Pan"; }

  QIcon getIcon();

 private:
  CQIllustratorPanMode *panMode_;
};

class CQIllustratorPanMode : public CQIllustratorMode {
 public:
  CQIllustratorPanMode(CQIllustrator *illustrator);

  const char *getTitle() const { return "Pan"; }

  CQIllustratorPanToolbar *createToolbar();

  CQMenuItem *createMenuItem(CQMenu *menu);

  CQIllustratorPanToolbar *getToolbar() const { return toolbar_; }

  void handleMousePress  (const MouseEvent &e);
  void handleMouseRelease(const MouseEvent &e);
  void handleMouseDrag   (const MouseEvent &e);
  void handleMouseMove   (const MouseEvent &e);

  QCursor getCursor() const;

 private:
  CQIllustratorPanToolbar *toolbar_;
};

#endif
##concat##CQIllustratorPointSelectMode.h
#ifndef CQIllustratorPointSelectMode_H
#define CQIllustratorPointSelectMode_H

#include <CQIllustratorMode.h>
#include <CQIllustratorToolbar.h>

class CQIllustratorShape;
class CQIllustratorControlPointHandle;
class CQIllustratorPointSelectMode;
class CQIllustratorPointSelectSizer;

class CQIllustratorPointSelectToolbar : public CQIllustratorToolbar {
  Q_OBJECT

 public:
  CQIllustratorPointSelectToolbar(CQIllustratorPointSelectMode *selectMode);

  const char *getTitle() const { return "Point Select"; }

  QIcon getIcon();

  void addWidgets();

  void setSelectedShape(const CQIllustratorShape *shape);

 private:
  CQIllustratorPointSelectMode *mode_;
};

class CQIllustratorPointSelectSizer : public CQIllustratorModeSizer {
 public:
  CQIllustratorPointSelectSizer(CQIllustratorPointSelectMode *mode);

  void drawHandles(QPainter *painter, const CQIllustratorShape *shape);

  void updateHandles(uint numHandles);
};

class CQIllustratorPointSelectMode : public CQIllustratorMode {
 public:
  CQIllustratorPointSelectMode(CQIllustrator *illustrator);

  CQIllustratorPointSelectToolbar *createToolbar();

  CQIllustratorPointSelectSizer *createSizer();

  const char *getTitle() const { return "Select Shape Point"; }

  CQMenuItem *createMenuItem(CQMenu *menu);

  bool isSelectMode() const { return true; }

  CQIllustratorPointSelectToolbar *getToolbar() const { return toolbar_; }

  void handleMouseRelease(const MouseEvent &e);
  void handleMouseDrag   (const MouseEvent &e);

  void drawOverlay(CQIllustratorShapeDrawer *drawer);

  QCursor getCursor() const;

 private:
  CQIllustratorPointSelectToolbar *toolbar_;
  CQIllustratorPointSelectSizer   *sizer_;
};

#endif
##concat##CQIllustratorPreference.h
#include <QWidget>

#include <string>

class CQPointEdit;

enum CQIllustratorPreferenceType {
  CQILLUSTRATOR_PREFERENCE_STRING_TYPE,
  CQILLUSTRATOR_PREFERENCE_INTEGER_TYPE,
  CQILLUSTRATOR_PREFERENCE_REAL_TYPE
};

class CQIllustrator;

class CQIllustratorPreferenceMgr {
 public:
  CQIllustratorPreferenceMgr(CQIllustrator *illustrator);

  void addStringPreference (const std::string &name, const std::string &def_value="");
  void addIntegerPreference(const std::string &name, int def_value=0);
  void addRealPreference   (const std::string &name, double def_value=0.0);
};

union CQIllustratorPreferenceValue {
  int     integer;
  double  real;
  char   *string;
};

class CQIllustratorPreference {
 public:
  CQIllustratorPreference() { }

 private:
  std::string                  name;
  CQIllustratorPreferenceType  type;
  CQIllustratorPreferenceValue value;
};

class CQIllustratorPreferenceDock : public QWidget {
  Q_OBJECT

 public:
  CQIllustratorPreferenceDock(CQIllustrator *illustrator);

 private slots:
  void syncFillBBox();
  void updateFillBBox();

 private:
  CQIllustrator *illustrator_;
  CQPointEdit   *fullMin_;
  CQPointEdit   *fullMax_;
};
##concat##CQIllustratorSandbox.h
#ifndef CQIllustratorSandbox_H
#define CQIllustratorSandbox_H

#include <vector>
#include <sys/types.h>
#include <CPoint2D.h>
#include <CBBox2D.h>
#include <CQIllustratorData.h>

class CQIllustrator;
class CQIllustratorShape;
class CQIllustratorShapeDrawer;

class CQIllustratorSandbox {
 public:
  typedef std::vector<CQIllustratorShape *> EditShapes;

  typedef EditShapes::iterator       shape_iterator;
  typedef EditShapes::const_iterator const_shape_iterator;

 public:
  CQIllustratorSandbox(CQIllustrator *illustrator);

  void addSelection();

  void addSelectionPath();

  uint getNumShapes() const { return edit_shapes_.size(); }

  CQIllustratorShape *frontShape() {
    if (! edit_shapes_.empty())
      return edit_shapes_.front();
    else
      return 0;
  }

  shape_iterator beginShape() { return edit_shapes_.begin(); }
  shape_iterator endShape  () { return edit_shapes_.end  (); }

  const_shape_iterator beginShape() const { return edit_shapes_.begin(); }
  const_shape_iterator endShape  () const { return edit_shapes_.end  (); }

  void clear();

  CBBox2D getBBox() const;

  void moveBy(const CPoint2D &d);

  void moveTo(const CPoint2D &d);

  void commit(CQIllustratorData::ChangeType changeType);

  void draw(CQIllustratorShapeDrawer *drawer);

 private:
  CQIllustrator *illustrator_;
  EditShapes     edit_shapes_;
};

#endif
##concat##CQIllustratorSaveData.h
#ifndef CQIllustratorSaveData_H
#define CQIllustratorSaveData_H

#include <CBBox2D.h>

struct CQIllustratorSaveData {
  CFile   *file;
  CBBox2D  bbox;
};

#endif
##concat##CQIllustratorSelection.h
#ifndef CQIllustratorSelection_H
#define CQIllustratorSelection_H

#include <QObject>
#include <CQIllustratorShape.h>

class CQIllustratorSelectedShape {
 protected:
  friend class CQIllustratorSelectedShapes;

  CQIllustratorSelectedShape(CQIllustratorShape *shape=0);

 public:
 ~CQIllustratorSelectedShape();

  CQIllustratorShape *getShape();

  const CQIllustratorShape *getShape() const;

  uint numPoints() const;

  const CQIllustratorShapeControlPoint *getPoint(uint i) const;

  CQIllustratorShapeControlPoint *getPoint(uint i);

  bool exists(const CQIllustratorShapeControlPoint *point) const;

  uint numLines() const;

  const CQIllustratorShapeControlLine *getLine(uint i) const;

  CQIllustratorShapeControlLine *getLine(uint i);

  bool exists(const CQIllustratorShapeControlLine *line) const;

 protected:
  void clearLines();

  void addLine(CQIllustratorShapeControlLine *line);

  void removeLine(CQIllustratorShapeControlLine *line);

  //----

  void clearPoints();

  void addPoint(CQIllustratorShapeControlPoint *point);

  void removePoint(CQIllustratorShapeControlPoint *point);

  //----

 private:
  typedef std::vector<CQIllustratorShapeControlLine  *> LineList;
  typedef std::vector<CQIllustratorShapeControlPoint *> PointList;

  CQIllustratorShape *shape_;
  LineList            lines_;
  PointList           points_;
};

class CQIllustratorSelectedShapes : public QObject {
  Q_OBJECT

 private:
  typedef std::list<CQIllustratorSelectedShape> SelectedShapes;

 public:
  typedef SelectedShapes::iterator       iterator;
  typedef SelectedShapes::const_iterator const_iterator;

 public:
  CQIllustratorSelectedShapes(CQIllustrator *illustrator);

  bool empty() const { return shapes_.empty(); }

  uint size() const { return shapes_.size(); }

  iterator begin() { return shapes_.begin(); }
  iterator end  () { return shapes_.end  (); }

  const_iterator begin() const { return shapes_.begin(); }
  const_iterator end  () const { return shapes_.end  (); }

  CQIllustratorSelectedShape &front() { return shapes_.front(); }

  const CQIllustratorSelectedShape &front() const { return shapes_.front(); }

  void clear();

  void startSelect();
  void endSelect  ();

  void add(CQIllustratorShape *shape);

  void remove(iterator i);

  bool exists(const CQIllustratorShape *shape) const;

  bool exists(const CQIllustratorShape *shape, const CQIllustratorShapeControlPoint *point) const;

  CQIllustratorSelectedShape &get(CQIllustratorShape *shape);

  CQIllustratorSelectedShape &checkoutShape(const CQIllustratorSelectedShape &sshape,
                                            CQIllustratorData::ChangeType changeType);

  void checkinShape(const CQIllustratorSelectedShape &sshape,
                    CQIllustratorData::ChangeType changeType);

  //----

  void clearShapeLines(CQIllustratorSelectedShape &shape);

  void addShapeLine(CQIllustratorSelectedShape &shape, CQIllustratorShapeControlLine *line);

  void removeShapeLine(CQIllustratorSelectedShape &shape, CQIllustratorShapeControlLine *line);

  void setShapeLine(CQIllustratorSelectedShape &shape, uint i, const CLine2D &l);

  //----

  void clearShapePoints(CQIllustratorSelectedShape &shape);

  void addShapePoint(CQIllustratorSelectedShape &shape, CQIllustratorShapeControlPoint *point);

  void removeShapePoint(CQIllustratorSelectedShape &shape, CQIllustratorShapeControlPoint *point);

 signals:
  void selectionChanged();

 private:
  CQIllustrator  *illustrator_;
  SelectedShapes  shapes_;
  bool            locked_;
};

#endif
##concat##CQIllustratorSelectMode.h
#ifndef CQIllustratorSelectMode_H
#define CQIllustratorSelectMode_H

#include <CAutoPtr.h>
#include <CQIllustratorMode.h>
#include <CQIllustratorToolbar.h>
#include <CQIllustratorSizer.h>

#include <CQIllustratorMode.h>

class CQImageButton;
class CQIllustratorSelectMode;

class CQIllustratorSelectToolbar : public CQIllustratorToolbar {
  Q_OBJECT

 public:
  CQIllustratorSelectToolbar(CQIllustratorSelectMode *mode);

  const char *getTitle() const { return "Select"; }

  QIcon getIcon();

  void addWidgets();

 private slots:
  void selectAllSlot();
  void selectNoneSlot();
  void setMode(int id);

 private:
  CQIllustratorSelectMode *mode_;
  CQImageButton           *selectAllButton_;
  CQImageButton           *selectNoneButton_;
};

class CQIllustratorSelectMode : public CQIllustratorMode {
  Q_OBJECT

 public:
  CQIllustratorSelectMode(CQIllustrator *illustrator);

  const char *getTitle() const { return "Select Shape"; }

  CQIllustratorSelectToolbar *createToolbar();

  CQMenuItem *createMenuItem(CQMenu *menu);

  bool isSelectMode() const { return true; }

  CQIllustratorSelectToolbar *getToolbar() const { return toolbar_; }

  void setInside(bool inside);

  void handleMousePress  (const MouseEvent &e);
  void handleMouseRelease(const MouseEvent &e);
  void handleMouseDrag   (const MouseEvent &e);
  void handleMouseMove   (const MouseEvent &e);

  bool handleKeyPress(const KeyEvent &e);

  void commitShapes();

  void drawOverlay(CQIllustratorShapeDrawer *drawer);

 private:
  CQIllustratorSelectToolbar   *toolbar_;
  CAutoPtr<CQIllustratorSizer>  sizer_;
  bool                          sizing_;
  CBBox2D                       drag_bbox_;
  CPoint2D                      drag_center_;
  CMatrix2D                     drag_matrix_;
  bool                          inside_;
};

#endif
##concat##CQIllustratorSetAnchorObjectMode.h
#ifndef CQIllustratorSetAnchorObjectMode_H
#define CQIllustratorSetAnchorObjectMode_H

#include <CQIllustratorMode.h>

class CQIllustratorSetAnchorObjectMode : public CQIllustratorMode {
 public:
  CQIllustratorSetAnchorObjectMode(CQIllustrator *illustrator);

  const char *getTitle() const { return "Set Anchor Object"  ; }

  CQIllustratorToolbar *createToolbar() { return 0; }

  CQMenuItem *createMenuItem(CQMenu *menu);

  CQIllustratorToolbar *getToolbar() const { return 0; }

  void handleMousePress  (const MouseEvent &e);
  void handleMouseRelease(const MouseEvent &e);
  void handleMouseDrag   (const MouseEvent &e);
  void handleMouseMove   (const MouseEvent &e);

  QCursor getCursor() const;

 private:
};

#endif
##concat##CQIllustratorSetAnchorPositionMode.h
#ifndef CQIllustratorSetAnchorPositionMode_H
#define CQIllustratorSetAnchorPositionMode_H

#include <CQIllustratorMode.h>

class CQIllustratorSetAnchorPositionMode : public CQIllustratorMode {
 public:
  CQIllustratorSetAnchorPositionMode(CQIllustrator *illustrator);

  const char *getTitle() const { return "Set Anchor Position"; }

  CQIllustratorToolbar *createToolbar() { return 0; }

  CQMenuItem *createMenuItem(CQMenu *menu);

  CQIllustratorToolbar *getToolbar() const { return 0; }

  void handleMousePress  (const MouseEvent &e);
  void handleMouseRelease(const MouseEvent &e);
  void handleMouseDrag   (const MouseEvent &e);
  void handleMouseMove   (const MouseEvent &e);

  QCursor getCursor() const;

 private:
};

#endif
##concat##CQIllustratorSetImageMode.h
#ifndef CQIllustratorSetImageMode_H
#define CQIllustratorSetImageMode_H

#include <CAutoPtr.h>

#include <CQIllustratorMode.h>
#include <CQIllustratorToolbar.h>
#include <CQIllustrator.h>

class QComboBox;
class CQImageButton;
class CQIllustrator;
class CQIllustratorSetImageMode;

class CQIllustratorImageSizer : public CQIllustratorModeSizer {
 public:
  CQIllustratorImageSizer(CQIllustratorSetImageMode *mode);

  void drawHandles(QPainter *painter, const CQIllustratorShape *shape);
};

class CQIllustratorSetImageToolbar : public CQIllustratorToolbar {
  Q_OBJECT

 public:
  CQIllustratorSetImageToolbar(CQIllustratorSetImageMode *mode);

  const char *getTitle() const { return "Set Image"; }

  QIcon getIcon();

  void addWidgets();

  void setSelectedShape(const CQIllustratorShape *shape);

  void updateShape();

  void updateWidgets();

  void setShapeImage(CQIllustratorShape *shape, CImagePtr image);

 private slots:
  void setImageSlot();
  void setScaleSlot(int);

  void lalignSlot();
  void hcalignSlot();
  void ralignSlot();

  void talignSlot();
  void vcalignSlot();
  void balignSlot();

 private:
  CQIllustratorSetImageMode          *mode_;
  CQIllustratorShapeFill::ImageScale  scale_;
  CHAlignType                         halign_;
  CVAlignType                         valign_;
  QComboBox                          *scaleCombo_;
  CQImageButton                      *imageButton_;
  CQImageButton                      *lalignButton_;
  CQImageButton                      *hcalignButton_;
  CQImageButton                      *ralignButton_;
  CQImageButton                      *talignButton_;
  CQImageButton                      *vcalignButton_;
  CQImageButton                      *balignButton_;
};

class CQIllustratorSetImageMode : public CQIllustratorMode {
  Q_OBJECT

 public:
  CQIllustratorSetImageMode(CQIllustrator *illustrator);

  const char *getTitle() const { return "Set Image"; }

  CQIllustratorSetImageToolbar *createToolbar();

  CQIllustratorImageSizer *createSizer();

  CQMenuItem *createMenuItem(CQMenu *menu);

  CQIllustratorSetImageToolbar *getToolbar() const { return toolbar_; }

  void handleMouseRelease(const MouseEvent &e);
  void handleMouseDrag   (const MouseEvent &e);

  void drawOverlay(CQIllustratorShapeDrawer *drawer);

  QCursor getCursor() const;

 private:
  CQIllustratorSetImageToolbar      *toolbar_;
  CAutoPtr<CQIllustratorImageSizer>  sizer_;
};

#endif
##concat##CQIllustratorSetLGradientMode.h
#ifndef CQIllustratorSetLGradientMode_H
#define CQIllustratorSetLGradientMode_H

#include <CAutoPtr.h>

#include <CQIllustratorMode.h>
#include <CQIllustratorToolbar.h>
#include <CQIllustrator.h>

class QRadioButton;
class CQRealEdit;
class CQIllustrator;
class CQIllustratorControlPointHandle;
class CQIllustratorSetLGradientMode;

class CQIllustratorLGradSizer : public CQIllustratorModeSizer {
 public:
  CQIllustratorLGradSizer(CQIllustratorSetLGradientMode *mode);

  void drawHandles(QPainter *painter, const CQIllustratorShape *shape);

 private:
  CQIllustratorControlPointHandle *start_handle_;
  CQIllustratorControlPointHandle *end_handle_;
};

class CQIllustratorSetLGradientToolbar : public CQIllustratorToolbar {
  Q_OBJECT

 public:
  CQIllustratorSetLGradientToolbar(CQIllustratorSetLGradientMode *mode);

  const char *getTitle() const { return "Linear Gradient"; }

  QIcon getIcon();

  void addWidgets();

  void setSelectedShape(const CQIllustratorShape *shape);

 private slots:
  void modeChangedSlot();

  void updateShape();

 private:
  CQIllustratorSetLGradientMode *mode_;
  QRadioButton                  *createRadio_;
  QRadioButton                  *editRadio_;
  CQRealEdit                    *startXEdit_;
  CQRealEdit                    *startYEdit_;
  CQRealEdit                    *endXEdit_;
  CQRealEdit                    *endYEdit_;
};

class CQIllustratorSetLGradientMode : public CQIllustratorMode {
 public:
  CQIllustratorSetLGradientMode(CQIllustrator *illustrator);

  const char *getTitle() const { return "Set Linear Gradient"; }

  CQIllustratorSetLGradientToolbar *createToolbar();

  CQIllustratorLGradSizer *createSizer();

  CQMenuItem *createMenuItem(CQMenu *menu);

  CQIllustratorSetLGradientToolbar *getToolbar() const { return toolbar_; }

  CQIllustratorData::ChangeType getChangeType() const {
    return CQIllustratorData::CHANGE_FILL;
  }

  CQIllustratorShape::ControlType getControlType() const {
    return CQIllustratorShape::CONTROL_LGRADIENT;
  }

  void handleMouseRelease(const MouseEvent &e);
  void handleMouseDrag   (const MouseEvent &e);

  void drawOverlay(CQIllustratorShapeDrawer *drawer);

  QCursor getCursor() const;

 private:
  CQIllustratorSetLGradientToolbar  *toolbar_;
  CAutoPtr<CQIllustratorLGradSizer>  sizer_;
};

#endif
##concat##CQIllustratorSetRGradientMode.h
#ifndef CQIllustratorSetRGradientMode_H
#define CQIllustratorSetRGradientMode_H

#include <CAutoPtr.h>

#include <CQIllustratorMode.h>
#include <CQIllustratorToolbar.h>
#include <CQIllustrator.h>

class CQRealEdit;
class CQIllustrator;
class CQIllustratorControlPointHandle;
class CQIllustratorSetRGradientMode;

class CQIllustratorRGradSizer : public CQIllustratorModeSizer {
 public:
  CQIllustratorRGradSizer(CQIllustratorSetRGradientMode *mode);

  void drawHandles(QPainter *painter, const CQIllustratorShape *shape);

 private:
  CQIllustratorControlPointHandle *center_handle_;
  CQIllustratorControlPointHandle *focus_handle_;
  CQIllustratorControlPointHandle *radius_handle_;
};

class CQIllustratorSetRGradientToolbar : public CQIllustratorToolbar {
  Q_OBJECT

 public:
  CQIllustratorSetRGradientToolbar(CQIllustratorSetRGradientMode *mode);

  const char *getTitle() const { return "Radial Gradient"; }

  QIcon getIcon();

  void addWidgets();

  void setSelectedShape(const CQIllustratorShape *shape);

 private slots:
  void updateShape();

 private:
  CQIllustratorSetRGradientMode *mode_;
  CQRealEdit                    *centerXEdit_;
  CQRealEdit                    *centerYEdit_;
  CQRealEdit                    *focusXEdit_;
  CQRealEdit                    *focusYEdit_;
  CQRealEdit                    *radiusEdit_;
};

class CQIllustratorSetRGradientMode : public CQIllustratorMode {
 public:
  CQIllustratorSetRGradientMode(CQIllustrator *illustrator);

  const char *getTitle() const { return "Set Radial Gradient"; }

  CQIllustratorSetRGradientToolbar *createToolbar();

  CQIllustratorRGradSizer *createSizer();

  CQMenuItem *createMenuItem(CQMenu *menu);

  CQIllustratorSetRGradientToolbar *getToolbar() const { return toolbar_; }

  CQIllustratorData::ChangeType getChangeType() const {
    return CQIllustratorData::CHANGE_FILL;
  }

  CQIllustratorShape::ControlType getControlType() const {
    return CQIllustratorShape::CONTROL_RGRADIENT;
  }

  void handleMouseRelease(const MouseEvent &e);
  void handleMouseDrag   (const MouseEvent &e);

  void drawOverlay(CQIllustratorShapeDrawer *drawer);

  QCursor getCursor() const;

 private:
  CAutoPtr<CQIllustratorRGradSizer>  sizer_;
  CQIllustratorSetRGradientToolbar  *toolbar_;
};

#endif
##concat##CQIllustratorShapeDrawer.h
#ifndef CQILLUSTARTOR_SHAPE_DRAWER_H
#define CQILLUSTARTOR_SHAPE_DRAWER_H

#include <QFont>
#include <QTransform>
#include <QImage>
#include <CBBox2D.h>
#include <CMatrix2D.h>
#include <CFont.h>
#include <CImageLib.h>
#include <CFillType.h>

class QPainter;

class CQIllustrator;
class CQIllustratorShape;
class CQIllustratorShapeStroke;
class CQIllustratorShapeFill;

class CQIllustratorShapeDrawer {
 public:
  CQIllustratorShapeDrawer(CQIllustrator *illustrator, QPainter *painter=0);

  virtual ~CQIllustratorShapeDrawer();

  CQIllustrator *getIllustrator() const { return illustrator_; }

  void setPainter(QPainter *painter);

  QPainter *getPainter() const { return painter_; }

  void setBBox(const CBBox2D &bbox);

  void pushMatrix(const CMatrix2D &m, bool combine=true);
  void popMatrix();

  void setStroke(const CQIllustratorShape *shape, const CQIllustratorShapeStroke &stroke);
  void setFill  (const CQIllustratorShape *shape, const CQIllustratorShapeFill &fill);

  void setFont(CFontPtr font);

  void drawText(const CBBox2D &rect, const std::string &str,
                CHAlignType halign, CVAlignType valign);

  void pathInit();
  void pathMoveTo(const CPoint2D &p);
  void pathLineTo(const CPoint2D &p);
  void pathBezierTo(const CPoint2D &p1, const CPoint2D &p2);
  void pathBezierTo(const CPoint2D &p1, const CPoint2D &p2, const CPoint2D &p3);
  void pathArc(const CPoint2D &c, double xr, double yr, double angle1, double angle2);
  void pathText(const CBBox2D &rect, const std::string &str,
                CHAlignType halign, CVAlignType valign);
  void pathClose();

  void pathStroke();
  void pathFill(CFillType type);
  void pathClip();

  void drawControlLine(const CPoint2D &p1, const CPoint2D &p2);

  //void drawControlPointNormal(const CPoint2D &point, bool selected);
  //void drawControlPointControl(const CPoint2D &point, bool selected);

  void drawGridLine(const CPoint2D &p1, const CPoint2D &p2);

  void drawGridSubLine(const CPoint2D &p1, const CPoint2D &p2);

  void drawImage(int x, int y, QImage image);

 protected:
  typedef std::vector<CMatrix2D> MatrixStack;

  CQIllustrator *illustrator_;
  QPainter      *painter_;
  CBBox2D        bbox_;
  QPainterPath  *path_;
  QFont          qfont_;
  CMatrix2D      m_;
  MatrixStack    matrices_;

  CImagePtr control_point_image_;
  CImagePtr control_point_active_image_;
  CImagePtr curve_point_image_;
  CImagePtr curve_point_active_image_;

  QImage qi1_control_;
  QImage qi2_control_;
  QImage qi1_curve_;
  QImage qi2_curve_;
};

class CQIllustratorFilterShapeDrawer : public CQIllustratorShapeDrawer {
 public:
  CQIllustratorFilterShapeDrawer(CQIllustratorShapeDrawer *drawer,
                                 const CQIllustratorShape *shape);

 ~CQIllustratorFilterShapeDrawer();

  QImage &getImage();

 private:
  CQIllustrator            *illustrator_;
  const CQIllustratorShape *shape_;
  QImage                    qimage_;
  CBBox2D                   bbox_;
};

#endif
##concat##CQIllustratorShape.h
#ifndef CQIllustratorShape_H
#define CQIllustratorShape_H

#include <CAutoPtrVector.h>
#include <CBBox2D.h>
#include <CPoint2D.h>
#include <CPolygon2D.h>
#include <CMatrix2D.h>
#include <CRGBA.h>
#include <CLineDash.h>
#include <CLineCapType.h>
#include <CLineJoinType.h>
#include <CFillType.h>
#include <CPathPartType.h>
#include <CFont.h>
#include <CImageLib.h>
#include <CGenGradient.h>

class CQIllustratorShape;
class CQIllustratorShapeDrawer;

#include <CQIllustratorSaveData.h>
#include <CQIllustratorData.h>

struct CQIllustratorShapeStroke {
 private:
  CRGBA         color_;
  double        width_;
  double        opacity_;
  CLineDash     dash_;
  CLineCapType  cap_;
  CLineJoinType join_;
  double        mlimit_;

 public:
  CQIllustratorShapeStroke() :
   color_(0,0,0), width_(1), opacity_(1), dash_(), cap_(LINE_CAP_TYPE_SQUARE),
   join_(LINE_JOIN_TYPE_MITRE), mlimit_(3) {
  }

  CQIllustratorShapeStroke(const CQIllustratorShapeStroke &stroke) :
   color_(stroke.color_), width_(stroke.width_), opacity_(stroke.opacity_),
   dash_(stroke.dash_), cap_(stroke.cap_), join_(stroke.join_), mlimit_(stroke.mlimit_) {
  }

  virtual ~CQIllustratorShapeStroke() { }

  const CQIllustratorShapeStroke &operator=(const CQIllustratorShapeStroke &stroke) {
    color_   = stroke.color_;
    width_   = stroke.width_;
    opacity_ = stroke.opacity_;
    dash_    = stroke.dash_;
    cap_     = stroke.cap_;
    join_    = stroke.join_;
    mlimit_  = stroke.mlimit_;

    return *this;
  }

  const CRGBA &getColor() const { return color_; }
  void setColor(const CRGBA &color) { color_ = color; }

  double getWidth() const { return width_; }
  void setWidth(double width) { width_ = width; }

  double getOpacity() const { return opacity_; }
  void setOpacity(double opacity) { opacity_ = opacity; }

  const CLineDash &getLineDash() const { return dash_; }
  void setLineDash(const CLineDash &dash) { dash_ = dash; }

  const CLineCapType &getLineCap() const { return cap_; }
  void setLineCap(const CLineCapType &cap) { cap_ = cap; }

  const CLineJoinType &getLineJoin() const { return join_; }
  void setLineJoin(const CLineJoinType &join) { join_ = join; }

  double getMitreLimit() const { return mlimit_; }
  void setMitreLimit(double mlimit) { mlimit_ = mlimit; }

  void draw(const CQIllustratorShape *shape, CQIllustratorShapeDrawer *drawer) const;
};

class CQIllustratorImageFill {
 public:
  enum Scale {
    SCALE_NONE,
    SCALE_FIT,
    SCALE_EQUAL
  };

 public:
  CQIllustratorImageFill() :
   image_(), scale_(SCALE_NONE), halign_(CHALIGN_TYPE_LEFT), valign_(CVALIGN_TYPE_BOTTOM) {
  }

  CQIllustratorImageFill(const CQIllustratorImageFill &image) :
   image_(image.image_), scale_(image.scale_), halign_(image.halign_), valign_(image.valign_) {
  }

  CImagePtr getImage() const { return image_; }

  void setImage(CImagePtr image) { image_ = image; }

  Scale getScale() const { return scale_; }

  void setScale(Scale scale) { scale_ = scale; }

  CHAlignType getHAlign() const { return halign_; }
  CVAlignType getVAlign() const { return valign_; }

  void setHAlign(CHAlignType halign) { halign_ = halign; }
  void setVAlign(CVAlignType valign) { valign_ = valign; }

 private:
  CImagePtr   image_;
  Scale       scale_;
  CHAlignType halign_;
  CVAlignType valign_;
};

class CQIllustratorShapeFill {
 public:
  enum ImageScale {
    IMAGE_SCALE_NONE,
    IMAGE_SCALE_FIT,
    IMAGE_SCALE_EQUAL
  };

 private:
  CRGBA         color_;
  double        opacity_;
  CFillType     rule_;
  CGenGradient *gradient_;
  CQIllustratorImageFill   *image_;

 public:
  CQIllustratorShapeFill() :
   color_(1,1,1), opacity_(1), rule_(FILL_TYPE_EVEN_ODD), gradient_(0), image_(0) {
  }

  CQIllustratorShapeFill(const CQIllustratorShapeFill &fill) :
   color_(fill.color_), opacity_(fill.opacity_), rule_(fill.rule_), gradient_(0), image_(0) {
    if (fill.gradient_)
      gradient_ = fill.gradient_->dup();

    if (fill.image_)
      image_ = new CQIllustratorImageFill(*fill.image_);
  }

  const CQIllustratorShapeFill &operator=(const CQIllustratorShapeFill &fill) {
    color_   = fill.color_;
    opacity_ = fill.opacity_;
    rule_    = fill.rule_;

    delete gradient_;

    if (fill.gradient_)
      gradient_ = fill.gradient_->dup();
    else
      gradient_ = 0;

    delete image_;

    if (fill.image_)
      image_ = new CQIllustratorImageFill(*fill.image_);
    else
      image_ = 0;

    return *this;
  }

 ~CQIllustratorShapeFill() {
    delete gradient_;
    delete image_;
  }

  const CRGBA &getColor() const { return color_; }
  void setColor(const CRGBA &color) { color_ = color; }

  double getOpacity() const { return opacity_; }
  void setOpacity(double opacity) { opacity_ = opacity; }

  double getFillRule() const { return rule_; }
  void setFillRule(CFillType rule) { rule_ = rule; }

  bool hasGradient() const { return (gradient_ != 0); }

  void setGradient(const CGenGradient *g) {
    delete gradient_;

    if (g)
      gradient_ = g->dup();
    else
      gradient_ = 0;
  }

  const CGenGradient *getGradient() const { return gradient_; }

  CGenGradient *getGradient() { return gradient_; }

  bool hasImage() const { return (image_ != 0); }

  CImagePtr getImage() const {
    if (! image_) {
      CQIllustratorShapeFill *th = const_cast<CQIllustratorShapeFill *>(this);

      th->image_ = new CQIllustratorImageFill;
    }

    return image_->getImage();
  }

  void setImage(CImagePtr image) {
    if (! image_) {
      CQIllustratorShapeFill *th = const_cast<CQIllustratorShapeFill *>(this);

      th->image_ = new CQIllustratorImageFill;
    }

    image_->setImage(image);
  }

  void resetImage() {
    delete image_;

    image_ = 0;
  }

  ImageScale getImageScale() const {
    if (! image_)
      return IMAGE_SCALE_NONE;

    return (ImageScale) image_->getScale();
  }

  void setImageScale(ImageScale scale) {
    if (! image_) {
      CQIllustratorShapeFill *th = const_cast<CQIllustratorShapeFill *>(this);

      th->image_ = new CQIllustratorImageFill;
    }

    image_->setScale((CQIllustratorImageFill::Scale) scale);
  }

  CHAlignType getImageHAlign() const {
    if (! image_)
      return CHALIGN_TYPE_LEFT;

    return image_->getHAlign();
  }

  void setImageHAlign(CHAlignType halign) {
    if (! image_) {
      CQIllustratorShapeFill *th = const_cast<CQIllustratorShapeFill *>(this);

      th->image_ = new CQIllustratorImageFill;
    }

    image_->setHAlign(halign);
  }

  CVAlignType getImageVAlign() const {
    if (! image_)
      return CVALIGN_TYPE_BOTTOM;

    return image_->getVAlign();
  }

  void setImageVAlign(CVAlignType valign) {
    if (! image_) {
      CQIllustratorShapeFill *th = const_cast<CQIllustratorShapeFill *>(this);

      th->image_ = new CQIllustratorImageFill;
    }

    image_->setVAlign(valign);
  }

  void draw(const CQIllustratorShape *shape, CQIllustratorShapeDrawer *drawer) const;
};

#define CQIllustratorShapeFilterMgrInst CQIllustratorShapeFilterMgr::getInstance()

class CQIllustratorShapeFilter;

class CQIllustratorShapeFilterMgr {
 public:
  static CQIllustratorShapeFilterMgr *getInstance();

  CQIllustratorShapeFilter *getFilter(uint id);

  void addFilter(CQIllustratorShapeFilter *filter);

 private:
  CQIllustratorShapeFilterMgr();
 ~CQIllustratorShapeFilterMgr();

 private:
  typedef std::map<uint,CQIllustratorShapeFilter *> FilterMap;

  FilterMap filterMap_;
  uint      id_;
};

class CQIllustratorShapeFilter {
 public:
  CQIllustratorShapeFilter();

  virtual ~CQIllustratorShapeFilter();

  uint getId() const { return id_; }

 private:
  friend class CQIllustratorShapeFilterMgr;

  void setId(uint id) { id_ = id; }

 protected:
  uint id_;
};

class CQIllustratorShapeGaussianFilter : public CQIllustratorShapeFilter {
 public:
  CQIllustratorShapeGaussianFilter(double std_dev=1.0) :
   std_dev_(std_dev) {
  }

 private:
  double std_dev_;
};

class CQIllustratorShapeControlLine {
 public:
  CQIllustratorShapeControlLine(uint id, const CLine2D &line=CLine2D());

  virtual ~CQIllustratorShapeControlLine() { }

  virtual CQIllustratorShapeControlLine *dup() const = 0;

  uint getId() const { return id_; }

  virtual CLine2D getLine(const CQIllustratorShape *shape) const;

  virtual void setLine(CQIllustratorShape *shape, const CLine2D &line);

  virtual void setLine(const CLine2D &line);

  void updateLine(CQIllustratorShape *shape, CQIllustratorShapeControlLine *line);

  virtual void setType(CQIllustratorShape *shape, CPathPartType type);

  friend bool operator==(const CQIllustratorShapeControlLine &p1,
                         const CQIllustratorShapeControlLine &p2);
  friend bool operator!=(const CQIllustratorShapeControlLine &p1,
                         const CQIllustratorShapeControlLine &p2);

  virtual void moveLineTo(CQIllustratorShape *shape, const CLine2D &line);

 protected:
  uint    id_;
  CLine2D line_;
};

class CQIllustratorShapeControlPoint {
 public:
  enum ControlPointType {
    NORMAL_POINT,
    CONTROL_POINT
  };

 public:
  CQIllustratorShapeControlPoint(uint id, const CPoint2D &point=CPoint2D(0,0),
                                 ControlPointType type=NORMAL_POINT);

  virtual ~CQIllustratorShapeControlPoint() { }

  virtual CQIllustratorShapeControlPoint *dup() const = 0;

  uint getId() const { return id_; }

  virtual CPoint2D getPoint(const CQIllustratorShape *shape) const;

  virtual void setPoint(CQIllustratorShape *shape, const CPoint2D &point);

  virtual void setPoint(const CPoint2D &point);

  void updatePoint(CQIllustratorShape *shape, CQIllustratorShapeControlPoint *point);

  friend bool operator==(const CQIllustratorShapeControlPoint &p1,
                         const CQIllustratorShapeControlPoint &p2);
  friend bool operator!=(const CQIllustratorShapeControlPoint &p1,
                         const CQIllustratorShapeControlPoint &p2);

  virtual double distance(const CQIllustratorShape *shape, const CPoint2D &point) const;

  virtual void movePointBy(CQIllustratorShape *shape, const CPoint2D &d);

  virtual void movePointTo(CQIllustratorShape *shape, const CPoint2D &pos);

  static double pointDist(const CPoint2D &p1, const CPoint2D &p2);

 protected:
  uint             id_;
  CPoint2D         point_;
  ControlPointType type_;
};

class CQIllustratorShapeNearestPoint2D {
 public:
  CQIllustratorShapeNearestPoint2D() :
   set_(false), dist_(0.0), p_(0) {
  }

  CQIllustratorShapeNearestPoint2D(const CQIllustratorShapeNearestPoint2D &p) :
   set_(p.set_), dist_(p.dist_), p_(p.p_ ? p.p_->dup() : 0) {
  }

  const CQIllustratorShapeNearestPoint2D &operator=(const CQIllustratorShapeNearestPoint2D &p) {
    set_  = p.set_;
    dist_ = p.dist_;
    p_    = (p.p_ ? p.p_->dup() : 0);

    return *this;
  }

 ~CQIllustratorShapeNearestPoint2D() {
    delete p_;
  }

  bool isSet() const { return set_; }

  void updatePoint(CQIllustratorShapeControlPoint *p, double dist) {
    if (! set_ || dist < dist_) {
      set_  = true;
      dist_ = dist;

      delete p_;

      p_ = p->dup();
    }
  }

  double getDist() const { return dist_; }

  CQIllustratorShapeControlPoint *getPoint() const { return p_; }

 private:
  bool                set_;
  double              dist_;
  CQIllustratorShapeControlPoint *p_;
};

class CQIllustratorShapeGeometry {
 public:
  CQIllustratorShapeGeometry(bool fixed, const CPoint2D &rcenter, const CMatrix2D &m) :
   fixed_(fixed), rcenter_(rcenter), m_(m) {
  }

  virtual ~CQIllustratorShapeGeometry() { }

  virtual CQIllustratorShapeGeometry *dup() = 0;

 protected:
  bool      fixed_;
  CPoint2D  rcenter_;
  CMatrix2D m_;
};

class CQIllustratorShapeLGradientControlPoint : public CQIllustratorShapeControlPoint {
 public:
  enum Position { START, END };

 public:
  CQIllustratorShapeLGradientControlPoint(Position pos, const CPoint2D &p);

  CQIllustratorShapeLGradientControlPoint *dup() const;

  Position getPosition() const { return pos_; }

  CPoint2D getPoint(const CQIllustratorShape *shape) const;

  void setPoint(CQIllustratorShape *shape, const CPoint2D &point);

 protected:
  Position pos_;
};

class CQIllustratorShapeRGradientControlPoint : public CQIllustratorShapeControlPoint {
 public:
  enum Position { CENTER, FOCUS, RADIUS };

 public:
  CQIllustratorShapeRGradientControlPoint(Position pos, const CPoint2D &p);

  CQIllustratorShapeRGradientControlPoint *dup() const;

  Position getPosition() const { return pos_; }

  CPoint2D getPoint(const CQIllustratorShape *shape) const;

  void setPoint(CQIllustratorShape *shape, const CPoint2D &point);

 protected:
  Position pos_;
};

#include <CPathShape.h>

class CQIllustratorShape {
 public:
  enum ControlType {
    CONTROL_GEOMETRY,
    CONTROL_LGRADIENT,
    CONTROL_RGRADIENT
  };

  typedef std::vector<CPoint2D> PointList;

  typedef CAutoPtrVector<CQIllustratorShapeControlLine>  ControlLineList;
  typedef CAutoPtrVector<CQIllustratorShapeControlPoint> ControlPointList;

  typedef std::list<CQIllustratorShape *> ShapeList;

 public:
  CQIllustratorShape(CQIllustratorShape *parent=0);
  CQIllustratorShape(const CQIllustratorShape &rhs);

  virtual ~CQIllustratorShape();

  virtual CQIllustratorShape *dup() const = 0;

  CQIllustratorData *getData() const { return data_; }

  void setData(CQIllustratorData *data) { data_ = data; }

  uint getId() const { return id_; }

  void setId(uint id) { id_ = id; }

  virtual const char *getClassName() const { return "shape"; }

  const std::string &getName() const { return name_; }

  void setName(const std::string &name);

  const CBBox2D &getBBox() const;

  virtual CPoint2D getCenter() const;

  virtual bool getPolygon(CPolygon2D &) const = 0;

  virtual bool getPath(CPathShapePartList &) const = 0;

  const CMatrix2D &getFlatMatrix() const;

  CBBox2D getFlatBBox() const;

  const CMatrix2D &getMatrix() const { return m_; }

  void setMatrix(const CMatrix2D &m);

  virtual void addChild   (CQIllustratorShape *child);
  virtual void removeChild(CQIllustratorShape *child);

  CQIllustratorShape *getParent() const { return parent_; }

  virtual void setParent(CQIllustratorShape *newParent);

  virtual void childrenChanged() { }

  const ShapeList &getChildren() const { return shapes_; }

  CQIllustratorShapeStroke &getStroke();
  CQIllustratorShapeFill   &getFill  ();

  const CQIllustratorShapeStroke &getStroke() const;
  const CQIllustratorShapeFill   &getFill  () const;

  void setStroke(const CQIllustratorShapeStroke &stroke);
  void setFill  (const CQIllustratorShapeFill   &fill  );

  void setStrokeColor(const CRGBA &rgba);
  void setFillColor  (const CRGBA &rgba);

  void setStrokeOpacity(double opacity);
  void setFillOpacity  (double opacity);

  double getStrokeWidth() const;

  void setFilter(uint num);

  void setFilter(CQIllustratorShapeFilter *filter);

  void unsetFilter();

  CQIllustratorShapeFilter *getFilter() const;

  bool getClip() const { return clip_; }
  void setClip(bool clip);

  bool getFixed() const { return fixed_; }
  void setFixed(bool fixed) { fixed_ = fixed; }

  void setVisible(bool visible) { visible_ = visible; }
  bool getVisible() const { return visible_; }

  virtual CPoint2D getRotateCenter() const;

  void setRotateCenter(const CPoint2D &center);

  virtual double distance(const CPoint2D &p) const;

  virtual bool inside(const CPoint2D &p) const;

  virtual void getControlLines(ControlLineList &lines) const;

  virtual void setControlLine(const CQIllustratorShapeControlLine *line);

  virtual void getControlPoints(ControlPointList &points, ControlType type=CONTROL_GEOMETRY) const;

  virtual void setControlPoint(const CQIllustratorShapeControlPoint *point) = 0;

  CQIllustratorShapeNearestPoint2D nearestPoint(const CPoint2D &p,
                                                ControlType type=CONTROL_GEOMETRY) const;

  void moveTo(const CPoint2D &pos);

  virtual void moveBy(const CPoint2D &d) = 0;

  void resizeTo(double w, double h);

  virtual void resizeBy(double dw, double dh);

  virtual void movePointTo(const CQIllustratorShapeControlPoint *point, const CPoint2D &pos);
  virtual void movePointBy(const CQIllustratorShapeControlPoint *point, const CPoint2D &d);

  bool removePoint(const CQIllustratorShapeControlPoint *point);

  virtual bool doRemovePoint(const CQIllustratorShapeControlPoint *point);

  virtual void scale(const CPoint2D &c, double sx, double sy);

  virtual void rotate(double da);

  virtual void skew(double dx, double dy);

  virtual void transform(const CPoint2D &c, const CMatrix2D &m);

  virtual void setBBox(const CBBox2D &bbox);

  virtual bool flip(bool x_axis=true);

  void draw(CQIllustratorShapeDrawer *drawer) const;

  virtual void drawShape(CQIllustratorShapeDrawer *drawer) const = 0;

  void drawGaussian(CQIllustratorShapeDrawer *drawer) const;

  virtual CQIllustratorShapeGeometry *getGeometry() = 0;

  void setGeometry(const CQIllustratorShapeGeometry *geom);

  virtual void doSetGeometry(const CQIllustratorShapeGeometry *) = 0;

  virtual void saveSVG(const CQIllustratorSaveData &saveData) = 0;
  virtual void saveCmd(const CQIllustratorSaveData &saveData) = 0;

  virtual void drawSelect(CQIllustratorShapeDrawer *drawer);

  std::string getSVGStroke() const;

  std::string getSVGMatrix() const;
  std::string getSVGMatrix(const CMatrix2D &m) const;

  //------

  void lockShape();
  void unlockShape();

  int getLocked() const { return (lock_count_ > 0); }

 protected:
  void checkoutShape(CQIllustratorData::ChangeType changeType);
  void checkinShape (CQIllustratorData::ChangeType changeType);

  void invalidateBBox() const { bbox_valid_ = false; }

  virtual void updateBBox() const = 0;

  double pointDist(const CPoint2D &p1, const CPoint2D &p2) const;

 private:
  CQIllustratorShape &operator=(const CQIllustratorShape &rhs);

 protected:
  static uint last_id_;

  CQIllustratorData        *data_;
  uint                      id_;
  CQIllustratorShape       *parent_;
  ShapeList                 shapes_;
  std::string               name_;
  CQIllustratorShapeStroke  stroke_;
  CQIllustratorShapeFill    fill_;
  uint                      filter_id_;
  bool                      clip_;
  bool                      fixed_;
  bool                      visible_;
  CPoint2D                  rcenter_;
  CMatrix2D                 m_;
  int                       lock_count_;

  mutable CBBox2D           bbox_;
  mutable bool              bbox_valid_;
};

class CQIllustratorRectGeometry : public CQIllustratorShapeGeometry {
 public:
  CQIllustratorRectGeometry(bool fixed=false, const CPoint2D &rcenter=CPoint2D(0,0),
                            const CMatrix2D m=CMatrix2D(), const CPoint2D &p1=CPoint2D(),
                            const CPoint2D &p2=CPoint2D(), double rx=0.0, double ry=0.0) :
   CQIllustratorShapeGeometry(fixed, rcenter, m), p1_(p1), p2_(p2), rx_(rx), ry_(ry) {
  }

  CQIllustratorRectGeometry(const CQIllustratorRectGeometry &geometry) :
   CQIllustratorShapeGeometry(geometry), p1_(geometry.p1_), p2_(geometry.p2_),
   rx_(geometry.rx_), ry_(geometry.ry_) {
  }

  virtual CQIllustratorRectGeometry *dup() {
    return new CQIllustratorRectGeometry(*this);
  }

  friend class CQIllustratorRectShape;

 private:
  CQIllustratorRectGeometry &operator=(const CQIllustratorRectGeometry &);

 private:
  CPoint2D p1_, p2_;
  double   rx_, ry_;
};

class CQIllustratorRectShape : public CQIllustratorShape {
 public:
  enum ControlPointType {
    TYPE_LL, TYPE_UR, TYPE_RX, TYPE_RY
  };

 public:
  CQIllustratorRectShape(const CPoint2D &p1, const CPoint2D &p2, double rx=0.0, double ry=0.0);
  CQIllustratorRectShape(const CQIllustratorRectShape &rect);

  CQIllustratorRectShape *dup() const;

  const char *getClassName() const { return "rect"; }

  void getControlPoints(ControlPointList &points,
                        ControlType type=CONTROL_GEOMETRY) const;

  void setControlPoint(const CQIllustratorShapeControlPoint *point);

  double getRadiusX() const { return rx_; }
  double getRadiusY() const { return ry_; }

  void setRadiusX(double rx);
  void setRadiusY(double ry);

  CPoint2D getLL() const;
  CPoint2D getUR() const;

  CPoint2D getRXPoint() const;
  CPoint2D getRYPoint() const;

  void setLL(const CPoint2D &p);
  void setUR(const CPoint2D &p);

  void setRXPoint(const CPoint2D &p);
  void setRYPoint(const CPoint2D &p);

  bool getPolygon(CPolygon2D &polygon) const;

  bool getPath(CPathShapePartList &path) const;

  void moveBy(const CPoint2D &d);

  void resizeBy(double dw, double dh);

  bool flip(bool x_axis);

  void drawShape(CQIllustratorShapeDrawer *drawer) const;

  CQIllustratorShapeGeometry *getGeometry();

  void doSetGeometry(const CQIllustratorShapeGeometry *geom);

  void saveSVG(const CQIllustratorSaveData &saveData);
  void saveCmd(const CQIllustratorSaveData &saveData);

  double getAngle() const;

 protected:
  void updateBBox() const;

 protected:
  CPoint2D p1_, p2_;
  double   rx_, ry_;
};

class CQIllustratorRectShapeControlPoint : public CQIllustratorShapeControlPoint {
 public:
  CQIllustratorRectShapeControlPoint(CQIllustratorRectShape::ControlPointType type,
                                     const CPoint2D &p);

  CQIllustratorRectShapeControlPoint *dup() const;

  CQIllustratorRectShape::ControlPointType getType() const { return type_; }

  CPoint2D getPoint(const CQIllustratorShape *shape) const;

  void setPoint(CQIllustratorShape *shape, const CPoint2D &point);

 protected:
  CQIllustratorRectShape::ControlPointType type_;
};

//----------------

enum CEllipseConnectType {
  CELLIPSE_CONNECT_LINE,  // Line
  CELLIPSE_CONNECT_CENTER // Center
};

class CQIllustratorEllipseGeometry : public CQIllustratorShapeGeometry {
 public:
  CQIllustratorEllipseGeometry(bool fixed=false, const CPoint2D &rcenter=CPoint2D(0,0),
                               const CMatrix2D m=CMatrix2D(), const CPoint2D &p1=CPoint2D(),
                               const CPoint2D &p2=CPoint2D(), double angle1=0.0,
                               double angle2=360.0,
                               CEllipseConnectType connectType=CELLIPSE_CONNECT_LINE) :
   CQIllustratorShapeGeometry(fixed, rcenter, m), p1_(p1), p2_(p2),
                              angle1_(angle1), angle2_(angle2), connectType_(connectType) {
  }

  CQIllustratorEllipseGeometry(const CQIllustratorEllipseGeometry &geometry) :
   CQIllustratorShapeGeometry(geometry), p1_(geometry.p1_), p2_(geometry.p2_),
   angle1_(geometry.angle1_), angle2_(geometry.angle2_) {
  }

  virtual CQIllustratorEllipseGeometry *dup() {
    return new CQIllustratorEllipseGeometry(*this);
  }

  friend class CQIllustratorEllipseShape;

 private:
  CQIllustratorEllipseGeometry &operator=(const CQIllustratorEllipseGeometry &);

 protected:
  CPoint2D            p1_, p2_;
  double              angle1_, angle2_;
  CEllipseConnectType connectType_;
};

class CQIllustratorEllipseShape : public CQIllustratorShape {
 public:
  enum ControlPointType {
    TYPE_RX, TYPE_RY, TYPE_A1, TYPE_A2
  };

 public:
  CQIllustratorEllipseShape(const CPoint2D &p1, const CPoint2D &p2,
                            double angle1=0.0, double angle2=360.0,
                            CEllipseConnectType connectType=CELLIPSE_CONNECT_LINE);
  CQIllustratorEllipseShape(const CQIllustratorEllipseShape &ellipse);

  CQIllustratorEllipseShape *dup() const;

  const char *getClassName() const { return "ellipse"; }

  void setConnectType(CEllipseConnectType connectType) { connectType_ = connectType; }

  CEllipseConnectType getConnectType() const { return connectType_; }

  void getControlPoints(ControlPointList &points,
                        ControlType type=CONTROL_GEOMETRY) const;

  void setControlPoint(const CQIllustratorShapeControlPoint *point);

  double getAngle1() const;
  double getAngle2() const;

  void setAngle1(double a1);
  void setAngle2(double a2);

  CPoint2D getRXPoint() const;
  CPoint2D getRYPoint() const;

  void setRXPoint(const CPoint2D &p);
  void setRYPoint(const CPoint2D &p);

  CPoint2D getAngle1Point() const;
  CPoint2D getAngle2Point() const;

  void setAngle1Point(const CPoint2D &p);
  void setAngle2Point(const CPoint2D &p);

  bool getPolygon(CPolygon2D &polygon) const;

  bool getPath(CPathShapePartList &path) const;

  void moveBy(const CPoint2D &d);

  void resizeBy(double dw, double dh);

  bool flip(bool x_axis);

  void drawShape(CQIllustratorShapeDrawer *drawer) const;

  CQIllustratorShapeGeometry *getGeometry();

  void doSetGeometry(const CQIllustratorShapeGeometry *geom);

  void saveSVG(const CQIllustratorSaveData &saveData);
  void saveCmd(const CQIllustratorSaveData &saveData);

  double getAngle() const;

 protected:
  void updateBBox() const;

 protected:
  CPoint2D            p1_, p2_;
  double              angle1_, angle2_;
  CEllipseConnectType connectType_;
};

class CQIllustratorEllipseShapeControlPoint : public CQIllustratorShapeControlPoint {
 public:
  CQIllustratorEllipseShapeControlPoint(CQIllustratorEllipseShape::ControlPointType type,
                                        const CPoint2D &p);

  CQIllustratorEllipseShapeControlPoint *dup() const;

  CQIllustratorEllipseShape::ControlPointType getType() const { return type_; }

  CPoint2D getPoint(const CQIllustratorShape *shape) const;

  void setPoint(CQIllustratorShape *shape, const CPoint2D &point);

 protected:
  CQIllustratorEllipseShape::ControlPointType type_;
};

//----------------

class CQIllustratorNPolyGeometry : public CQIllustratorShapeGeometry {
 public:
  CQIllustratorNPolyGeometry(bool fixed=false, const CPoint2D &rcenter=CPoint2D(0,0),
                             const CMatrix2D m=CMatrix2D(), const CPoint2D &c=CPoint2D(),
                             uint n=5, double r=0.0, double a=0.0) :
   CQIllustratorShapeGeometry(fixed, rcenter, m), c_(c), n_(n), r_(r), a_(a) {
  }

  CQIllustratorNPolyGeometry(const CQIllustratorNPolyGeometry &geometry) :
   CQIllustratorShapeGeometry(geometry), c_(geometry.c_), n_(geometry.n_),
   r_(geometry.r_), a_(geometry.a_) {
  }

  virtual CQIllustratorNPolyGeometry *dup() {
    return new CQIllustratorNPolyGeometry(*this);
  }

  friend class CQIllustratorNPolyShape;

 private:
  CQIllustratorNPolyGeometry &operator=(const CQIllustratorNPolyGeometry &);

 protected:
  CPoint2D c_;
  uint     n_;
  double   r_;
  double   a_;
};

class CQIllustratorNPolyShape : public CQIllustratorShape {
 public:
  enum ControlPointType {
    TYPE_CENTER, TYPE_RADIUS
  };

 public:
  CQIllustratorNPolyShape(const CPoint2D &c, uint n, double r, double a);
  CQIllustratorNPolyShape(const CQIllustratorNPolyShape &poly);

  CQIllustratorNPolyShape *dup() const;

  const char *getClassName() const { return "npoly"; }

  void getControlPoints(ControlPointList &points,
                        ControlType type=CONTROL_GEOMETRY) const;

  void setControlPoint(const CQIllustratorShapeControlPoint *point);

  CPoint2D getCenter() const { return c_; }

  CPoint2D getRotateCenter() const;

  uint getNum() const { return n_; }

  void setNum(uint n);

  double getRadius() const { return r_; }

  void setRadius(double r);

  double getAngle() const { return a_; }

  void setAngle(double a);

  CPoint2D getCenterPoint() const;

  void setCenterPoint(const CPoint2D &c);

  CPoint2D getPoint() const;

  void setPoint(const CPoint2D &p);

  bool getPolygon(CPolygon2D &polygon) const;

  bool getPath(CPathShapePartList &path) const;

  void moveBy(const CPoint2D &d);

  bool flip(bool x_axis);

  void drawShape(CQIllustratorShapeDrawer *drawer) const;

  CQIllustratorShapeGeometry *getGeometry();

  void doSetGeometry(const CQIllustratorShapeGeometry *geom);

  void saveSVG(const CQIllustratorSaveData &saveData);
  void saveCmd(const CQIllustratorSaveData &saveData);

 protected:
  void updateBBox() const;

  void getPoints(std::vector<CPoint2D> &p) const;

 protected:
  CPoint2D c_;
  uint     n_;
  double   r_;
  double   a_;
};

class CQIllustratorNPolyShapeControlPoint : public CQIllustratorShapeControlPoint {
 public:
  CQIllustratorNPolyShapeControlPoint(CQIllustratorNPolyShape::ControlPointType type,
                                      const CPoint2D &p);

  CQIllustratorNPolyShapeControlPoint *dup() const;

  CQIllustratorNPolyShape::ControlPointType getType() const { return type_; }

  CPoint2D getPoint(const CQIllustratorShape *shape) const;

  void setPoint(CQIllustratorShape *shape, const CPoint2D &point);

 protected:
  CQIllustratorNPolyShape::ControlPointType type_;
};

//----------------

class CQIllustratorStarGeometry : public CQIllustratorShapeGeometry {
 public:
  CQIllustratorStarGeometry(bool fixed=false, const CPoint2D &rcenter=CPoint2D(0,0),
                            const CMatrix2D m=CMatrix2D(), const CPoint2D &c=CPoint2D(),
                            uint n=5, double r1=0.0, double r2=0.0, double a1=0.0, double a2=0.0) :
   CQIllustratorShapeGeometry(fixed, rcenter, m), c_(c), n_(n), r1_(r1), r2_(r2), a1_(a1), a2_(a2) {
  }

  CQIllustratorStarGeometry(const CQIllustratorStarGeometry &geometry) :
   CQIllustratorShapeGeometry(geometry), c_(geometry.c_), n_(geometry.n_), r1_(geometry.r1_),
   r2_(geometry.r2_), a1_(geometry.a1_), a2_(geometry.a2_) {
  }

  virtual CQIllustratorStarGeometry *dup() {
    return new CQIllustratorStarGeometry(*this);
  }

  friend class CQIllustratorStarShape;

 private:
  CQIllustratorStarGeometry &operator=(const CQIllustratorStarGeometry &);

 protected:
  CPoint2D c_;
  uint     n_;
  double   r1_, r2_;
  double   a1_, a2_;
};

class CQIllustratorStarShape : public CQIllustratorShape {
 public:
  enum ControlPointType {
    TYPE_CENTER, TYPE_IR, TYPE_OR
  };

 public:
  CQIllustratorStarShape(const CPoint2D &c, uint n, double r1, double r2, double a1, double a2);
  CQIllustratorStarShape(const CQIllustratorStarShape &star);

  CQIllustratorStarShape *dup() const;

  const char *getClassName() const { return "star"; }

  void getControlPoints(ControlPointList &points,
                        ControlType type=CONTROL_GEOMETRY) const;

  void setControlPoint(const CQIllustratorShapeControlPoint *point);

  CPoint2D getCenter() const { return c_; }

  CPoint2D getRotateCenter() const;

  uint getNum() const { return n_; }

  void setNum(uint n);

  double getInnerRadius() const { return r1_; }
  double getOuterRadius() const { return r2_; }

  void setInnerRadius(double r);
  void setOuterRadius(double r);

  double getInnerAngle() const { return a1_; }
  double getOuterAngle() const { return a2_; }

  void setInnerAngle(double a);
  void setOuterAngle(double a);

  CPoint2D getCenterPoint() const;

  void setCenterPoint(const CPoint2D &c);

  CPoint2D getInnerPoint() const;

  void setInnerPoint(const CPoint2D &p);

  CPoint2D getOuterPoint() const;

  void setOuterPoint(const CPoint2D &p);

  bool getPolygon(CPolygon2D &polygon) const;

  bool getPath(CPathShapePartList &path) const;

  void moveBy(const CPoint2D &d);

  bool flip(bool x_axis);

  void drawShape(CQIllustratorShapeDrawer *drawer) const;

  CQIllustratorShapeGeometry *getGeometry();

  void doSetGeometry(const CQIllustratorShapeGeometry *geom);

  void saveSVG(const CQIllustratorSaveData &saveData);
  void saveCmd(const CQIllustratorSaveData &saveData);

 protected:
  void updateBBox() const;

  void getPoints(std::vector<CPoint2D> &pi, std::vector<CPoint2D> &po) const;

 protected:
  CPoint2D c_;
  uint     n_;
  double   r1_, r2_;
  double   a1_, a2_;
};

class CQIllustratorStarShapeControlPoint : public CQIllustratorShapeControlPoint {
 public:
  CQIllustratorStarShapeControlPoint(CQIllustratorStarShape::ControlPointType type,
                                     const CPoint2D &p);

  CQIllustratorStarShapeControlPoint *dup() const;

  CQIllustratorStarShape::ControlPointType getType() const { return type_; }

  CPoint2D getPoint(const CQIllustratorShape *shape) const;

  void setPoint(CQIllustratorShape *shape, const CPoint2D &point);

 protected:
  CQIllustratorStarShape::ControlPointType type_;
};

//----------------

class CQIllustratorPolygonGeometry : public CQIllustratorShapeGeometry {
 public:
  typedef std::vector<CPoint2D> PointList;

 public:
  CQIllustratorPolygonGeometry(bool fixed=false, const CPoint2D &rcenter=CPoint2D(0,0),
                               const CMatrix2D m=CMatrix2D(), const PointList points=PointList()) :
   CQIllustratorShapeGeometry(fixed, rcenter, m), points_(points) {
  }

  CQIllustratorPolygonGeometry(const CQIllustratorPolygonGeometry &geometry) :
   CQIllustratorShapeGeometry(geometry), points_(geometry.points_) {
  }

  virtual CQIllustratorPolygonGeometry *dup() {
    return new CQIllustratorPolygonGeometry(*this);
  }

  friend class CQIllustratorPolygonShape;

 private:
  CQIllustratorPolygonGeometry &operator=(const CQIllustratorPolygonGeometry &);

 protected:
  PointList points_;
};

class CQIllustratorPolygonShape : public CQIllustratorShape {
 public:
  CQIllustratorPolygonShape(const PointList &points=PointList());
  CQIllustratorPolygonShape(const CQIllustratorPolygonShape &polygon);

  CQIllustratorPolygonShape *dup() const;

  const char *getClassName() const { return "polygon"; }

  void setPoints(const CPolygon2D &polygon);

  void addPoint(const CPoint2D &p);

  double distance(const CPoint2D &p) const;

  bool inside(const CPoint2D &p) const;

  CPoint2D getPoint(uint i) const;

  void setPoint(uint i, const CPoint2D &p);

  void getControlPoints(ControlPointList &points,
                        ControlType type=CONTROL_GEOMETRY) const;

  void setControlPoint(const CQIllustratorShapeControlPoint *point);

  bool addPoint(const CQIllustratorShapeControlPoint *before_point, const CPoint2D &p);

  bool doRemovePoint(const CQIllustratorShapeControlPoint *point);

  bool getPolygon(CPolygon2D &polygon) const;

  bool getPath(CPathShapePartList &path) const;

  void moveBy(const CPoint2D &d);

  void resizeBy(double dw, double dh);

  bool flip(bool x_axis);

  void drawShape(CQIllustratorShapeDrawer *drawer) const;

  CQIllustratorShapeGeometry *getGeometry();

  void doSetGeometry(const CQIllustratorShapeGeometry *geom);

  void saveSVG(const CQIllustratorSaveData &saveData);
  void saveCmd(const CQIllustratorSaveData &saveData);

 protected:
  void updateBBox() const;

 protected:
  PointList points_;
};

class CQIllustratorPolygonShapeControlPoint : public CQIllustratorShapeControlPoint {
 public:
  CQIllustratorPolygonShapeControlPoint(uint ind, const CPoint2D &p);

  CQIllustratorPolygonShapeControlPoint *dup() const;

  CPoint2D getPoint(const CQIllustratorShape *shape) const;

  void setPoint(CQIllustratorShape *shape, const CPoint2D &point);

  int getInd() const { return ind_; }

 protected:
  int ind_;
};

//----------------

class CQIllustratorPathGeometry : public CQIllustratorShapeGeometry {
 public:
  CQIllustratorPathGeometry(bool fixed=false, const CPoint2D &rcenter=CPoint2D(0,0),
                            const CMatrix2D m=CMatrix2D(),
                            const CPathShapePartList &parts=
                              CPathShapePartList()) :
   CQIllustratorShapeGeometry(fixed, rcenter, m), parts_(parts) {
  }

  CQIllustratorPathGeometry(const CQIllustratorPathGeometry &geometry) :
   CQIllustratorShapeGeometry(geometry), parts_(geometry.parts_) {
  }

  virtual CQIllustratorPathGeometry *dup() {
    return new CQIllustratorPathGeometry(*this);
  }

  friend class CPathShape;

 private:
  CQIllustratorPathGeometry &operator=(const CQIllustratorPathGeometry &);

 protected:
  CPathShapePartList parts_;
};

class CPathShape : public CQIllustratorShape {
 public:
  CPathShape(const CPathShapePartList &parts=
                          CPathShapePartList());
  CPathShape(const CPathShape &path);

  CPathShape *dup() const;

  const char *getClassName() const { return "path"; }

  const CPathShapePartList &getParts() const { return parts_; }

  bool getPolygon(CPolygon2D &polygon) const;

  bool getPath(CPathShapePartList &path) const;

  void moveBy(const CPoint2D &d);

  void startGroup();
  void endGroup();

  void setParts(const CPathShapePartList &parts);

  void addMoveTo(const CPoint2D &p);
  void addLineTo(const CPoint2D &p);
  void addCurveTo(const CPoint2D &p1, const CPoint2D &p2);
  void addCurveTo(const CPoint2D &p1, const CPoint2D &p2, const CPoint2D &p3);
  void addArcTo(const CPoint2D &c, double rx, double ry, double angle1, double angle2);
  void addClose();

  void addLineTo(uint ind, const CPoint2D &p);

  bool empty() const;

  double distance(const CPoint2D &p) const;

  bool inside(const CPoint2D &p) const;

  void getControlLines(ControlLineList &lines) const;

  void getLines(std::vector<CLine2D> &lines) const;

  void getControlPoints(ControlPointList &points,
                        ControlType type=CONTROL_GEOMETRY) const;

  void setControlPoint(const CQIllustratorShapeControlPoint *point);

  bool doRemovePoint(const CQIllustratorShapeControlPoint *point);

  CLine2D getLine(uint ind) const;

  void setLine(uint ind, const CLine2D &l);

  void setLineType(uint ind, CPathPartType type);

  CPoint2D getPoint(uint ind, uint ind1) const;

  void setPoint(uint ind, uint ind1, const CPoint2D &p);

  void setCornerPoint(uint ind);
  void setCurvePoint(uint ind);

  bool flip(bool x_axis);

  void drawShape(CQIllustratorShapeDrawer *drawer) const;

  CQIllustratorShapeGeometry *getGeometry();

  void doSetGeometry(const CQIllustratorShapeGeometry *geom);

  void saveSVG(const CQIllustratorSaveData &saveData);
  void saveCmd(const CQIllustratorSaveData &saveData);

  void processPath(CPathShapeProcess *process);

 protected:
  void updateBBox() const;

 protected:
  CPathShapePartList parts_;
  mutable int                    group_;
};

class CPathShapeControlLine : public CQIllustratorShapeControlLine {
 public:
  CPathShapeControlLine(uint ind, const CLine2D &l);

  CPathShapeControlLine *dup() const;

  CLine2D getLine(const CQIllustratorShape *shape) const;

  void setLine(CQIllustratorShape *shape, const CLine2D &l);

  uint getInd() const { return ind_; }

  void setType(CQIllustratorShape *shape, CPathPartType type);

 protected:
  uint ind_;
};

class CPathShapeControlPoint : public CQIllustratorShapeControlPoint {
 public:
  CPathShapeControlPoint(uint ind, const CPoint2D &p);

  CPathShapeControlPoint(uint ind, uint ind1, const CPoint2D &p);

  CPathShapeControlPoint *dup() const;

  CPoint2D getPoint(const CQIllustratorShape *shape) const;

  void setPoint(CQIllustratorShape *shape, const CPoint2D &point);

  uint getInd () const { return ind_ ; }
  uint getInd1() const { return ind1_; }

  bool isMaster() const { return (ind1_ == 0); }

  void setCornerNode(CQIllustratorShape *shape) const;
  void setCurveNode (CQIllustratorShape *shape) const;

 protected:
  uint ind_;
  uint ind1_;
};

//----------------

class CQIllustratorTextGeometry : public CQIllustratorShapeGeometry {
 public:
  CQIllustratorTextGeometry(bool fixed=false, const CPoint2D &rcenter=CPoint2D(0,0),
                            const CMatrix2D m=CMatrix2D(), const CPoint2D &p1=CPoint2D(),
                            const CPoint2D &p2=CPoint2D(), const std::string &str="",
                            CFontPtr font=CFontPtr(), CHAlignType halign=CHALIGN_TYPE_CENTER,
                            CVAlignType valign=CVALIGN_TYPE_CENTER) :
   CQIllustratorShapeGeometry(fixed, rcenter, m), p1_(p1), p2_(p2), str_(str), font_(font),
   halign_(halign), valign_(valign) {
  }

  CQIllustratorTextGeometry(const CQIllustratorTextGeometry &geometry) :
   CQIllustratorShapeGeometry(geometry), p1_(geometry.p1_), p2_(geometry.p2_), str_(geometry.str_),
   font_(geometry.font_), halign_(geometry.halign_), valign_(geometry.valign_) {
  }

  virtual CQIllustratorTextGeometry *dup() {
    return new CQIllustratorTextGeometry(*this);
  }

  friend class CQIllustratorTextShape;

 private:
  CQIllustratorTextGeometry &operator=(const CQIllustratorTextGeometry &);

 protected:
  CPoint2D    p1_, p2_;
  std::string str_;
  CFontPtr    font_;
  CHAlignType halign_;
  CVAlignType valign_;
};

class CQIllustratorTextShape : public CQIllustratorShape {
 public:
  enum ControlPointType {
    TYPE_LL, TYPE_UR
  };

 public:
  CQIllustratorTextShape(const CPoint2D &p1, const CPoint2D &p2,
                         const std::string &str, CFontPtr font=CFontPtr(),
                         CHAlignType halign=CHALIGN_TYPE_CENTER,
                         CVAlignType valign=CVALIGN_TYPE_CENTER);
  CQIllustratorTextShape(const CQIllustratorTextShape &text);

  CQIllustratorTextShape *dup() const;

  const char *getClassName() const { return "text"; }

  void getControlPoints(ControlPointList &points,
                        ControlType type=CONTROL_GEOMETRY) const;

  void setControlPoint(const CQIllustratorShapeControlPoint *point);

  CPoint2D getLL() const;
  CPoint2D getUR() const;

  void setLL(const CPoint2D &p);
  void setUR(const CPoint2D &p);

  std::string getText() const { return str_; }

  void setText(const std::string &str);

  CFontPtr getFont() const { return font_; }

  void setFont(CFontPtr font);

  CHAlignType getHAlign() const { return halign_; }
  CVAlignType getVAlign() const { return valign_; }

  void setHAlign(CHAlignType halign);
  void setVAlign(CVAlignType valign);

  int getCursorPos() const { return cursorPos_; }

  void setCursorPos(int cursorPos) { cursorPos_ = cursorPos; }

  bool getPolygon(CPolygon2D &polygon) const;

  bool getPath(CPathShapePartList &path) const;

  void moveBy(const CPoint2D &d);

  void resizeBy(double dw, double dh);

  bool flip(bool x_axis);

  void drawShape(CQIllustratorShapeDrawer *drawer) const;

  CQIllustratorShapeGeometry *getGeometry();

  void doSetGeometry(const CQIllustratorShapeGeometry *geom);

  void saveSVG(const CQIllustratorSaveData &saveData);
  void saveCmd(const CQIllustratorSaveData &saveData);

  void drawSelect(CQIllustratorShapeDrawer *drawer);

 protected:
  void updateBBox() const;

 protected:
  CPoint2D    p1_;
  CPoint2D    p2_;
  std::string str_;
  CFontPtr    font_;
  CHAlignType halign_;
  CVAlignType valign_;
  int         cursorPos_;
};

class CQIllustratorTextShapeControlPoint : public CQIllustratorShapeControlPoint {
 public:
  CQIllustratorTextShapeControlPoint(CQIllustratorTextShape::ControlPointType type,
                                     const CPoint2D &p);

  CQIllustratorTextShapeControlPoint *dup() const;

  CQIllustratorTextShape::ControlPointType getType() const { return type_; }

  CPoint2D getPoint(const CQIllustratorShape *shape) const;

  void setPoint(CQIllustratorShape *shape, const CPoint2D &point);

 protected:
  CQIllustratorTextShape::ControlPointType type_;
};

//----------------

class CQIllustratorGroupGeometry : public CQIllustratorShapeGeometry {
 public:
  CQIllustratorGroupGeometry(bool fixed=false, const CPoint2D &rcenter=CPoint2D(0,0),
                             const CMatrix2D m=CMatrix2D()) :
   CQIllustratorShapeGeometry(fixed, rcenter, m) {
  }

  CQIllustratorGroupGeometry(const CQIllustratorGroupGeometry &geometry) :
   CQIllustratorShapeGeometry(geometry) {
  }

  virtual CQIllustratorGroupGeometry *dup() {
    return new CQIllustratorGroupGeometry(*this);
  }

  friend class CQIllustratorGroupShape;

 private:
  CQIllustratorGroupGeometry &operator=(const CQIllustratorGroupGeometry &);
};

class CQIllustratorGroupShape : public CQIllustratorShape {
 public:
  CQIllustratorGroupShape();
  CQIllustratorGroupShape(const CQIllustratorGroupShape &group);

  CQIllustratorGroupShape *dup() const;

  const char *getClassName() const { return "group"; }

  void childrenChanged();

  void getControlPoints(ControlPointList &points,
                        ControlType type=CONTROL_GEOMETRY) const;

  void setControlPoint(const CQIllustratorShapeControlPoint *point);

  void scale(const CPoint2D &c, double sx, double sy);

  void rotate(double da);

  void transform(const CPoint2D &c, const CMatrix2D &m);

  bool getPolygon(CPolygon2D &polygon) const;

  bool getPath(CPathShapePartList &path) const;

  void getPolygons(std::vector<CPolygon2D> &polygons) const;

  void moveBy(const CPoint2D &d);

  bool flip(bool x_axis);

  void drawShape(CQIllustratorShapeDrawer *drawer) const;

  CQIllustratorShapeGeometry *getGeometry();

  void doSetGeometry(const CQIllustratorShapeGeometry *geom);

  void saveSVG(const CQIllustratorSaveData &saveData);
  void saveCmd(const CQIllustratorSaveData &saveData);

 protected:
  void updateBBox() const;
};

class CQIllustratorGroupShapeControlPoint : public CQIllustratorShapeControlPoint {
 public:
  CQIllustratorGroupShapeControlPoint(uint ind, const CPoint2D &p);

  CQIllustratorGroupShapeControlPoint *dup() const;

  CPoint2D getPoint(const CQIllustratorShape *shape) const;

  void setPoint(CQIllustratorShape *shape, const CPoint2D &point);

  int getInd() const { return ind_; }

 protected:
  int ind_;
};

#endif
##concat##CQIllustratorSizer.h
#ifndef CQIllustratorSizer_H
#define CQIllustratorSizer_H

#include <QPointF>
#include <QTransform>
#include <CBBox2D.h>

class CQIllustrator;
class CQIllustratorShape;
class CQIllustratorHandle;
class CQIllustratorShapeDrawer;

class CQIllustratorSizer {
 public:
  enum HandleType {
    HANDLE_NONE = 0,
    HANDLE_L    = (1<<0),
    HANDLE_B    = (1<<1),
    HANDLE_R    = (1<<2),
    HANDLE_T    = (1<<3),
    HANDLE_RC   = (1<<4),
    HANDLE_BL   = (HANDLE_B | HANDLE_L),
    HANDLE_BR   = (HANDLE_B | HANDLE_R),
    HANDLE_TL   = (HANDLE_T | HANDLE_L),
    HANDLE_TR   = (HANDLE_T | HANDLE_R)
  };

  enum OpType {
    OP_RESIZE,
    OP_ROTATE
  };

 public:
  CQIllustratorSizer(CQIllustrator *illustrator);

  HandleType getHandleType() const { return handle_; }

  HandleType getPressHandleType() const { return handle_; }

  void setPressHandleType  () { press_handle_ = handle_; }
  void resetPressHandleType() { press_handle_ = HANDLE_NONE; }

  OpType getOpType() const { return op_; }

  bool mousePress  (const QPointF &p);
  void mouseRelease(const QPointF &p);

  void updateShape(CQIllustratorShape *shape, const QPointF &oldPoint,
                   const QPointF &newPoint, bool equal_scale=false);

  bool updateActive(const QPointF &p);

  void toggleOp();

  void draw(CQIllustratorShapeDrawer *drawer, const CQIllustratorShape *shape);

 private:
  CQIllustrator *illustrator_;

  QTransform transform_;
  HandleType handle_;
  HandleType press_handle_;
  OpType     op_;

  CQIllustratorHandle *bl_corner_handle_;
  CQIllustratorHandle *br_corner_handle_;
  CQIllustratorHandle *tl_corner_handle_;
  CQIllustratorHandle *tr_corner_handle_;

  CQIllustratorHandle *bl_rotate_handle_;
  CQIllustratorHandle *br_rotate_handle_;
  CQIllustratorHandle *tl_rotate_handle_;
  CQIllustratorHandle *tr_rotate_handle_;

  CQIllustratorHandle *l_side_handle_;
  CQIllustratorHandle *b_side_handle_;
  CQIllustratorHandle *r_side_handle_;
  CQIllustratorHandle *t_side_handle_;

  CQIllustratorHandle *rcenter_handle_;
};

#endif
##concat##CQIllustratorSliceMode.h
#ifndef CQIllustratorSliceMode_H
#define CQIllustratorSliceMode_H

#include <CQIllustratorMode.h>
#include <CQIllustratorToolbar.h>

class CQIllustrator;
class CQIllustratorSliceMode;

class CQIllustratorSliceToolbar : public CQIllustratorToolbar {
  Q_OBJECT

 public:
  CQIllustratorSliceToolbar(CQIllustratorSliceMode *mode);

  const char *getTitle() const { return "Slice"; }

  QIcon getIcon();

  void addWidgets();

 private:
  CQIllustratorSliceMode *mode_;
};

class CQIllustratorSliceMode : public CQIllustratorMode {
 public:
  CQIllustratorSliceMode(CQIllustrator *illustrator);

  const char *getTitle() const { return "Slice"; }

  CQIllustratorSliceToolbar *createToolbar();

  CQMenuItem *createMenuItem(CQMenu *menu);

  CQIllustratorSliceToolbar *getToolbar() const { return toolbar_; }

  void handleMousePress  (const MouseEvent &e);
  void handleMouseRelease(const MouseEvent &e);
  void handleMouseDrag   (const MouseEvent &e);
  void handleMouseMove   (const MouseEvent &e);

  void drawOverlay(CQIllustratorShapeDrawer *drawer);

 private:
  CQIllustratorSliceToolbar *toolbar_;
};

#endif
##concat##CQIllustratorSnap.h
#include <QWidget>

class CQIllustrator;
class QCheckBox;
class QDoubleSpinBox;

class CQIllustratorSnapDock : public QWidget {
  Q_OBJECT

 public:
  CQIllustratorSnapDock(CQIllustrator *illustrator);

 private slots:
  void enabledSlot();
  void xPitchSlot(double xpitch);
  void yPitchSlot(double ypitch);

 private:
  CQIllustrator  *illustrator_;
  QCheckBox      *enabledCheck_;
  QDoubleSpinBox *xPitch_;
  QDoubleSpinBox *yPitch_;
};
##concat##CQIllustratorToolbar.h
#ifndef CQIllustratorToolbar_H
#define CQIllustratorToolbar_H

#include <QWidget>

class QToolButton;

class CQIllustratorMode;
class CQIllustratorShape;
class CQIllustratorShapeControlPoint;

class CQIllustratorToolbar : public QWidget {
  Q_OBJECT

 public:
  CQIllustratorToolbar(CQIllustratorMode *mode);

  virtual ~CQIllustratorToolbar() { }

  void init();

  virtual const char *getTitle() const = 0;

  virtual QIcon getIcon() = 0;

  virtual void addWidgets();

  virtual void setSelectedShape(const CQIllustratorShape *shape);

  virtual void setSelectedShapePoint(const CQIllustratorShape *shape,
                                     const CQIllustratorShapeControlPoint *point);

 private slots:
  void modeSlot();

  void createEditSlot();

 private:
  CQIllustratorMode *mode_;
  QToolButton       *createEditButton_;
};

#endif
##concat##CQIllustratorTransformMode.h
#ifndef CQIllustratorTransformMode_H
#define CQIllustratorTransformMode_H

#include <CQIllustrator.h>
#include <CQIllustratorMode.h>
#include <CQIllustratorToolbar.h>

class QCheckBox;

class CQTransformMoveTool;
class CQTransformScaleTool;
class CQTransformRotateTool;
class CQTransformSkewTool;
class CQAngleSpinBox;
class CQRealEdit;
class CQPointEdit;
class CQIllustratorTransformMode;

class CQIllustratorTransformToolbar : public CQIllustratorToolbar {
  Q_OBJECT

 public:
  CQIllustratorTransformToolbar(CQIllustratorTransformMode *mode);

  const char *getTitle() const { return "Transform"; }

  CQIllustrator *getIllustrator() const;

  QIcon getIcon();

  void addWidgets();

  void resetSelectMode();

 private slots:
  void resetSlot();
  void applySlot();

 private:
  CQIllustratorTransformMode *mode_;
  QTabWidget                 *tab_;
  CQTransformMoveTool        *moveTool_;
  CQTransformScaleTool       *scaleTool_;
  CQTransformRotateTool      *rotateTool_;
  CQTransformSkewTool        *skewTool_;
};

class CQIllustratorTransformMode : public CQIllustratorMode {
  Q_OBJECT

 public:
  CQIllustratorTransformMode(CQIllustrator *illustrator);

  const char *getTitle() const { return "Transform"; }

  CQIllustratorTransformToolbar *createToolbar();

  CQMenuItem *createMenuItem(CQMenu *menu);

  CQIllustratorTransformToolbar *getToolbar() const { return toolbar_; }

  void handleMouseRelease(const MouseEvent &e);
  void handleMouseDrag   (const MouseEvent &e);

  void drawOverlay(CQIllustratorShapeDrawer *drawer);

  QCursor getCursor() const;

 private:
  CQIllustratorTransformToolbar *toolbar_;
};

class CQTransformMoveTool : public QWidget {
  Q_OBJECT

 public:
  CQTransformMoveTool(CQIllustratorTransformToolbar *toolbar);

  void apply();

 private:
  CQIllustratorTransformToolbar *toolbar_;
  CQRealEdit                    *hedit_;
  CQRealEdit                    *vedit_;
  QCheckBox                     *relativeCheck_;
  QCheckBox                     *groupCheck_;
};

class CQTransformScaleTool : public QWidget {
 public:
  CQTransformScaleTool(CQIllustratorTransformToolbar *toolbar);

  void apply();

 private:
  CQIllustratorTransformToolbar *toolbar_;
  CQRealEdit                    *wedit_;
  CQRealEdit                    *hedit_;
  QCheckBox                     *equalCheck_;
  QCheckBox                     *groupCheck_;
};

class CQTransformRotateTool : public QWidget {
 public:
  CQTransformRotateTool(CQIllustratorTransformToolbar *toolbar);

  void apply();

 private:
  CQIllustratorTransformToolbar *toolbar_;
  CQAngleSpinBox                *angleEdit_;
  QCheckBox                     *groupCheck_;
};

class CQTransformSkewTool : public QWidget {
 public:
  CQTransformSkewTool(CQIllustratorTransformToolbar *toolbar);

  void apply();

 private:
  CQIllustratorTransformToolbar *toolbar_;
  CQRealEdit                    *hedit_;
  CQRealEdit                    *vedit_;
  QCheckBox                     *groupCheck_;
};

#endif
##concat##CQIllustratorUndoDock.h
#ifndef CQIllustratorUndoDock_H
#define CQIllustratorUndoDock_H

#include <QWidget>

class CQIllustrator;
class QListWidget;
class QListWidgetItem;

class CQIllustratorUndoDock : public QWidget {
  Q_OBJECT

 public:
  CQIllustratorUndoDock(CQIllustrator *illustrator);

  void reload();

 private slots:
  void itemSelectedSlot(QListWidgetItem *item);

  void undoChangedSlot();

 private:
  CQIllustrator *illustrator_;
  QListWidget   *list_;
};

#endif
##concat##CQIllustratorUndo.h
#ifndef CQIllustratorUndo_H
#define CQIllustratorUndo_H

#include <QObject>
#include <CUndo.h>
#include <CPoint2D.h>
#include <CQIllustratorData.h>
#include <CQIllustratorShape.h>

class CQIllustrator;

class CQIllustratorUndo : public QObject, public CUndo {
  Q_OBJECT

 public:
  typedef CQIllustratorData::ChangeType ChangeType;

  CQIllustratorUndo(CQIllustrator *illustrator);

  CQIllustrator *getIllustrator() const { return illustrator_; }

  bool addUndo(CUndoData *data);

  bool undo(uint n=1);
  bool redo(uint n=1);

  void emitUndoChanged();

 signals:
  void undoChanged();

 private slots:
  void objectCreated(CQIllustratorShape *shape);
  void objectDeleted(CQIllustratorShape *shape);

  void objectPreModify (CQIllustratorShape *shape, ChangeType changeType);
  void objectPostModify(CQIllustratorShape *shape, ChangeType changeType);

 private:
  CQIllustrator *illustrator_;
};

class CQIllustratorUndoSetShapeGeometry : public CUndoData {
 public:
  CQIllustratorUndoSetShapeGeometry(CQIllustratorUndo *undo, CQIllustratorShape *shape);

 ~CQIllustratorUndoSetShapeGeometry() { }

  bool exec();

  std::string getDesc() const;

 private:
  CQIllustratorUndo          *undo_;
  uint                        id_;
  CQIllustratorShapeGeometry *geom_;
};

class CQIllustratorUndoSetShapeStroke : public CUndoData {
 public:
  CQIllustratorUndoSetShapeStroke(CQIllustratorUndo *undo, CQIllustratorShape *shape);

 ~CQIllustratorUndoSetShapeStroke() { }

  bool exec();

  std::string getDesc() const;

 private:
  CQIllustratorUndo        *undo_;
  uint                      id_;
  CQIllustratorShapeStroke  stroke_;
};

class CQIllustratorUndoSetShapeFill : public CUndoData {
 public:
  CQIllustratorUndoSetShapeFill(CQIllustratorUndo *undo, CQIllustratorShape *shape);

 ~CQIllustratorUndoSetShapeFill() { }

  bool exec();

  std::string getDesc() const;

 private:
  CQIllustratorUndo      *undo_;
  uint                    id_;
  CQIllustratorShapeFill  fill_;
};

class CQIllustratorUndoCreateShape : public CUndoData {
 public:
  CQIllustratorUndoCreateShape(CQIllustratorUndo *undo, CQIllustratorShape *shape, bool create);

 ~CQIllustratorUndoCreateShape() { }

  bool exec();

  std::string getDesc() const;

 private:
  CQIllustratorUndo  *undo_;
  bool                create_;
  CQIllustratorShape *shape_;
  uint                id_;
};

#endif
##concat##CQIllustratorZoomMode.h
#ifndef CQIllustratorZoomMode_H
#define CQIllustratorZoomMode_H

#include <CQIllustratorMode.h>
#include <CQIllustratorToolbar.h>

class CQImageButton;
class CQIllustrator;
class CQIllustratorZoomMode;

class CQIllustratorZoomToolbar : public CQIllustratorToolbar {
  Q_OBJECT

 public:
  CQIllustratorZoomToolbar(CQIllustratorZoomMode *mode);

  const char *getTitle() const { return "Zoom"; }

  QIcon getIcon();

  void addWidgets();

 private slots:
  void zoomFitSlot();
  void zoomSelSlot();
  void zoomInSlot ();
  void zoomOutSlot();

 private:
  CQIllustratorZoomMode *mode_;
  CQImageButton         *zoomFitButton_;
  CQImageButton         *zoomSelButton_;
  CQImageButton         *zoomInButton_;
  CQImageButton         *zoomOutButton_;
};

class CQIllustratorZoomMode : public CQIllustratorMode {
 public:
  CQIllustratorZoomMode(CQIllustrator *illustrator);

  const char *getTitle() const { return "Zoom"; }

  CQIllustratorZoomToolbar *createToolbar();

  CQMenuItem *createMenuItem(CQMenu *menu);

  CQIllustratorZoomToolbar *getToolbar() const { return toolbar_; }

  void handleMousePress  (const MouseEvent &e);
  void handleMouseRelease(const MouseEvent &e);
  void handleMouseDrag   (const MouseEvent &e);
  void handleMouseMove   (const MouseEvent &e);

  void drawOverlay(CQIllustratorShapeDrawer *drawer);

 private:
  CQIllustratorZoomToolbar *toolbar_;
};

#endif
##concat##CQImageButton.h
#ifndef CQIMAGE_BUTTON_H
#define CQIMAGE_BUTTON_H

#include <QToolButton>
#include <CImageLib.h>

class CQImageButton : public QToolButton {
  Q_OBJECT

 private:
  QSize size_;

 public:
  CQImageButton(CImagePtr image);
  CQImageButton(const QString &fileName);
  CQImageButton(const char *data[]);
  CQImageButton(uchar *data, uint len);
  CQImageButton(const QPixmap &pixmap);

  virtual ~CQImageButton() { }

  QSize sizeHint() const;
  QSize minimumSizeHint() const;

 private:
  void init(CImagePtr image);
  void init(const QPixmap &pixmap);
};

#endif
##concat##CQImageGaussianBlur.h
#ifndef CQIMAGE_GAUSSIAN_BLUR_H
#define CQIMAGE_GAUSSIAN_BLUR_H

#include <QImage>
#include <CGaussianBlur.h>

class CQImageWrapper : public QImage {
 public:
  CQImageWrapper(QImage &image) :
   image_(image) {
  }

  void getPixelRange(int *x1, int *y1, int *x2, int *y2) const {
   *x1 = 0;
   *y1 = 0;
   *x2 = image_.width () - 1;
   *y2 = image_.height() - 1;
  }

  void getRGBA(int x, int y, double *r, double *g, double *b, double *a) const {
    QRgb rgb = image_.pixel(x, y);

    *r = qRed  (rgb)/255.0;
    *g = qGreen(rgb)/255.0;
    *b = qBlue (rgb)/255.0;
    *a = qAlpha(rgb)/255.0;
  }

  void setRGBA(int x, int y, double r, double g, double b, double a) {
    QRgb rgb = qRgba(int(r*255), int(g*255), int(b*255), int(a*255));

    image_.setPixel(x, y, rgb);
  }

 private:
  friend class CQImageGaussianBlur;

  QImage &image_;
};

class CQImageGaussianBlur {
 public:
  CQImageGaussianBlur(QImage image) :
   image_(image) {
  }

  void blur(QImage &dst, double bx, double by, int nx, int ny) {
    CGaussianBlur<CQImageWrapper> blur;

    CQImageWrapper dst1(dst);

    blur.blur(image_, dst1, bx, by, nx, ny);
  }

 private:
  CQImageWrapper image_;
};

#endif
##concat##CQImagePreview.h
#ifndef CQIMAGE_PREVIEW_H
#define CQIMAGE_PREVIEW_H

#include <CImageLib.h>

#include <QWidget>

class QResizeEvent;
class QPaintEvent;

class CQImagePreviewCanvas;
class CQScrollArea;

class CQImagePreview : public QWidget {
  Q_OBJECT

 public:
  CQImagePreview(QWidget *parent=0);

 ~CQImagePreview();

  CImagePtr getImage() const;

  void setImage(CImagePtr image);

  void setBackground(const CRGBA &rgba);

  CQScrollArea *getScrollArea() const { return sarea_; }

  void sendCancelSignal();

  void scrollUp(bool page=false);
  void scrollDown(bool page=false);
  void scrollLeft(bool page=false);
  void scrollRight(bool page=false);

 signals:
  void cancelSignal();

 private slots:
  void canvasUpdateSlot();

 private:
  CQImagePreviewCanvas *canvas_;
  CQScrollArea         *sarea_;
};

class CQImagePreviewCanvas : public QWidget {
  Q_OBJECT

 public:
  CQImagePreviewCanvas(CQImagePreview *view);

  virtual ~CQImagePreviewCanvas();

  CImagePtr getImage() const { return image_; }

  void setImage(CImagePtr image);

  double getZoomFactor() const { return zoom_factor_; }

  void setZoomFactor(double factor);

  void setFillScreen(bool fill_screen) { fill_screen_ = fill_screen; }
  void setKeepAspect(bool keep_aspect) { keep_aspect_ = keep_aspect; }

  bool getFillScreen() const { return fill_screen_; }
  bool getKeepAspect() const { return keep_aspect_; }

  void setBackground(const CRGBA &rgba);

  void zoomIncrease();
  void zoomDecrease();

  void resizeEvent(QResizeEvent *e);
  void paintEvent(QPaintEvent *e);

  void keyPressEvent(QKeyEvent *e);

 private:
  CQImagePreview *view_;
  CImagePtr       image_;
  double          zoom_factor_;
  bool            fill_screen_;
  bool            keep_aspect_;
  CRGBA           bg_;
};

#endif
##concat##CQIntegerEdit.h
#ifndef CQINTEGER_EDIT_H
#define CQINTEGER_EDIT_H

#include <QLineEdit>

class CQIntegerEdit : public QLineEdit {
  Q_OBJECT

 private:
  int value_;

 public:
  CQIntegerEdit(QWidget *parent, int value=0);
  CQIntegerEdit(int value=0);

  virtual ~CQIntegerEdit() { }

  void setValue(int value);

  int getValue() const;

 private:
  void init(const QString &name, int value);

 private slots:
  void editingFinishedI();

 signals:
  void valueChanged(int);

 private:
  void valueToWidget();
  bool widgetToValue();
};

#endif
##concat##CQLayerOption.h
#include <CQOptionToolSet.h>

class CQLayerOptionDialog;
class CQIllustrator;
class CQIllustratorShape;
class QLabel;
class QListWidget;
class QListWidgetItem;

class CQLayerOptionTool : public CQOptionTool {
  Q_OBJECT

 public:
  CQLayerOptionTool(CQIllustrator *illustrator);

  CQIllustrator *getIllustrator() const { return illustrator_; }

  CQOptionToolDialog *getDialog();

  void updateLayer();

  void reloadLayers();

 signals:
  void valueChanged(const QString &name);

 private slots:
  void populateSlot();

 private:
  CQIllustrator       *illustrator_;
  CQLayerOptionDialog *dialog_;
  QLabel              *label_;
};

class CQLayerOptionDialog : public CQOptionToolDialog {
  Q_OBJECT

 public:
  CQLayerOptionDialog(CQLayerOptionTool *tool);

  void populate();

 private:
  void initWidgets();

 signals:
  void valueChanged(const QString &name);

 private slots:
  void itemSelectedSlot(QListWidgetItem *item);

  void addLayerSlot();

 private:
  CQLayerOptionTool *tool_;
  QListWidget       *list_;
};
##concat##CQLineCap.h
#ifndef CQLINE_CAP_H
#define CQLINE_CAP_H

#include <QComboBox>
#include <CLineCapType.h>

class CQLineCap : public QComboBox {
  Q_OBJECT

 public:
  CQLineCap(QWidget *parent=0);

  void setLineCap(CLineCapType cap);

  CLineCapType getLineCap() const;

 private slots:
  void capChangedSlot(int value);

 signals:
  void valueChanged(CLineCapType cap);
};

#endif
##concat##CQLineDash.h
#ifndef CQLINE_DASH_H
#define CQLINE_DASH_H

#include <QLineEdit>
#include <CLineDash.h>

class QMenu;

class CQLineDash : public QLineEdit {
  Q_OBJECT

 public:
  CQLineDash(QWidget *parent=0);

  void setLineDash(const CLineDash &dash);

  CLineDash getLineDash() const;

 private:
  void contextMenuEvent(QContextMenuEvent *);

 private slots:
  void dashChangedSlot();
  void menuItemActivated(QAction *);

 signals:
  void valueChanged(const CLineDash &dash);

 private:
  CLineDash  dash_;
  QMenu     *menu_;
};

#endif
##concat##CQLineJoin.h
#ifndef CQLINE_JOIN_H
#define CQLINE_JOIN_H

#include <QComboBox>
#include <CLineJoinType.h>

class CQLineJoin : public QComboBox {
  Q_OBJECT

 public:
  CQLineJoin(QWidget *parent=0);

  void setLineJoin(CLineJoinType pen);

  CLineJoinType getLineJoin() const;

 private slots:
  void joinChangedSlot(int join);

 signals:
  void valueChanged(CLineJoinType join);
};

#endif
##concat##CQMatrix2D.h
#ifndef CQMATRIX_2D_H
#define CQMATRIX_2D_H

#include <QWidget>
#include <CMatrix2D.h>

class CQTableWidget;

class CQMatrix2D : public QWidget {
  Q_OBJECT

 private:
  CQTableWidget *table_;
  CMatrix2D      m_;

 public:
  CQMatrix2D(QWidget *parent, const CMatrix2D &m=CMatrix2D(CMATRIX_TYPE_IDENTITY));
  CQMatrix2D(const CMatrix2D &m=CMatrix2D(CMATRIX_TYPE_IDENTITY));

  QSize minimumSizeHint() const;
  QSize sizeHint() const;

  CQTableWidget *getTableWidget() const { return table_; }

  void setValue(const CMatrix2D &m);

  const CMatrix2D &getValue() const { return m_; }

  void setValue(int r, int c, double v);

  double getValue(int r, int c) const;

 private:
  void init();
  void updateValues();

 signals:
  void valueChanged();
};

#endif
##concat##CQObjectOption.h
#include <CQOptionToolSet.h>

class CQObjectOptionDialog;
class CQIllustrator;
class CQIllustratorShape;
class QLabel;
class QTreeWidget;
class QTreeWidgetItem;

class CQObjectOptionTool : public CQOptionTool {
  Q_OBJECT

 public:
  CQObjectOptionTool(CQIllustrator *illustrator);

  CQOptionToolDialog *getDialog();

  void selectShape(const std::string &name);

 signals:
  void valueChanged(const QString &name);

 private slots:
  void selectionChangedSlot();
  void populateSlot();

 private:
  CQIllustrator        *illustrator_;
  CQObjectOptionDialog *dialog_;
  QLabel               *label_;
};

class CQObjectOptionDialog : public CQOptionToolDialog {
  Q_OBJECT

 public:
  CQObjectOptionDialog(CQObjectOptionTool *tool);

  void populate(CQIllustrator *illustrator);

 private:
  void initWidgets();
  void updateWidgets();

  void populateChildren(CQIllustrator *illustrator, QTreeWidgetItem *pitem,
                        const CQIllustratorShape *shape);

 signals:
  void valueChanged(const QString &name);

 private slots:
  void itemSelectedSlot(QTreeWidgetItem *item, int pos);

 private:
  CQObjectOptionTool *tool_;
  QTreeWidget        *list_;
};
##concat##CQOptionToolSet.h
#ifndef CQOptionToolSet_H
#define CQOptionToolSet_H

#include <QFrame>
#include <QScrollArea>
#include <QToolButton>
#include <CQWinWidget.h>

#include <list>

class CQOptionToolSet;
class CQOptionToolArea;
class CQOptionToolDialogArea;

//! Widget for option dialog
class CQOptionToolDialog : public QWidget {
 public:
  CQOptionToolDialog();
};

//! Widget to contain option and popup option panel
class CQOptionTool : public QWidget {
  Q_OBJECT

 public:
  CQOptionTool();

  virtual CQOptionToolDialog *getDialog() = 0;

  CQOptionToolArea *getArea() const { return area_; }

  void setArea(CQOptionToolArea *area);

  void popup  (CQOptionToolDialogArea *dialogArea, QWidget *popupArea);
  void popdown(CQOptionToolDialogArea *area);

 signals:
  void poppingUp();
  void poppedUp();

  void poppingDown();
  void poppedDown();

 private:
  CQOptionToolArea *area_;
};

//! Widget to contain the popup dialog placed in the popup area
class CQOptionToolDialogArea : public CQWinWidget {
  Q_OBJECT

 public:
  CQOptionToolDialogArea(CQOptionToolSet *set);

  void setWidget(QWidget *w);

  void updateSize();

 private slots:
  void closedSlot();

 private:
  CQOptionToolSet *set_;
  QWidget         *w_;
};

class CQOptionToolMenu : public QToolButton {
  Q_OBJECT

 public:
  CQOptionToolMenu();

 private slots:
  void updatePixmap(bool checked);

 private:
  QPixmap on_pixmap_;
  QPixmap off_pixmap_;
};

//! widget to hold the tool and popup menu button
class CQOptionToolArea : public QFrame {
  Q_OBJECT

 public:
  CQOptionToolArea(CQOptionToolSet *toolset, CQOptionTool *tool);

  CQOptionTool *getTool() const { return tool_; }

  CQOptionToolMenu *getMenuButton() const { return menuButton_; }

 private slots:
  void menuPressed(bool show);

 private:
  CQOptionToolSet  *toolset_;
  CQOptionTool     *tool_;
  CQOptionToolMenu *menuButton_;
};

//! Widget to contain list of options
//! each option has a 'optional' popup floating option panel
class CQOptionToolSet : public QWidget {
  Q_OBJECT

 public:
  CQOptionToolSet(QWidget *parent=0);

  void setPopupArea(QWidget *popupArea);

  void addOption(CQOptionTool *tool);

  void popup(CQOptionToolArea *tool);
  void popdown(CQOptionToolArea *tool);

 public slots:
  void popdown();

 private:
  typedef std::list<QWidget *> ToolList;

  QWidget                *popupArea_;
  CQOptionToolDialogArea *dialogArea_;
  ToolList                toolList_;
  CQOptionToolArea       *currentTool_;
};

#endif
##concat##CQPointEdit.h
#ifndef CQPOINT_EDIT_H
#define CQPOINT_EDIT_H

#include <QLineEdit>
#include <QValidator>
#include <CPoint2D.h>

class CQPointEdit : public QLineEdit {
  Q_OBJECT

 private:
  CPoint2D point_;

 public:
  CQPointEdit(QWidget *parent, const CPoint2D &value=CPoint2D(0,0));
  CQPointEdit(const CPoint2D &value=CPoint2D(0,0));

  virtual ~CQPointEdit() { }

  void setValue(const CPoint2D &point=CPoint2D(0,0));

  const CPoint2D &getValue() const;

 private:
  void init(const QString &name, const CPoint2D &value);

 private slots:
  void editingFinishedI();
  void returnPressedI();

 signals:
  void valueChanged();
  void valueAccepted();

 private:
  void pointToWidget();

  bool widgetToPoint();

 public:
  static std::string pointToString(const CPoint2D &point);

  static QValidator::State stringToPoint(const std::string &text, CPoint2D &point);
};

#endif
##concat##CQPropertiesOption.h
#include <CQOptionToolSet.h>
#include <CQPointEdit.h>
#include <CQTableWidget.h>
#include <CQIllustratorShape.h>

#include <QPointer>

class CQIllustratorShape;
class CQPropertiesOptionDialog;
class CQControlPointsTable;
class CQIllustrator;
class CQPointEdit;
class CQMatrix2D;
class CQTransformPanel;

class QLabel;
class QLineEdit;
class QTabWidget;
class CQRealEdit;
class CQAngleSpinBox;

class CQPropertiesOptionTool : public CQOptionTool {
  Q_OBJECT

 public:
  CQPropertiesOptionTool(CQIllustrator *illustrator);

  CQIllustrator *getIllustrator() const { return illustrator_; }

  CQOptionToolDialog *getDialog();

  void setObject(CQIllustratorShape *shape);

  void emitValueChanged();

 signals:
  void valueChanged();

 private slots:
  void selectionChangedSlot();

 private:
  CQIllustrator            *illustrator_;
  CQPropertiesOptionDialog *dialog_;
  QLabel                   *label_;
};

class CQPropertiesOptionDialog : public CQOptionToolDialog {
  Q_OBJECT

 public:
  CQPropertiesOptionDialog(CQPropertiesOptionTool *tool);

  CQIllustrator *getIllustrator() const;

  void update(const CQIllustratorShape *shape);

 private:
  void initWidgets();
  void updateWidgets();

 private slots:
  void updateShape();

  void replaceMatrixSlot();
  void appendMatrixSlot();
  void resetMatrixSlot();

 private:
  CQPropertiesOptionTool *tool_;
  std::string             name_;
  QTabWidget             *tab_;
  QLineEdit              *nameEdit_;
  QLineEdit              *classEdit_;
  CQPointEdit            *posEdit_;
  CQPointEdit            *sizeEdit_;
  QLineEdit              *textEdit_;
  CQControlPointsTable   *table_;
  CQTransformPanel       *transformPanel_;
  QLineEdit              *filterEdit_;
};

//------

class CQControlPointsTable;

class CQControlPointItem : public CQTableWidgetItem {
 public:
  enum { TYPE = QTableWidgetItem::UserType + 1 };

  CQControlPointItem(CQControlPointsTable *t, const CQIllustratorShape *shape,
                     CQIllustratorShapeControlPoint *point);

 ~CQControlPointItem();

  CQIllustratorShapeControlPoint *getPoint() const { return point_; }

  CQControlPointItem *clone() const;

  QString getString();

  QWidget *createEditor(QWidget *parent) const;

  void setEditorData();

  void getEditorData(QString &str);

  bool sizeHint(const QStyleOptionViewItem &option, QSize &size) const;

 private:
  CQControlPointsTable           *table_;
  const CQIllustratorShape       *shape_;
  CQIllustratorShapeControlPoint *point_;
  mutable QPointer<CQPointEdit>   edit_;
};

class CQControlPointsTable : public CQTableWidget {
  Q_OBJECT

 public:
  CQControlPointsTable(CQPropertiesOptionDialog *dialog);

  CQIllustrator *getIllustrator() const;

  void clear();

  void addPoint(const CQIllustratorShape *shape, uint pos, CQIllustratorShapeControlPoint *point);

 private slots:
  void updatePointsSlot();

 private:
  CQPropertiesOptionDialog *dialog_;
};

class CQTransformPanel : public QWidget {
  Q_OBJECT

 public:
  CQTransformPanel(CQPropertiesOptionDialog *dialog);

  CQMatrix2D *getMatrix() const { return matrix_; }

  CMatrix2D getNewMatrix() const;

 private:
  CQPropertiesOptionDialog *dialog_;
  CQMatrix2D               *matrix_;
  QTabWidget               *tabWidget_;
  CQRealEdit               *translateXEdit_;
  CQRealEdit               *translateYEdit_;
  CQRealEdit               *scaleXEdit_;
  CQRealEdit               *scaleYEdit_;
  CQAngleSpinBox           *rotateAngleEdit_;
  CQRealEdit               *skewXEdit_;
  CQRealEdit               *skewYEdit_;
};
##concat##CQRadioButtons.h
#ifndef CQRADIO_BUTTONS_H
#define CQRADIO_BUTTONS_H

#include <vector>
#include <QWidget>

class QRadioButton;
class QLayout;

class CQRadioButtons : public QWidget {
  Q_OBJECT

 public:
  CQRadioButtons(QWidget *parent=0);

  virtual ~CQRadioButtons();

  void addButton(const QString &name);

  int     getCurrentValue() const;
  QString getCurrentName () const;

 protected:
  void addButtons(const std::vector<QString> &names);

  virtual QLayout *createLayout(QWidget *parent);

  virtual void addWidget(QWidget *widget);

 protected slots:
  void valueChangedI(bool value);

 signals:
  void valueChanged(int id);
  void valueChanged(const QString &d);

 protected:
  bool                        hasLayout_;
  std::vector<QRadioButton *> buttons_;
};

class CQHRadioButtons : public CQRadioButtons {
 public:
  CQHRadioButtons(QWidget *parent, const char *name, ...);
  CQHRadioButtons(QWidget *parent=0);

 protected:
  QLayout *createLayout(QWidget *parent);

  void addWidget(QWidget *widget);
};

class CQVRadioButtons : public CQRadioButtons {
 public:
  CQVRadioButtons(QWidget *parent, const char *name, ...);
  CQVRadioButtons(QWidget *parent=0);

 protected:
  QLayout *createLayout(QWidget *parent);

  void addWidget(QWidget *widget);
};

class CQToolbarRadioButtons : public CQRadioButtons {
 public:
  CQToolbarRadioButtons(QWidget *parent, const char *title, const char *name, ...);
  CQToolbarRadioButtons(QWidget *parent, const char *title);

 protected:
  QLayout *createLayout(QWidget *parent);

  void addWidget(QWidget *widget);

 protected:
  QString title_;
};

#endif
##concat##CQRealEdit.h
#ifndef CQREAL_EDIT_H
#define CQREAL_EDIT_H

#include <QLineEdit>
#include <QAction>

class QDoubleValidator;
class QContextMenuEvent;
class QMenu;

class CQRealEdit : public QLineEdit {
  Q_OBJECT

 public:
  CQRealEdit(QWidget *parent, double value=0.0);
  CQRealEdit(double value=0.0);

  virtual ~CQRealEdit() { }

  void setValue(double value);

  double getValue() const;

  void setRange(double lower, double upper, int decimals=0);

  void addMenuValue(double value);

 private:
  void init(const QString &name, double value);

  void contextMenuEvent(QContextMenuEvent *);

 private slots:
  void editingFinishedI();
  void menuItemActivated(QAction *);

 signals:
  void valueChanged(double);

 private:
  void valueToWidget();
  bool widgetToValue();

 private:
  double            value_;
  QDoubleValidator *validator_;
  QMenu            *menu_;
};

class CQRealEditAction : public QAction {
 public:
  CQRealEditAction(double value);

  double getValue() const { return value_; }

 private:
  double value_;
};

#endif
##concat##CQScrollArea.h
#ifndef CQScrollArea_H
#define CQScrollArea_H

#include <QWidget>

class QScrollBar;
class QPainter;

class CQScrollArea : public QWidget {
  Q_OBJECT

 public:
  CQScrollArea(QWidget *widget);

  QWidget *getWidget() const { return widget_; }

  void showHBar(bool flag);
  void showVBar(bool flag);

  void setCornerWidget(QWidget *w);

  void setXSize(int x_size);
  void setYSize(int y_size);

  int getXSize() const { return x_size_; }
  int getYSize() const { return y_size_; }

  void setXOffset(int x_offset);
  void setYOffset(int y_offset);

  int getXOffset() const { return x_offset_; }
  int getYOffset() const { return y_offset_; }

  void setXPageStep(int x);
  void setYPageStep(int y);

  void scrollUp(bool page=false);
  void scrollDown(bool page=false);
  void scrollLeft(bool page=false);
  void scrollRight(bool page=false);

  void ensureVisible(int x, int y, int xmargin=50, int ymargin=50);

  void updateScrollbars();

 private slots:
  void hscrollSlot(int value);
  void vscrollSlot(int value);

 signals:
  void updateArea();

 private:
  QWidget    *widget_;
  QScrollBar *hbar_;
  QScrollBar *vbar_;
  int         x_size_;
  int         y_size_;
  int         x_offset_;
  int         y_offset_;
};

#endif
##concat##CQStrokeOption.h
#include <CLineDash.h>
#include <CQOptionToolSet.h>
#include <CQIllustratorShape.h>

class CQIllustratorShapeStroke;
class CQStrokeOptionDialog;
class CQStrokeOptionSwab;
class CQColorChooser;
class QPaintEvent;
class CQLineDash;
class CQLineCap;
class CQLineJoin;
class QDoubleSpinBox;

class CQStrokeOptionTool : public CQOptionTool {
  Q_OBJECT

 public:
  CQStrokeOptionTool(CQIllustrator *illustrator);

  CQOptionToolDialog *getDialog();

  CQIllustrator *getIllustrator() const { return illustrator_; }

 signals:
  void valueChanged(const CQIllustratorShapeStroke &stroke);

 private slots:
  void selectionChangedSlot();

 private:
  CQIllustrator        *illustrator_;
  CQStrokeOptionDialog *dialog_;
  CQStrokeOptionSwab   *swab_;
};

class CQStrokeOptionDialog : public CQOptionToolDialog {
  Q_OBJECT

 public:
  CQStrokeOptionDialog(CQStrokeOptionTool *tool);

  void setStroke(const CQIllustratorShapeStroke &stroke);

  const CQIllustratorShapeStroke &getStroke() const { return stroke_; }

 private:
  void initWidgets();
  void updateWidgets();

 private slots:
  void colorSlot  (const QColor &color);
  void widthSlot  (double);
  void opacitySlot(double);
  void dashSlot   (const CLineDash &dash);
  void capSlot    (CLineCapType cap);
  void joinSlot   (CLineJoinType join);
  void mitreSlot  (double);

  void setDefaultSlot();

 signals:
  void valueChanged(const CQIllustratorShapeStroke &stroke);

 private:
  CQStrokeOptionTool       *tool_;
  CQIllustratorShapeStroke  stroke_;
  CQColorChooser           *colorChooser_;
  QDoubleSpinBox           *widthEdit_;
  QDoubleSpinBox           *opacityEdit_;
  CQLineDash               *dashEdit_;
  CQLineCap                *capEdit_;
  CQLineJoin               *joinEdit_;
  QDoubleSpinBox           *mitreEdit_;
};
##concat##CQSwatch.h
#ifndef CQSwatch_H
#define CQSwatch_H

#include <QWidget>

class QGridLayout;

class CQSwatch : public QWidget {
 public:
  CQSwatch();
  CQSwatch(QWidget *widget);
  CQSwatch(const char *title, QWidget *w);
  CQSwatch(const char *title, QWidget *w1, QWidget *w2);
  CQSwatch(const char *title, QWidget *w1, QWidget *w2, QWidget *w3);
  CQSwatch(const char *title, QWidget *w1, QWidget *w2, QWidget *w3, QWidget *w4);

  void setTitle(const char *title);

  void addWidget(QWidget *w);

  void addWidget(QWidget *w, int rows, int cols);

  void addSeparator();

 private:
  void init();

 private:
  QGridLayout *grid_;
  int          pos_;
  bool         has_title_;
};

#endif
##concat##CQTableWidget.h
#ifndef CQTableWidget_H
#define CQTableWidget_H

#include <QTableWidget>

#include <cassert>
#include <vector>
#include <map>

class CQTableWidget;

class CQTableWidgetItem : public QTableWidgetItem {
 public:
  // run-time type ID that is unique for each item
  // e.g. QTableWidgetItem::UserType + N
  static void setType(uint type) { type_ = type; }
  static uint getType() { return type_; }

  static bool isType(uint type) { return type == type_; }

  //------

  CQTableWidgetItem(CQTableWidget *t);

 ~CQTableWidgetItem() { }

  // clone new item
  virtual CQTableWidgetItem *clone() const = 0;

  // create edit widget for item
  virtual QWidget *createEditor(QWidget *parent) const = 0;

  // update edit widget from current item's data
  virtual void setEditorData() = 0;

  // update current item's data from edit widget
  virtual void getEditorData(QString &str) = 0;

  // get hint to item size
  virtual bool sizeHint(const QStyleOptionViewItem &, QSize &) const { return false; }

  // drawing override for static (not editted) item
  virtual bool paint(QPainter *, const QStyleOptionViewItem &) const { return false; }

  // set string value
  virtual QString getString() = 0;

  virtual bool validate() const { return true; }

  // draw background in correct color for item state when editing
  void paintBackground(QPainter *painter, const QStyleOptionViewItem &option) const;

  // set correct pen color to draw text
  void setTextPen(QPainter *painter, const QStyleOptionViewItem &option) const;

 protected:
  static uint type_;

  CQTableWidget *t_;
};

class CQTableWidget : public QTableWidget {
  Q_OBJECT

 public:
  CQTableWidget(QWidget* parent = 0);

  virtual ~CQTableWidget();

  void registerType(uint type, CQTableWidgetItem *item);

  void setColumnLabel(int col, const QString &label);
  void setRowLabel(int row, const QString &label);

  void setColumnLabels(const QStringList &labels);
  void setRowLabels(const QStringList &labels);

  template<typename T>
  T *createItem(int row, int column) {
    uint type = T::getType();

    return dynamic_cast<T *>(createItem(row, column, type));
  }

  template<typename T>
  T *getItem(int row, int column) {
    QTableWidgetItem *i = item(row, column);

    CQTableWidgetItem *i1 = dynamic_cast<CQTableWidgetItem *>(i);
    assert(i1 != 0);

    assert(i1->getType() == T::getType());

    return dynamic_cast<T *>(i1);
  }

  CQTableWidgetItem *createItem(int row, int column, uint type);

  void setItem(int row, int column, CQTableWidgetItem *item);

  void setItem(int row, int column, const QString &str);

  void setItem(int row, int column, QWidget *w);

  void fixTableColumnWidths();

  void emitValueChanged(int row, int col);

 protected:
  void showEvent(QShowEvent *);

  void fixTableColumnWidths(QTableWidget *table, int max_len, bool init);

 protected:
  typedef std::map<uint,CQTableWidgetItem*> TypeList;

  TypeList types_;

 signals:
  void valueChanged(int row, int col);
};

#endif
##concat##CQToolBar.h
#ifndef CQTOOLBAR_H
#define CQTOOLBAR_H

#include <QToolBar>
#include <QAbstractButton>

#include <CQMenu.h>

class CQToolBar {
 private:
  QMainWindow  *main_window_;
  QToolBar     *toolbar_;

 public:
  CQToolBar(QMainWindow *main_window, const QString &name,
            Qt::ToolBarArea area=Qt::TopToolBarArea) :
   main_window_(main_window) {
    toolbar_ = new QToolBar(name);

    main_window->addToolBar(area, toolbar_);

    setIconSize(QSize(16,16));
  }

  QMainWindow *getMainWindow() const { return main_window_; }

  QToolBar *getToolBar() const { return toolbar_; }

  void setIconSize(const QSize &iconSize) {
    toolbar_->setIconSize(iconSize);
  }

  QAction *addItem(CQMenuItem *item) {
    QAction *action = item->getAction();

    return addItem(action);
  }

  QAction *addItem(QAction *action) {
    toolbar_->addAction(action);

    return action;
  }

  QAction *addWidget(QWidget *widget) {
    return toolbar_->addWidget(widget);
  }

  QAction *addWidget(QWidget *widget, bool checked) {
    QAction *action = toolbar_->addWidget(widget);

    QAbstractButton *button = qobject_cast<QAbstractButton *>(widget);

    if (button) {
      button->setCheckable(true);
      button->setChecked(checked);
    }

    return action;
  }

  QAction *addSeparator() {
    return toolbar_->addSeparator();
  }

  void setAllowedAreas(Qt::ToolBarAreas areas) {
    toolbar_->setAllowedAreas(areas);
  }

  void setVisible(bool visible) {
    toolbar_->setVisible(visible);
  }
};

#endif
##concat##CQuadTree.h
#ifndef CQUAD_TREE_H
#define CQUAD_TREE_H

#include <list>
#include <cassert>

// quad tree containing pointers to items of type DATA with an associated bbox of type BBOX
//
// the tree is split when the number of elements is greater than or equal to the auto
// split limit
//
// tree does not take ownership of data. The application must ensure elements are not
// deleted while in the tree and are deleted when required.
//
// DATA must support:
//   const BBOX &bbox = data->getBBox();
//
// BBOX must support:
//   constructor BBOX(l, b, r, t);
//
//   T l = bbox.getLeft  ();
//   T b = bbox.getBottom();
//   T r = bbox.getRight ();
//   T t = bbox.getTop   ();
//
template<typename DATA, typename BBOX, typename T=double>
class CQuadTree {
 public:
  typedef std::list<DATA *> DataList;

 private:
  CQuadTree *parent_;   // parent tree (0 if root)
  BBOX       bbox_;     // bounding box of tree
  DataList   dataList_; // data list
  CQuadTree *bl_tree_;  // bottom left sub tree
  CQuadTree *br_tree_;  // bottom right sub tree
  CQuadTree *tl_tree_;  // top left sub tree
  CQuadTree *tr_tree_;  // top right sub tree

 public:
  explicit CQuadTree(const BBOX &bbox=BBOX(1,1,-1,-1)) :
   parent_(0), bbox_(bbox), bl_tree_(0), br_tree_(0), tl_tree_(0), tr_tree_(0) {
  }

 ~CQuadTree() {
    delete bl_tree_;
    delete br_tree_;
    delete tl_tree_;
    delete tr_tree_;
  }

 private:
  CQuadTree(CQuadTree *parent, const BBOX &bbox) :
   parent_(parent), bbox_(bbox), bl_tree_(0), br_tree_(0), tl_tree_(0), tr_tree_(0) {
  }

 public:
  // reset quad tree
  void reset() {
    dataList_.clear();

    delete bl_tree_; bl_tree_ = 0;
    delete br_tree_; br_tree_ = 0;
    delete tl_tree_; tl_tree_ = 0;
    delete tr_tree_; tr_tree_ = 0;
  }

  // get bounding box
  const BBOX &getBBox() const { return bbox_; }

  // get data list
  const DataList &getDataList() const { return dataList_; }

  // get auto split limit
  static uint getAutoSplitLimit() {
    return *getAutoSplitLimitP();
  }

  // set auto split limit
  static void setAutoSplitLimit(uint limit) {
    *getAutoSplitLimitP() = limit;
  }

  // get auto split limit
  static uint getMinTreeSize() {
    return *getMinTreeSizeP();
  }

  // set auto split limit
  static void setTreeSize(uint limit) {
    *getMinTreeSizeP() = limit;
  }

  // get parent tree
  CQuadTree *getParent() const { return parent_; }

  // get sub trees
  CQuadTree *getBLTree() const { return bl_tree_; }
  CQuadTree *getBRTree() const { return br_tree_; }
  CQuadTree *getTLTree() const { return tl_tree_; }
  CQuadTree *getTRTree() const { return tr_tree_; }

  // has child trees
  bool hasChildren() const { return bl_tree_ != 0; }

  //----------

 public:
  // add data item to the tree
  void add(DATA *data) {
    const BBOX &bbox = data->getBBox();

    if (! inside(bbox))
      grow(bbox);

    addData(data, bbox);
  }

 private:
  void addData(DATA *data, const BBOX &bbox) {
    if (bl_tree_) {
      if        (bbox.getRight() <= br_tree_->bbox_.getLeft ()) {
        if        (bbox.getTop   () <= tl_tree_->bbox_.getBottom()) {
          bl_tree_->addData(data, bbox); return;
        } else if (bbox.getBottom() >= bl_tree_->bbox_.getTop   ()) {
          tl_tree_->addData(data, bbox); return;
        }
      } else if (bbox.getLeft () >= bl_tree_->bbox_.getRight()) {
        if        (bbox.getTop   () <= tr_tree_->bbox_.getBottom()) {
          br_tree_->addData(data, bbox); return;
        } else if (bbox.getBottom() >= br_tree_->bbox_.getTop   ()) {
          tr_tree_->addData(data, bbox); return;
        }
      }
    }

    dataList_.push_back(data);

    if (! bl_tree_) {
      uint limit = getAutoSplitLimit();

      if (limit > 0 && dataList_.size() > limit)
        autoSplit();
    }
  }

  //----------

 public:
  // increase size of bounding box of tree (root)
  void grow(const BBOX &bbox) {
    T l, b, r, t;

    if (bbox_.getLeft() > bbox_.getRight()) {
      l = bbox.getLeft  ();
      b = bbox.getBottom();
      r = bbox.getRight ();
      t = bbox.getTop   ();
    }
    else {
      l = std::min(bbox_.getLeft  (), bbox.getLeft  ());
      b = std::min(bbox_.getBottom(), bbox.getBottom());
      r = std::max(bbox_.getRight (), bbox.getRight ());
      t = std::max(bbox_.getTop   (), bbox.getTop   ());
    }

    if (bl_tree_) {
      const BBOX &bl_bbox = bl_tree_->getBBox();
      const BBOX &br_bbox = br_tree_->getBBox();
      const BBOX &tl_bbox = tl_tree_->getBBox();
      const BBOX &tr_bbox = tr_tree_->getBBox();

      bl_tree_->grow(BBOX(l                 , b                  ,
                          bl_bbox.getRight(), bl_bbox.getTop   ()));
      br_tree_->grow(BBOX(br_bbox.getLeft (), b                  ,
                          r                 , br_bbox.getTop   ()));
      tl_tree_->grow(BBOX(l                 , tl_bbox.getBottom(),
                          tl_bbox.getRight(), t                  ));
      tr_tree_->grow(BBOX(tr_bbox.getLeft (), tr_bbox.getBottom(),
                          r                 , t                  ));
    }

    bbox_ = BBOX(l, b, r, t);
  }

  //----------

 public:
  // remove data from tree
  void remove(DATA *data) {
    const BBOX &bbox = data->getBBox();

    assert(inside(bbox));

    removeData(data, bbox);
  }

 private:
  void removeData(DATA *data, const BBOX &bbox) {
    if (bl_tree_) {
      if      (bl_tree_->inside(bbox)) return bl_tree_->removeData(data, bbox);
      else if (br_tree_->inside(bbox)) return br_tree_->removeData(data, bbox);
      else if (tl_tree_->inside(bbox)) return tl_tree_->removeData(data, bbox);
      else if (tr_tree_->inside(bbox)) return tr_tree_->removeData(data, bbox);
    }

    dataList_.remove(data);
  }

  //----------

 public:
  // split tree at point (defining vertical and horizontal split)
  void split(T x, T y) {
    if (bbox_.getLeft() == bbox_.getRight() && bbox_.getBottom() == bbox_.getRight()) return;

    if (! bl_tree_) {
      if (x <= bbox_.getLeft()   || x >= bbox_.getRight() ||
          y <= bbox_.getBottom() || y >= bbox_.getTop()) return;

      BBOX blbbox(bbox_.getLeft(), bbox_.getBottom(), x               , y             );
      BBOX brbbox(x              , bbox_.getBottom(), bbox_.getRight(), y             );
      BBOX tlbbox(bbox_.getLeft(), y                , x               , bbox_.getTop());
      BBOX trbbox(x              , y                , bbox_.getRight(), bbox_.getTop());

      bl_tree_ = new CQuadTree(this, blbbox);
      br_tree_ = new CQuadTree(this, brbbox);
      tl_tree_ = new CQuadTree(this, tlbbox);
      tr_tree_ = new CQuadTree(this, trbbox);

      typename DataList::iterator p1 = dataList_.begin();
      typename DataList::iterator p2 = dataList_.end  ();

      while (p1 != p2) {
        const BBOX &bbox = (*p1)->getBBox();

        if      (bl_tree_->inside(bbox)) bl_tree_->add(*p1);
        else if (br_tree_->inside(bbox)) br_tree_->add(*p1);
        else if (tl_tree_->inside(bbox)) tl_tree_->add(*p1);
        else if (tr_tree_->inside(bbox)) tr_tree_->add(*p1);
        else                             { ++p1; continue; }

        typename DataList::iterator p = p1++;

        dataList_.erase(p);
      }
    }
    else {
      bl_tree_->split(x, y);
      br_tree_->split(x, y);
      tl_tree_->split(x, y);
      tr_tree_->split(x, y);
    }
  }

 public:
  // automatically split tree (1 or more times)
  // the split point is automatically determined from the data
  bool autoSplit(uint n=1) {
    if (n == 0) return false;

    if (! bl_tree_) {
      if (dataList_.size() <= getMinTreeSize()) return false;

      T x, y;

      if (getSplitPoint(x, y)) {
        split(x, y);

        if (bl_tree_) {
          bl_tree_->autoSplit(n - 1);
          br_tree_->autoSplit(n - 1);
          tl_tree_->autoSplit(n - 1);
          tr_tree_->autoSplit(n - 1);
        }
      }
    }
    else {
      bl_tree_->autoSplit(n);
      br_tree_->autoSplit(n);
      tl_tree_->autoSplit(n);
      tr_tree_->autoSplit(n);
    }

    return true;
  }

 private:
  bool getSplitPoint(T &x, T &y) {
    x = (bbox_.getRight() + bbox_.getLeft  ())/2;
    y = (bbox_.getTop  () + bbox_.getBottom())/2;

    return (x != bbox_.getLeft() && y != bbox_.getBottom());
  }

  //-------

 public:
  // get data items inside the specified bounding box
  void getDataInsideBBox(const BBOX &bbox, DataList &dataList) const {
    dataList.clear();

    addDataInsideBBox(bbox, dataList);
  }

  void addDataInsideBBox(const BBOX &bbox, DataList &dataList) const {
    if (! overlaps(bbox))
      return;

    // if tree completely inside, add all items
    if (inside(bbox_, bbox))
      addTreeDataToList(dataList);
    else {
      typename DataList::const_iterator p1, p2;

      for (p1 = dataList_.begin(), p2 = dataList_.end(); p1 != p2; ++p1) {
        const BBOX &bbox1 = (*p1)->getBBox();

        if (inside(bbox1, bbox))
          dataList.push_back(*p1);
      }

      if (bl_tree_) {
        bl_tree_->addDataInsideBBox(bbox, dataList);
        br_tree_->addDataInsideBBox(bbox, dataList);
        tl_tree_->addDataInsideBBox(bbox, dataList);
        tr_tree_->addDataInsideBBox(bbox, dataList);
      }
    }
  }

  //-------

 public:
  // get data items touching the specified bounding box
  void getDataTouchingBBox(const BBOX &bbox, DataList &dataList) const {
    dataList.clear();

    if (overlaps(bbox))
      addDataTouchingBBox(bbox, dataList);
  }

  void addDataTouchingBBox(const BBOX &bbox, DataList &dataList) const {
    // if tree completely inside, add all items
    if (inside(bbox_, bbox))
      addTreeDataToList(dataList);
    else {
      typename DataList::const_iterator p1, p2;

      for (p1 = dataList_.begin(), p2 = dataList_.end(); p1 != p2; ++p1) {
        const BBOX &bbox1 = (*p1)->getBBox();

        if (overlaps(bbox1, bbox))
          dataList.push_back(*p1);
      }

      if (bl_tree_) {
        if (bbox.getLeft() <= br_tree_->bbox_.getLeft()) {
          if (bbox.getBottom() <= tl_tree_->bbox_.getBottom())
            bl_tree_->addDataTouchingBBox(bbox, dataList);
          if (bbox.getTop   () >= bl_tree_->bbox_.getTop())
            tl_tree_->addDataTouchingBBox(bbox, dataList);
        }

        if (bbox.getRight() >= bl_tree_->bbox_.getRight()) {
          if (bbox.getBottom() <= tr_tree_->bbox_.getBottom())
            br_tree_->addDataTouchingBBox(bbox, dataList);
          if (bbox.getTop   () >= br_tree_->bbox_.getTop())
            tr_tree_->addDataTouchingBBox(bbox, dataList);
        }
      }
    }
  }

  //-------

 public:
  // get data items which have the specified point inside them
  void getDataAtPoint(T x, T y, DataList &dataList) const {
    dataList.clear();

    addDataAtPoint(x, y, dataList);
  }

  void addDataAtPoint(T x, T y, DataList &dataList) const {
    if (x < bbox_.getLeft  () || x > bbox_.getRight() ||
        y < bbox_.getBottom() || y > bbox_.getTop  ())
      return;

    typename DataList::const_iterator p1, p2;

    for (p1 = dataList_.begin(), p2 = dataList_.end(); p1 != p2; ++p1) {
      const BBOX &bbox = (*p1)->getBBox();

      if (x >= bbox.getLeft  () && x <= bbox.getRight() &&
          y >= bbox.getBottom() && y <= bbox.getTop  ())
        dataList.push_back(*p1);
    }

    if (bl_tree_) {
      if (x <= br_tree_->bbox_.getLeft()) {
        if (y <= tl_tree_->bbox_.getBottom())
          bl_tree_->addDataAtPoint(x, y, dataList);
        if (y >= bl_tree_->bbox_.getTop())
          tl_tree_->addDataAtPoint(x, y, dataList);
      }

      if (x >= bl_tree_->bbox_.getRight()) {
        if (y <= tr_tree_->bbox_.getBottom())
          br_tree_->addDataAtPoint(x, y, dataList);
        if (y >= br_tree_->bbox_.getTop())
          tr_tree_->addDataAtPoint(x, y, dataList);
      }
    }
  }

  //-------

 public:
  // get tree which has the specified point inside it
  const CQuadTree *getTreeAtPoint(T x, T y) const {
    if (x < bbox_.getLeft  () || x > bbox_.getRight() ||
        y < bbox_.getBottom() || y > bbox_.getTop  ())
      return 0;

    typename DataList::const_iterator p1, p2;

    for (p1 = dataList_.begin(), p2 = dataList_.end(); p1 != p2; ++p1) {
      const BBOX &bbox = (*p1)->getBBox();

      if (x >= bbox.getLeft  () && x <= bbox.getRight() &&
          y >= bbox.getBottom() && y <= bbox.getTop  ())
        return this;
    }

    if (bl_tree_) {
      const CQuadTree *tree = 0;

      if ((tree = bl_tree_->getTreeAtPoint(x, y)) != 0) return tree;
      if ((tree = br_tree_->getTreeAtPoint(x, y)) != 0) return tree;
      if ((tree = tl_tree_->getTreeAtPoint(x, y)) != 0) return tree;
      if ((tree = tr_tree_->getTreeAtPoint(x, y)) != 0) return tree;
    }

    return this;
  }

  //-------

 private:
  void addTreeDataToList(DataList &dataList) const {
    typename DataList::const_iterator p1, p2;

    for (p1 = dataList_.begin(), p2 = dataList_.end(); p1 != p2; ++p1)
      dataList.push_back(*p1);

    if (bl_tree_) {
      bl_tree_->addTreeDataToList(dataList);
      br_tree_->addTreeDataToList(dataList);
      tl_tree_->addTreeDataToList(dataList);
      tr_tree_->addTreeDataToList(dataList);
    }
  }

  //-------

 private:
  // is bbox inside tree
  bool inside(const BBOX &bbox) const {
    assert(bbox.getLeft() <= bbox.getRight() && bbox.getBottom() <= bbox.getTop());

    return inside(bbox, bbox_);
  }

  // does bbox overlap tree
  bool overlaps(const BBOX &bbox) const {
    assert(bbox.getLeft() <= bbox.getRight() && bbox.getBottom() <= bbox.getTop());

    return overlaps(bbox, bbox_);
  }

  // is bbox1 inside bbox2
  static bool inside(const BBOX &bbox1, const BBOX &bbox2) {
    return ((bbox1.getLeft  () >= bbox2.getLeft  () && bbox1.getRight() <= bbox2.getRight()) &&
            (bbox1.getBottom() >= bbox2.getBottom() && bbox1.getTop  () <= bbox2.getTop  ()));
  }

  // does bbox1 overlap bbox2
  static bool overlaps(const BBOX &bbox1, const BBOX &bbox2) {
    return ((bbox1.getRight() >= bbox2.getLeft  () && bbox1.getLeft  () <= bbox2.getRight()) &&
            (bbox1.getTop  () >= bbox2.getBottom() && bbox1.getBottom() <= bbox2.getTop  ()));
  }

  //-------

 public:
  uint numElements() const {
    uint n = dataList_.size();

    if (bl_tree_)
      n = bl_tree_->numElements() + br_tree_->numElements() +
          tl_tree_->numElements() + tr_tree_->numElements();

    return n;
  }

  uint minElements() const {
    uint n = dataList_.size();

    if (bl_tree_)
      n = std::min(std::min(bl_tree_->minElements(), br_tree_->minElements()),
                   std::min(tl_tree_->minElements(), tr_tree_->minElements()));

    return n;
  }

  uint maxElements() const {
    uint n = dataList_.size();

    if (bl_tree_)
      n = std::max(std::max(bl_tree_->maxElements(), br_tree_->maxElements()),
                   std::max(tl_tree_->maxElements(), tr_tree_->maxElements()));

    return n;
  }

  uint getDepth() const {
    return (parent_ ? parent_->getDepth() + 1 : 1);
  }

  uint maxBorder() const {
    if (bl_tree_) {
      uint nd = dataList_.size();
      uint nl = bl_tree_->maxBorder();
      uint nr = br_tree_->maxBorder();
      uint nb = tl_tree_->maxBorder();
      uint nt = tr_tree_->maxBorder();

      return std::max(nd, std::max(nl, std::max(nr, std::max(nb, nt))));
    }
    else
      return 0;
  }

 private:
  static uint *getAutoSplitLimitP() {
    static uint autoSplitLimit = 16;

    return &autoSplitLimit;
  }

  // if tree contains less than or equal to this number of elements don't bother splitting
  static uint *getMinTreeSizeP() {
    static uint minTreeSize = 16;

    return &minTreeSize;
  }

};

#endif
##concat##CQWinWidget.h
#ifndef CQWinWidget_H
#define CQWinWidget_H

#include <QWidget>
#include <QPoint>
#include <QTextEdit>
#include <QLabel>
#include <QTableWidget>
#include <QTreeWidget>

class QMenu;

class CQWinWidget : public QWidget {
  Q_OBJECT

  Q_PROPERTY(DecorationType decorationType READ decorationType WRITE setDecorationType)
  Q_PROPERTY(HeaderSide     headerSide     READ headerSide     WRITE setHeaderSide    )

  Q_ENUMS(DecorationType)
  Q_ENUMS(HeaderSide)

 public:
  enum GeometryOps {
    MoveOp     = (1<<0),
    ResizeOp   = (1<<1),
    RaiseOp    = (1<<2),
    LowerOp    = (1<<3),
    CloseOp    = (1<<4),
    ExpandOp   = (1<<5),
    CollapseOp = (1<<6)
  };

  enum DecorationType {
    NoDecoration           = 0,
    BorderDecoration       = (1<<0),
    HeaderDecoration       = (1<<1),
    HeaderBorderDecoration = (BorderDecoration | HeaderDecoration)
  };

  enum EditMode {
    EDIT_MODE_DRAG,
    EDIT_MODE_CLICK
  };

  enum HeaderSide {
    SideLeft,
    SideRight,
    SideTop,
    SideBottom
  };

  enum Constraint {
    NO_CONSTRAINT,
    VISIBLE_CONSTRAINT,
    UNCLIPPED_CONSTRAINT
  };

 private:
  struct Decoration {
    DecorationType type;
    HeaderSide     header_side;
    int            header_height;
    QRect          header_rect;
    int            border;
    QColor         border_color;

    Decoration(DecorationType type1, HeaderSide header_side1, int header_height1,
               int border1, const QColor &border_color1) :
     type(type1), header_side(header_side1), header_height(header_height1),
     border(border1), border_color(border_color1) {
    }
  };

  struct HeaderButton {
    QIcon icon;
    QRect rect;
    bool  displayed;
    bool  active;
    bool  pressed;

    HeaderButton(const QIcon &icon1=QIcon()) :
     icon(icon1), rect(), displayed(false), active(false), pressed(false) {
    }

    void updateActive(const QPoint &p, bool pressed1) {
      active = rect.contains(p);

      if (active)
        pressed = pressed1;
      else
        pressed = false;
    }

    void draw(QPainter *painter, CQWinWidget *preview);
  };

  struct CloseButton : public HeaderButton {
    CloseButton(const QIcon &icon) : HeaderButton(icon) { }
  };

  struct ExpandButton : public HeaderButton {
    ExpandButton(const QIcon &icon) : HeaderButton(icon) { }
  };

  struct CollapseButton : public HeaderButton {
    CollapseButton(const QIcon &icon) : HeaderButton(icon) { }
  };

  struct State {
    QPoint init_pos;
    QSize  init_size;
    QPoint press_pos;
    bool   moving;
    bool   resizing;
    bool   resize_l, resize_t, resize_r, resize_b;

    State() :
     moving(false), resizing(false) {
    }
  };

 public:
  CQWinWidget(QWidget *parent=0, const char *name=0);

  virtual ~CQWinWidget() { }

  void setChild(QWidget *child);

  void fitChild();

  DecorationType decorationType() const { return decoration_.type; }
  void setDecorationType(DecorationType type) { decoration_.type = type; }

  HeaderSide headerSide() const { return decoration_.header_side; }
  void setHeaderSide(HeaderSide side) { decoration_.header_side = side; }

  void setDecorationHeaderHeight(int height) {
    decoration_.header_height = height;
  }

  void setDecorationBorder(int border) {
    decoration_.border = border;
  }

  void setOps(unsigned int ops) {
    ops_ = ops;
  }

  void setMovable(bool movable) {
    ops_ = (movable ? ops_ | MoveOp : ops_ & ~MoveOp);
  }

  void setResizable(bool resizable) {
    ops_ = (resizable ? ops_ | ResizeOp : ops_ & ~ResizeOp);
  }

  void setClosable(bool closable) {
    ops_ = (closable ? ops_ | CloseOp : ops_ & ~CloseOp);
  }

  void setTransparent(bool flag=true) {
    setAutoFillBackground(! flag);
  }

  void setEditMode(EditMode edit_mode) {
    edit_mode_ = edit_mode;
  }

  void setConstraint(Constraint constraint) {
    constraint_ = constraint;
  }

  void setChildSize(const QSize &size);

  int getX() const;
  int getY() const;

  int getWidth () const;
  int getHeight() const;

  int getHeaderHeight() const;

  void setPos (int x, int y);
  void setSize(int w, int h);

  virtual bool checkMove(QPoint &p) const;

  virtual bool checkGeometry(const QRect &r) const;

  int getBorder() const;

  void drawHeaderButtonH(QPainter *painter, HeaderButton &button, int &x1, int y1, int b1);
  void drawHeaderButtonV(QPainter *painter, HeaderButton &button, int x1, int &y1, int b1);

 private slots:
  void closeSlot();
  void expandSlot();
  void collapseSlot();

 signals:
  void geometryChanging();
  void geometryChanged();

  void closing();
  void closed();
  void expand();
  void collapse();

  void showContextMenu(const QPoint &p);

 private:
  void paintEvent(QPaintEvent *event);

  void moveEvent  (QMoveEvent *event);
  void resizeEvent(QResizeEvent *event);

  void mousePressEvent  (QMouseEvent *event);
  void mouseMoveEvent   (QMouseEvent *event);
  void mouseReleaseEvent(QMouseEvent *event);

  void contextMenuEvent(QContextMenuEvent *event);

  void enterEvent(QEvent *);
  void leaveEvent(QEvent *);

  void setCursor(const uchar *bits, const uchar *mask, int xo, int yo);

 private:
  QWidget *      child_;
  bool           active_;
  bool           pressed_;
  Decoration     decoration_;
  CloseButton    closeButton_;
  ExpandButton   expandButton_;
  CollapseButton collapseButton_;
  State          state_;
  unsigned int   ops_;
  EditMode       edit_mode_;
  Constraint     constraint_;
};

class CQWinWidgetBase {
 public:
  CQWinWidgetBase(QWidget *parent);

  virtual ~CQWinWidgetBase();

  CQWinWidget *widget() const { return widget_; }

  int getX() const { return widget_->x() + widget_->getX(); }
  int getY() const { return widget_->y() + widget_->getY(); }

  int getWidth () const { return widget_->getWidth (); }
  int getHeight() const { return widget_->getHeight(); }

  void setPos (int x, int y) { widget_->setPos (x, y); }
  void setSize(int w, int h) { widget_->setSize(w, h); }

  virtual void show() = 0;
  virtual void hide() = 0;

  virtual void setText(const QString &) { }

  virtual QString getText() const { return ""; }

  virtual void setImageName(const QString &) { }

  virtual QString getImageName() const { return ""; }

  void setEditMode(CQWinWidget::EditMode edit_mode);

 protected:
  CQWinWidget *widget_;
};

class CQWinTextEdit : public QTextEdit, public CQWinWidgetBase {
  Q_OBJECT

 public:
  CQWinTextEdit(QWidget *parent, const char *name=0);

  virtual ~CQWinTextEdit() { }

  void show() { QTextEdit::show(); widget_->show(); }
  void hide() { QTextEdit::hide(); widget_->hide(); }

  void setText(const QString &text) { QTextEdit::setText(text); }

  QString getText() const { return QTextEdit::toPlainText(); }

 signals:
  void valueChanged();
  void geometryChanging();
  void geometryChanged();
};

class CQWinImage : public QLabel, public CQWinWidgetBase {
  Q_OBJECT

 private:
  QString  fileName_;
  QImage   image_;
  QMenu   *menu_;

 public:
  CQWinImage(QWidget *parent, const char *name=0);

  virtual ~CQWinImage() { }

  void show() { QLabel::show(); widget_->show(); }
  void hide() { QLabel::hide(); widget_->hide(); }

  void setImageName(const QString &fileName);

  void setImage(const QImage &image);

  QString getImageName() const { return fileName_; }

  const QImage &getImage() const { return image_; }

 private:
  void contextMenuEvent(QContextMenuEvent *event);

 signals:
  void valueChanged();
  void geometryChanging();
  void geometryChanged();

 public slots:
  void loadImage();
};

class CQWinTable : public QTableWidget, public CQWinWidgetBase {
  Q_OBJECT

 public:
  CQWinTable(QWidget *parent, const char *name=0);

  virtual ~CQWinTable() { }

  void show() { QTableWidget::show(); widget_->show(); }
  void hide() { QTableWidget::hide(); widget_->hide(); }

 signals:
  void valueChanged();
  void geometryChanging();
  void geometryChanged();
};

class CQWinTree : public QTreeWidget, public CQWinWidgetBase {
  Q_OBJECT

 public:
  CQWinTree(QWidget *parent, const char *name=0);

  virtual ~CQWinTree() { }

  void show() { QTreeWidget::show(); widget_->show(); }
  void hide() { QTreeWidget::hide(); widget_->hide(); }

 signals:
  void valueChanged();
  void geometryChanging();
  void geometryChanged();
};

#endif
